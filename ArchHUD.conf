name: ArchHud - Archaegeo v1.515 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        ShowOdometer = true --export:
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        DisplayOrbit = true --export: 
        SetWaypointOnExit = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        showHelp = true --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        AutoShieldToggle = true --export:
        PreventPvP = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        ReEntryPitch = -30 --export:
        LockPitchTarget = 0 --export:
        AutopilotSpaceDistance = 5000 --export:
        TargetOrbitRadius = 1.2 --export:
        LowOrbitHeight = 2000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 100000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        WipeDamage = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        shieldX = 1750 --export:
        shieldY = 250 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 75 --export:
        OrbitMapY = 0 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)local b=require("atlas")script={}VERSION_NUMBER=1.515;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;iphCondition="All"stablized=true;UseExtra="Off"LastVersionUpdate=0.000;local c={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","iphCondition","stablized","UseExtra","SelectedTab"}local d=math.abs;local e=math.floor;local f=string.format;local g=json.decode;local h=json.encode;local j=core.getElementMaxHitPointsById;local k=unit.getAtmosphereDensity;local l=core.getElementMassById;local m=a.control.isRemoteControlled;local n=math.atan;local o=string.match;local q=system.getTime;local vec3=vec3;local r=utils.clamp;local s=a.axisCommandManager;local t=system.destroyWidgetPanel;local u=system.updateData;local v=system.addDataToWidget;local w=system.lockView;local x=system.isViewLocked;local y=math.sqrt;local z=tonumber;local core=core;local function A(B,C)local D=10^(C or 0)return e(B*D+0.5)/D end;local E=q()local F=q()local G=13;local H=SafeR;local I=SafeB;local J=SafeG;local K=0;local L=0;local M=false;local N=0;local O=false;local P=false;local Q=55;local R=false;local S=false;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=0;local a0=false;local a1=false;local a2="empty"local a3=5;local a4=5;local a5=a3;local a6=a4;local a7=false;local a8=0;local a9=0;local aa=0;local ab=0;local ac=nil;local ad=0;local ae=0;local af=0;local ag=0;local ah=0;local ai=3;local aj=0;local ak=""local al=false;local am=false;local an=false;local ao=-1;local ap=""local aq=k()>0;local ar=k()local as=core.getAltitude()local at=core.getElementIdList()local au=q()local av=core.getConstructMass()local aw=false;local ax=nil;local ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]local az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]local aA={}local aB=0;local aC=0;local aD=""local aE=true;local aF={}local aG=ResolutionX;local aH=ResolutionY;local aI={}local aJ={}local aK={}local aL=0;local aM=false;local aN=nil;local aO=nil;local aP=nil;local aQ=nil;local aR=nil;local aS=nil;local aT=nil;local aU=nil;local aV=nil;local aW=nil;local aX=nil;local aY=nil;local aZ=false;local a_=false;local b0=autoRollPreference;local b1=LandingGearGroundHeight;local b2=false;local b3=q()local b4=0;local b5=0;local b6=0;local b7=AtmoSpeedLimit;local b8=0;local b9=nil;local ba=0;local bb=0;local bc=false;local bd=false;local be={VectorToTarget=false}local bf=false;local bg=0;local bh=nil;local bi=false;local bj=false;local bk=false;local bl=false;local bm=0;local bn=vec3(core.getConstructWorldOrientationUp())local bo=vec3(core.getConstructWorldOrientationForward())local bp=vec3(core.getConstructWorldOrientationRight())local bq=vec3(core.getVelocity())local br=vec3(core.getWorldVelocity())local bs=vec3(br):len()local bt=vec3(core.getWorldVertical())local bu=-bt:dot(br)local bv=vec3(core.getConstructWorldPos())local bw=0;local bx=false;local by=false;local bz=nil;local bA=true;local bB=0;local bC=0;local bD=false;local bE={}local bF=showHud;local bG={}local bH=false;local bI=50000;local bJ=""local bK=nil;local bL={}local bM=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local bN=false;local bO=nil;local bP={}local bQ="Atmo"local bR=false;local bS=0;local bT={}function p(bU)system.print(E..": "..bU)end;local function bV(bW,bX,bY)bX=bX:project_on_plane(bW)bY=bY:project_on_plane(bW)return n(bX:cross(bY):dot(bW),bX:dot(bY))end;local function bZ(b_)local D=1;if b_ then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn and aw then local c0=K;K=A(r(K+D*speedChangeLarge/100,-1,1),2)if K>=0 and c0<0 then K=0;aw=false end elseif AltIsOn then if ar>0 or Reentry then b7=r(b7+D*speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity+D*speedChangeLarge/3.6*100,0,8333.00)end else s:updateCommandFromActionStart(axisCommandId.longitudinal,D*speedChangeLarge)end else if Autopilot or VectorToTarget or am or IntoOrbit then bS=bS+1*D*-1;if bS>#bG then bS=1 end;if bS<1 then bS=#bG end else if not b_ then D=1 else D=nil end;aW.adjustAutopilotTargetIndex(D)end end end;local function c1(c2)local c3,c4,c5=aR:getPlanetarySystem(0):castIntersections(bv,c2,function(c6)if c6.noAtmosphericDensityAltitude>0 then return c6.radius+c6.noAtmosphericDensityAltitude else return c6.radius+c6.surfaceMaxAltitude*1.5 end end)local c7=c4;if c5~=nil and c4~=nil then c7=math.min(c5,c4)end;if c7~=nil then return c3,c7 else return nil,nil end end;local function c8(c9,ca,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..c9 .."|"..ca.."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..c9 .."|"..ca.."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..c9 .."|"..ca.."|"..soundVolume)end end;local function cb(cc,cd)for i=1,#cd do cc[#cc+1]=cd[i]end;return cc end;local function ce(cf)local cg={}local ch={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit","AlwaysVSpd","BarFuelDisplay","showHelp","voices","alerts","CollisionSystem","AutoShieldToggle","PreventPvP"}local ci={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","ReEntryPitch","LockPitchTarget","AutopilotSpaceDistance","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization","WipeDamage"}local cj={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","shieldX","shieldY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local ck={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not cf then cb(cg,ch)cb(cg,ci)cb(cg,cj)cb(cg,ck)return cg elseif cf=="boolean"then return ch elseif cf=="handling"then return ci elseif cf=="hud"then return cj elseif cf=="physics"then return ck end end;local function cl(cm,cn,co,cp,cq)if cp==nil then cp=""end;if cq==nil then cq=""end;return f([[<text class="%s" x=%s y=%s style="%s">%s</text>]],cp,cm,cn,cq,co)end;local function cr(cs,ct)if s:getAxisCommandType(0)~=axisCommandType.byThrottle and not ct then a.control.cancelCurrentControlMasterMode()end;s:setThrottleCommand(axisCommandId.longitudinal,cs)K=r(A(cs*100,0)/100,-1,1)bz=nil end;local function cu(cs,ct)if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not ct then a.control.cancelCurrentControlMasterMode()end;s:setTargetSpeedCommand(axisCommandId.longitudinal,cs)bz=cs end;local function cv(cw,cx)if cw==0 then return d(cx)<1e-09 end;if cx==0 then return d(cw)<1e-09 end;return d(cw-cx)<math.max(d(cw),d(cx))*epsilon end;local function cy(aj,cz)local cA=aj>100000;if cz==nil then cz=1 end;if cA then return A(aj/1000/200,cz).."SU"elseif aj<1000 then return A(aj,cz).."M"else return A(aj/1000,cz).."KM"end end;local function cB()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;b0=true;af=0;if aq and ao==-1 then BrakeLanding=false;AltitudeHold=true;af=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cu(e(b7))end else bi=false;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;local function cC()bi=false;ba=nil;bb=nil;bm=0;if ar==0 then if IntoOrbit then c8("orOff","AP")IntoOrbit=false;bc=false;bh=nil;b0=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;be.VectorToTarget=false;be.AutopilotAlign=false;bf=false elseif bM then c8("orOn","AP")IntoOrbit=true;b0=true;if bh==nil then bh=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a2="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;bc=false;bh=nil;b0=autoRollPreference;if AltitudeHold then AltitudeHold=false end;be.VectorToTarget=false;be.AutopilotAlign=false;bf=false end end;local function cD()if E-b5<1.5 then if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;c8("11","EP")else if bM then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bg=HoldAltitude;bf=true;if not IntoOrbit then cC()end;bc=true end end;b5=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else b5=E end;if bM and ar==0 then bg=as;bf=true;bc=true;cC()if IntoOrbit then b5=E else b5=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;a0=false;b0=true;LockPitch=nil;bi=false;if ao~=-1 and bs<20 then c8("lfs","LS")AutoTakeoff=true;if b5>-1 then HoldAltitude=as+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;s:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bx then cB()end else c8("altOn","AH")AutoTakeoff=false;if b5>-1 then if bM then HoldAltitude=as end end;if VertTakeOff then cB()end end;if am then HoldAltitude=100000 end else c8("altOff","AH")if IntoOrbit then cC()end;if VertTakeOff then cB()end;b0=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;b5=0 end end;local function cE(cF)if cF then am=false;Autopilot=false;AutopilotRealigned=false;P=false;HoldAltitude=as;TargetSet=false end;VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bK=nil;if not by then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then cB()end;if IntoOrbit then cC()end;b0=autoRollPreference;al=false;an=false;af=0 end;local function cG()local function cH(SpaceTarget)bN=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cD()end end;VectorStatus="Proceeding to Waypoint"end;if E-b6<1.5 and ar>0 then if not bl then a2="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;c8("orH","OH")end;b6=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else b6=E end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not am and not IntoOrbit then if 0.5*a:maxForceForward()/core.g()<av then a2="WARNING: Heavy Loads may affect autopilot performance."ai=5 end;aW.UpdateAutopilotTarget()aX.showWayPoint(ac,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then c8("apSpc","AP")if ar~=0 then am=true;cD()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if ar>0 then if not VectorToTarget then c8("vtt","AP")cH(SpaceTarget)end else c8("apOn","AP")if not(ac.name==planet.name and as<AutopilotTargetOrbit*1.5)then bi=false;Autopilot=true elseif not aq then if IntoOrbit then cC()end;bg=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bf=true;be.AutopilotAlign=true;be.VectorToTarget=true;bc=false;if not IntoOrbit then cC()end end end else c8("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if ar~=0 then am=true;cD()else Autopilot=true end end elseif ar==0 then if CustomTarget==nil and(ac.name==planet.name and bM)and not IntoOrbit then WaypointSet=false;bi=false;bc=false;cC()else c8("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;a0=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;P=false;LockPitch=nil;WaypointSet=false end else c8("apP","AP")am=true;cD()end else c8("apOff","AP")cE(1)end end;local function cI()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;b0=autoRollPreference end;if BrakeIsOn then c8("bkOn","B",1)cE()else c8("bkOff","B",1)end end;local function cJ()if Reentry then a2="Re-Entry cancelled"c8("reOff","RE")Reentry=false;b0=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a2="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ai=5 elseif not R then Reentry=true;if s:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;b0=true;BrakeIsOn=false;a2="Beginning Parachute Re-Entry - Strap In.  Target speed: "..b7;c8("par","RE")else Reentry=true;AltitudeHold=true;b0=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local co=cy(HoldAltitude)a2="Beginning Re-entry.  Target speed: "..b7 .." Target Altitude: "..co;c8("glide","RE")cu(e(b7))end;AutoTakeoff=false end;local function cK()if antigrav and not ExternalAGG then if by then c8("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;c8("aggOn","AG")antigrav.activate()antigrav.show()end end end;local function cL(cM)local cN=0;local cO=0;local cP=0;if cM<60 then cM=e(cM)elseif cM<3600 then cN=e(cM/60)cM=e(cM%60)elseif cM<86400 then cO=e(cM/3600)cN=e(cM%3600/60)else cP=e(cM/86400)cO=e(cM%86400/3600)end;if cP>0 then return cP.."d "..cO.."h "elseif cO>0 then return cO.."h "..cN.."m "elseif cN>0 then return cN.."m "..cM.."s"elseif cM>0 then return cM.."s"else return"0s"end end;local function cQ(cR)local function cS(cT)for cU,cV in pairs(cT)do dbHud_1.setStringValue(cV,h(_G[cV]))if cR and dbHud_2 then dbHud_2.setStringValue(cV,h(_G[cV]))end end end;if dbHud_1 then cS(c)cS(ce())system.print("Saved Variables to Datacore")if cR and dbHud_2 then a2="Databank copied.  Remove copy when ready."end end end;local function cW()local function cX(cY)return type(cY)=='number'end;local function cZ(cY)return type(z(cY))=='number'end;local function c_(d0)return type(d0)=='table'end;local function d1(d2)return type(d2)=='string'end;local function d3(cV)return c_(cV)and cX(cV.x and cV.y and cV.z)end;local function d4(d5)return c_(d5)and cX(d5.latitude and d5.longitude and d5.altitude and d5.id and d5.systemId)end;local d6=math.pi/180;local d7=180/math.pi;local epsilon=1e-10;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local d8='::pos{'..B..','..B..','..B..','..B..','..B..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function d9(cY)local da=string.gsub(string.reverse(f('%.4f',cY)),'^0*%.?','')return da==''and'0'or string.reverse(da)end;local function db(dc)if d3(dc)then return f('{x=%.3f,y=%.3f,z=%.3f}',dc.x,dc.y,dc.z)end;if c_(dc)and not getmetatable(dc)then local dd={}local de=next(dc)if type(de)=='nil'or de==1 then dd=dc else for cU,cV in pairs(dc)do local cs=db(cV)if type(cU)=='number'then table.insert(dd,f('[%s]=%s',cU,cs))else table.insert(dd,f('%s=%s',cU,cs))end end end;return f('{%s}',table.concat(dd,','))end;if d1(dc)then return f("'%s'",dc:gsub("'",[[\']]))end;return tostring(dc)end;local df={}df.__index=df;df.__tostring=function(dc,dg)local dh={}for cU in pairs(dc)do table.insert(dh,cU)end;table.sort(dh)local dd={}for _,cU in ipairs(dh)do local cs=db(dc[cU])if type(cU)=='number'then table.insert(dd,f('[%s]=%s',cU,cs))else table.insert(dd,f('%s=%s',cU,cs))end end;if dg then return f('%s%s',dg,table.concat(dd,',\n'..dg))end;return f('{%s}',table.concat(dd,','))end;df.__eq=function(di,dj)return di.systemId==dj.systemId and di.id==dj.id and cv(di.radius,dj.radius)and cv(di.center.x,dj.center.x)and cv(di.center.y,dj.center.y)and cv(di.center.z,dj.center.z)and cv(di.GM,dj.GM)end;local function dk(dl,dm,dn,dp,dq)assert(cZ(dl),'Argument 1 (systemId) must be a number:'..type(dl))assert(cZ(dm),'Argument 2 (id) must be a number:'..type(dm))assert(cZ(dn),'Argument 3 (radius) must be a number:'..type(dn))assert(c_(dp),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dp))assert(cZ(dq),'Argument 5 (GM) must be a number:'..type(dq))return setmetatable({systemId=z(dl),id=z(dm),radius=z(dn),center=vec3(dp),GM=z(dq)},df)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(p)return f('::pos{%d,%d,%s,%s,%s}',p.systemId,p.id,d9(p.latitude*d7),d9(p.longitude*d7),d9(p.altitude))end;MapPosition.__eq=function(di,dj)return di.id==dj.id and di.systemId==dj.systemId and cv(di.latitude,dj.latitude)and cv(di.altitude,dj.altitude)and(cv(di.longitude,dj.longitude)or cv(di.latitude,math.pi/2)or cv(di.latitude,-math.pi/2))end;local function dr(ds,dm,dt,du,dv)local dl=ds;if d1(ds)and not du and not dv and not dm and not dt then dl,dm,dt,du,dv=o(ds,d8)assert(dl,'Argument 1 (position string) is malformed.')else assert(cZ(dl),'Argument 1 (systemId) must be a number:'..type(dl))assert(cZ(dm),'Argument 2 (id) must be a number:'..type(dm))assert(cZ(dt),'Argument 3 (latitude) must be in degrees:'..type(dt))assert(cZ(du),'Argument 4 (longitude) must be in degrees:'..type(du))assert(cZ(dv),'Argument 5 (altitude) must be in meters:'..type(dv))end;dl=z(dl)dm=z(dm)dt=z(dt)du=z(du)dv=z(dv)if dm==0 then return setmetatable({latitude=dt,longitude=du,altitude=dv,id=dm,systemId=dl},MapPosition)end;return setmetatable({latitude=d6*r(dt,-90,90),longitude=d6*(du%360),altitude=dv,id=dm,systemId=dl},MapPosition)end;local dw={}dw.__index=dw;dw.__tostring=function(dc,dg)local dx=dg and dg..'  'local dy={}local dh={}for cU in pairs(dc)do table.insert(dh,cU)end;table.sort(dh)for _,dz in ipairs(dh)do bdy=dc[dz]local dA=df.__tostring(bdy,dx)if dg then table.insert(dy,f('[%s]={\n%s\n%s}',dz,dA,dg))else table.insert(dy,f('  [%s]=%s',dz,dA))end end;if dg then return f('\n%s%s%s',dg,table.concat(dy,',\n'..dg),dg)end;return f('{\n%s\n}',table.concat(dy,',\n'))end;local function dB(dC)local b={}local pid;for _,cV in pairs(dC)do local dm=cV.planetarySystemId;if type(dm)~='number'then error('Invalid planetary system ID: '..tostring(dm))elseif pid and dm~=pid then error('Mistringmatch planetary system IDs: '..dm..' and '..pid)end;local dD=cV.bodyId;if type(dD)~='number'then error('Invalid body ID: '..tostring(dD))elseif b[dD]then error('Duplicate body ID: '..tostring(dD))end;setmetatable(cV.center,getmetatable(vec3.unit_x))b[dD]=setmetatable(cV,df)pid=dm end;return setmetatable(b,dw)end;aQ={}local function dE(dC)return setmetatable({galaxyAtlas=dC or{}},aQ)end;aQ.__index=function(d0,i)if type(i)=='number'then local system=d0.galaxyAtlas[i]return dB(system)end;return rawget(aQ,i)end;aQ.__pairs=function(dc)return function(d0,cU)local dF,nv=next(d0,cU)return dF,nv and dB(nv)end,dc.galaxyAtlas,nil end;aQ.__tostring=function(dc)local dG={}for _,dH in pairs(dc or{})do local dI=dH:getPlanetarySystemId()local dJ=dw.__tostring(dH,'    ')table.insert(dG,f('  [%s]={%s\n  }',dI,dJ))end;return f('{\n%s\n}\n',table.concat(dG,',\n'))end;aQ.BodyParameters=dk;aQ.MapPosition=dr;aQ.PlanetarySystem=dB;function aQ.createBodyParameters(dl,dm,dK,dL,dM,dN,dO)assert(cZ(dl),'Argument 1 (systemId) must be a number:'..type(dl))assert(cZ(dm),'Argument 2 (id) must be a number:'..type(dm))assert(cZ(dK),'Argument 3 (surfaceArea) must be a number:'..type(dK))assert(c_(dL),'Argument 4 (aPosition) must be an array or vec3:'..type(dL))assert(c_(dM),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(dM))assert(cZ(dN),'Argument 6 (altitude) must be in meters:'..type(dN))assert(cZ(dO),'Argument 7 (gravityAtPosition) must be number:'..type(dO))local dn=y(dK/4/math.pi)local aj=dn+dN;local dP=vec3(dL)+aj*vec3(dM)local dq=dO*aj*aj;return dk(dl,dm,dn,dP,dq)end;aQ.isMapPosition=d4;function aQ:getPlanetarySystem(ds)if i==nil then i=0 end;if nv==nil then nv=0 end;local dl=ds;if d4(ds)then dl=ds.systemId end;if type(dl)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=dw then system=dB(system)end;return system end end end;function dw:sizeCalculator(c6)return 1.05*c6.radius end;function dw:castIntersections(dQ,dR,dS,dT,dU,dV)local dW={}local dX=dU or self;for _,c6 in pairs(dX)do table.insert(dW,c6)end;if not dV then table.sort(dW,function(dY,dZ)return(dY.center-dQ):len()<(dZ.center-dQ):len()end)end;local d_=dR:normalize()for _,c6 in ipairs(dW)do local e0=c6.center-dQ;local dn=self:sizeCalculator(c6)local e1=e0:dot(d_)local e2=e1^2-(e0:len2()-dn^2)if e2>=0 then local e3=y(e2)local c4=e1+e3;local c5=e1-e3;if c5>0 then return c6,c4,c5 elseif c4>0 then return c6,c4,nil end end end;return nil,nil,nil end;function dw:closestBody(e4)assert(type(e4)=='table','Invalid coordinates.')local e5,c6;local e6=vec3(e4)for _,e7 in pairs(self)do local e8=(e7.center-e6):len2()if(not c6 or e8<e5)and e7.name~="Space"then c6=e7;e5=e8 end end;return c6 end;function dw:convertToBodyIdAndWorldCoordinates(ds)local e9=ds;if d1(ds)then e9=dr(ds)end;if e9.id==0 then return 0,vec3(e9.latitude,e9.longitude,e9.altitude)end;local e7=self:getBodyParameters(e9)if e7 then return e9.id,e7:convertToWorldCoordinates(e9)end end;function dw:getBodyParameters(ds)local dm=ds;if d4(ds)then dm=ds.id end;assert(cZ(dm),'Argument 1 (id) must be a number:'..type(dm))return self[dm]end;function dw:getPlanetarySystemId()local _,cV=next(self)return cV and cV.systemId end;function df:convertToMapPosition(dp)assert(c_(dp),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dp))local ea=vec3(dp)if self.id==0 then return setmetatable({latitude=ea.x,longitude=ea.y,altitude=ea.z,id=0,systemId=self.systemId},MapPosition)end;local eb=ea-self.center;local aj=eb:len()local dv=aj-self.radius;local dt=0;local du=0;if not cv(aj,0)then local ec=n(eb.y,eb.x)du=ec>=0 and ec or 2*math.pi+ec;dt=math.pi/2-math.acos(eb.z/aj)end;return setmetatable({latitude=dt,longitude=du,altitude=dv,id=self.id,systemId=self.systemId},MapPosition)end;function df:convertToWorldCoordinates(ds)local e9=d1(ds)and dr(ds)or ds;if e9.id==0 then return vec3(e9.latitude,e9.longitude,e9.altitude)end;assert(d4(e9),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(e9.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(e9.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local ed=math.cos(e9.latitude)return self.center+(self.radius+e9.altitude)*vec3(ed*math.cos(e9.longitude),ed*math.sin(e9.longitude),math.sin(e9.latitude))end;function df:getAltitude(dp)return(vec3(dp)-self.center):len()-self.radius end;function df:getDistance(dp)return(vec3(dp)-self.center):len()end;function df:getGravity(dp)local ee=self.center-vec3(dp)local ef=ee:len2()return self.GM/ef*ee/y(ef)end;return setmetatable(aQ,{__call=function(_,...)return dE(...)end})end;local function eg()local aS={}local eh=30000000/3600;local ei=eh*eh;local ej=100;function aS.computeAccelerationTime(ek,el,em)local en=eh*math.asin(ek/eh)return(eh*math.asin(em/eh)-en)/el end;function aS.computeDistanceAndTime(ek,em,eo,ep,eq,er)eq=eq or 0;er=er or 0;local es=ek<=em;local et=ep*(es and 1 or-1)/eo;local eu=-er/eo;local ev=et+eu;if es and ev<=0 or not es and ev>=0 then return-1,-1 end;local ew,ex=0,0;if et~=0 and eq>0 then local en=math.asin(ek/eh)local ey=math.pi*(et/2+eu)local ez=et*eq;local eA=eh*math.pi;local cV=function(d0)local eB=(ey*d0-ez*math.sin(math.pi*d0/2/eq)+eA*en)/eA;local eC=math.tan(eB)return eh*eC/y(eC*eC+1)end;local eD=es and function(d2)return d2>=em end or function(d2)return d2<=em end;ex=2*eq;if eD(cV(ex))then local eE=0;while d(ex-eE)>0.5 do local d0=(ex+eE)/2;if eD(cV(d0))then ex=d0 else eE=d0 end end end;local eF=ek;local eG=ex/ej;for eH=1,ej do local eI=cV(eH*eG)ew=ew+(eI+eF)*eG/2;eF=eI end;if ex<2*eq then return ew,ex end;ek=eF end;local en=eh*math.asin(ek/eh)local E=(eh*math.asin(em/eh)-en)/ev;local eJ=ei*math.cos(en/eh)/ev;local aj=eJ-ei*math.cos((ev*E+en)/eh)/ev;return aj+ew,E+ex end;function aS.computeTravelTime(ek,el,aj)if aj==0 then return 0 end;if el>0 then local en=eh*math.asin(ek/eh)local eJ=ei*math.cos(en/eh)/el;return(eh*math.acos(el*(eJ-aj)/ei)-en)/el end;if ek==0 then return-1 end;assert(ek>0,'Acceleration and initial speed are both zero.')return aj/ek end;return aS end;local function eK()local vec3=require('cpml.vec3')local cW=cW()local function d1(d2)return type(d2)=='string'end;local function c_(d0)return type(d0)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(dv)assert(self.body)local aj=dv+self.body.radius;if not cv(aj,0)then local orbit=y(self.body.GM/aj)return y(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(ds,eL)assert(self.body)assert(c_(ds)or d1(ds))assert(c_(eL))local eM=(d1(ds)or cW.isMapPosition(ds))and self.body:convertToWorldCoordinates(ds)or vec3(ds)local cV=vec3(eL)local eN=eM-self.body.center;local eO=cV:len2()local eP=eN:len()local eQ=self.body.GM;local eR=((eO-eQ/eP)*eN-eN:dot(cV)*cV)/eQ;local cw=eQ/(2*eQ/eP-eO)local eS=eR:len()local d_=eR:normalize()local eT=cw*(1-eS)local eU=cw*(1+eS)local eV=eT*d_+self.body.center;local eW=eS<=1 and-eU*d_+self.body.center or nil;local eX=y(cw*eQ*(1-eS*eS))local eY=eW and 2*math.pi*y(cw^3/eQ)local eZ=math.acos(eR:dot(eN)/(eS*eP))if eN:dot(cV)<0 then eZ=-(eZ-2*math.pi)end;local e_=math.acos((math.cos(eZ)+eS)/(1+eS*math.cos(eZ)))local f0=e_;if f0<0 then f0=f0+2*math.pi end;local f1=f0-eS*math.sin(f0)local f2=0;local f3=0;local f4=0;if eY~=nil then f2=f1/(2*math.pi/eY)f3=eY-f2;f4=f3+eY/2;if eZ-math.pi>0 then f3=f2;f4=f3+eY/2 end;if f4>eY then f4=f4-eY end end;return{periapsis={position=eV,speed=eX/eT,circularOrbitSpeed=y(eQ/eT),altitude=eT-self.body.radius},apoapsis=eW and{position=eW,speed=eX/eU,circularOrbitSpeed=y(eQ/eU),altitude=eU-self.body.radius},currentVelocity=cV,currentPosition=eM,eccentricity=eS,period=eY,eccentricAnomaly=e_,meanAnomaly=f1,timeToPeriapsis=f3,timeToApoapsis=f4,trueAnomaly=eZ}end;local function f5(f6)local e7=cW.BodyParameters(f6.systemId,f6.id,f6.radius,f6.center,f6.GM)return setmetatable({body=e7},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return f5(...)end})end;local function f7()local f8={}local f9={}local fa={XS=13,S=27,M=55,L=110,XL=221}local fb={}local fc;local fd;local fe;local ff;local fg;local function fh()local function fi(fj,fk,fl,fm,fn,fo,fp,fq)fk,fm,fo,fq=vec3(fk),vec3(fm),vec3(fo),vec3(fq)local fr,fs,ft=fj*fj,fl*fl,fn*fn;local eO=fm-fk;local fu=eO:normalize()local fv=eO:len()local fw=fo-fk;local fx=(fw-fw:project_on(fu)):normalize()local fy,fz=fw:dot(fu),fw:dot(fx)local fA=fy*fy+fz*fz;local fB=fu:cross(fx)local cm=(fr-fs+fv*fv)/(2*fv)local cn=(fr-ft+fA-2*fy*cm)/(2*fz)local d5=fr-cm^2-cn^2;local fC=y(d5)local fD=fk+fu*cm+fx*cn+fB*fC;local fE=fk+fu*cm+fx*cn-fB*fC;if d((fq-fD):len()-fp)<d((fq-fE):len()-fp)then return fD else return fE end end;local function fF()local function fG()local fH=core.getConstructWorldOrientationRight()local eO=core.getConstructWorldOrientationForward()local fw=core.getConstructWorldOrientationUp()local fI=library.systemResolution3(fH,eO,fw,{1,0,0})local fJ=library.systemResolution3(fH,eO,fw,{0,1,0})local fK=library.systemResolution3(fH,eO,fw,{0,0,1})return function(fL)return library.systemResolution3(fI,fJ,fK,fL)end end;local fM=fG()local fN=core.getConstructWorldPos()local eM=core.getElementPositionById(1)local fO={eM[1],eM[2],eM[3]}local fP=fM(fO)local fQ={fN[1]-fP[1],fN[2]-fP[2],fN[3]-fP[3]}return fQ end;local function fR(fS,eP,fT)local fU=fS.pts;local fV=#fU;local fW=fS.ref;if fV>3 then local fX,fY,fZ,f_=fU[fV],fU[fV-1],fU[fV-2],fU[fV-3]fS.ref=fT;local eM=fi(fX[1],fX[2],fY[1],fY[2],fZ[1],fZ[2],f_[1],f_[2])local cm,cn,fC=eM.x,eM.y,eM.z;if cm==cm and cn==cn and fC==fC then cm=cm+fW[1]cn=cn+fW[2]fC=fC+fW[3]local g0=vec3(cm,cn,fC)if not fS.lastPos then fS.center=g0 elseif(fS.lastPos-g0):len()<2 then fS.center=g0;fS.skipCalc=true end;fS.lastPos=g0 end;fS.pts={}else local g1={fT[1]-fW[1],fT[2]-fW[2],fT[3]-fW[3]}fU[fV+1]={eP,g1}end end;if bP[1]then fc=#bP[1].getConstructIds()local g2=bP[1].getData()local g3=g2:gmatch('{"constructId[^}]*}[^}]*}')if fc>0 then local fT=fF()local g4,g5=0,0;fg,ff=0,0;for cV in g3 do local dm,aj,g6=cV:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local g7=fa[g6]aj=z(aj)if bP[1].hasMatchingTransponder(dm)==1 then table.insert(f9,dm)end;local g8=bP[1].getConstructType(dm)if CollisionSystem then if g7>27 or g8=="static"or g8=="space"then fg=fg+1;local g9=bP[1].getConstructName(dm)local fS=bL[dm]if fS==nil then g7=g7+G;bL[dm]={pts={},ref=fT,name=g9,i=0,radius=g7,skipCalc=false}fS=bL[dm]end;if not fS.skipCalc then fR(fS,aj,fT)g5=g5+1 end;if fS.center then table.insert(fb,fS)end end;g4=g4+1;if bM and g4>700 or g5>70 or(not bM and g4>300 or g5>30)then coroutine.yield()g4,g5=0,0 end end end;ff=#fb;if ff>0 and bs>20 then local c6,ga,gb,gc;local gd=0;local ge=aR:getPlanetarySystem(0)gc=br:normalize()while gd<ff do coroutine.yield()local gf={table.unpack(fb,gd,math.min(gd+75,ff))}c6,ga,gb=ge:castIntersections(bv,gc,nil,nil,gf,true)if c6 and gb then bO={c6,ga,gb}break end;gd=gd+75 end;if not c6 then bO=nil end else bO=nil end;fb={}fd=g2:find('identifiedConstructs":%[%]')else fe=g2:find('worksInEnvironment":false')end end end;local function gg()if bP[1]then bQ="Atmo"if bP[1].getData():find('worksInAtmosphere":false')then bQ="Space"end end end;function f8.pickType()gg()end;function f8.assignRadar()if radar_1 and bP[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then bP[1]=radar_2 end;if bP[1]==radar_2 then gg()end elseif radar_2 and bP[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then bP[1]=radar_1 end;if bP[1]==radar_1 then gg()end end end;function f8.UpdateRadar()local gh=coroutine.status(UpdateRadarCoroutine)if gh=="suspended"then local cs,gi=coroutine.resume(UpdateRadarCoroutine)if gi then system.print("ERROR UPDATE RADAR: "..gi)end elseif gh=="dead"then UpdateRadarCoroutine=coroutine.create(fh)local cs,gi=coroutine.resume(UpdateRadarCoroutine)end end;function f8.GetRadarHud()local gj=f9;f9={}return fd,fe,fc,ff,fg,gj end;UpdateRadarCoroutine=coroutine.create(fh)return f8 end;local function gk(cV)if aG==1920 then return cV else return A(aG*cV/1920,0)end end;local function gl(cV)if aH==1080 then return cV else return A(aH*cV/1080,0)end end;local function gm()local gn=9.80665;local go=vec3({13771471,7435803,-128971})local gp=18000000;local gq=500000;local gr,gs=math.huge;local gt;local function gu(gv)gr=vec3(gv):dist(go)if gr<gp then return true,d(gr-gp)end;gs=vec3(gv):dist(vec3(planet.center))if gs<gq then gt=true else gt=false end;if d(gs-gq)<d(gr-gp)then return gt,d(gs-gq)else return gt,d(gr-gp)end end;local function gw()return x()==0 and userControlScheme~="keyboard"and m()==0 end;local function gx()local gy="TRAVEL"if not bA then gy="CRUISE"end;if Autopilot then gy="AUTOPILOT"end;return gy end;local gz=""local gA=""local gB=""local gC=1;local gD=2;local gE=3;local gF=4;local gG=5;local gH=6;local gI=""local gJ=0;local gK=e(1/apTickRate)*2*hudTickRate;local gL={}local gM={}local gN={}local gO={}local gP={}local gQ={}local function gR(cm,gS,gT,gU,gV,gW)local gX=tankY;local gY=tankY+5;if not BarFuelDisplay then gY=gY+5 end;if m()==1 and not RemoteHud then gX=gX-50;gY=gY-50 end;if gT=="ATMO"then gI="atmofueltank"elseif gT=="SPACE"then gI="spacefueltank"else gI="rocketfueltank"end;gJ=_G[gI.."_size"]if#gU>0 then for i=1,#gU do local g9=string.sub(gU[i][gD],1,12)local gZ=0;for g_=1,gJ do if gU[i][gD]==g(unit[gI.."_"..g_].getData()).name then gZ=g_;break end end;local h0=q()if gV[i]==nil or gW[i]==nil or h0-gU[i][gH]>gK then local h1;local h2=0;if gZ~=0 then gW[i]=g(unit[gI.."_"..gZ].getData()).percentage;gV[i]=g(unit[gI.."_"..gZ].getData()).timeLeft;if gV[i]=="n/a"then gV[i]=0 end else h2=l(gU[i][gC])-gU[i][gF]gW[i]=e(0.5+h2*100/gU[i][gE])h1=gU[i][gG]if h1<=h2 then gV[i]=0 else gV[i]=e(0.5+h2/((h1-h2)/(h0-gU[i][gH])))end;gU[i][gG]=h2;gU[i][gH]=h0 end end;if g9==gS then g9=f("%s %d",gT,i)end;if gZ==0 then g9=g9 .." *"end;local h3;if gV[i]==0 then h3=""else h3=cL(gV[i])end;if gW[i]~=nil then local h4=e(gW[i]*2.55)local h5=f("rgb(%d,%d,%d)",255-h4,h4,0)local cp=""if h3~=""and gV[i]<120 or gW[i]<5 then cp="red "end;local h6=f("rgb(%d,%d,%d)",r(e((255-h4)/2.55),50,100),r(e(h4/2.55),0,50),50)if BarFuelDisplay then gA=gA..f([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="20" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%% %s</text>
                                            </g>]],h6,cm,gY,h5,e(gW[i]*1.7+0.5),cm,gY,cm+5,gY+14,g9,gW[i],h3)gX=gX-22;gY=gY-22 else gA=gA..cl(cm,gX,g9,cp.."pdim txtfuel")gA=gA..cl(cm,gY,f("%d%% %s",gW[i],h3),"pdim txtfuel","fill:"..h5)gX=gX+30;gY=gY+30 end end end end;tankY=gX end;local function h7(h8,dv)if dv<200000 and not aq or dv and aq then local h9=0;if d(bu)>1 then h9=45*math.log(d(bu),10)if bu<0 then h9=-h9 end end;h8[#h8+1]=f([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,e(bu),e(h9))end;return h8 end;local function ha(hb)local hc=-bt;hb=hb-hb:project_on(hc)local hd=vec3(0,0,1)hd=hd-hd:project_on(hc)local he=hd:cross(hc)local h9=hd:angle_between(hb)*constants.rad2deg;if hb:dot(he)<0 then h9=360-h9 end;return h9 end;local function hf(h8,centerX,centerY,hg,hh,bM)local hi=circleRad;local hj=20;local hk=e(hg)if bM then for i=-45,45,5 do local hl=i;h8[#h8+1]=f([[<g transform="rotate(%f,%d,%d)">]],hl,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;h8[#h8+1]=f([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+hi+hj-len,centerX,centerY+hi+hj)end;h8[#h8+1]=cl(centerX,centerY+hi+hj-35,hh,"pdim txt txtmid")h8[#h8+1]=cl(centerX,centerY+hi+hj-25,hk.." deg","pdim txt txtmid")h8[#h8+1]=f([[<g transform="rotate(%f,%d,%d)">]],-hg,centerX,centerY)h8[#h8+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+hi+hj-20,centerX+5,centerY+hi+hj-20,centerX,centerY+hi+hj-15)h8[#h8+1]="</g>"end;h8[#h8+1]=[[<g style="clip-path: url(#headingClip);">]]local hm=hk;if bM then hm=ha(bo)end;local hn=20;local ho=e(hm)local hp=0;local hq=centerY+hi+hj+20;local hr=centerX;if hh~="YAW"then hq=gl(130)hr=gk(960)end;local hs=[[<path class="txttick line" d="]]local ht=e(ho-(hn+10)-ho%5+0.5)for i=ht+70,ht,-5 do local cm=hr-(-i*5+hm*5)if i%10==0 then hp=10;local B=i;if B==360 then B=0 elseif B>360 then B=B-360 elseif B<0 then B=B+360 end;h8[#h8+1]=cl(cm,hq+15,B,"txtmid bright")elseif i%5==0 then hp=5 end;if hp==10 then hs=f([[%s M %f %f v %d]],hs,cm,hq-5,hp)else hs=f([[%s M %f %f v %d]],hs,cm,hq-2.5,hp)end end;h8[#h8+1]=hs..[["/>]]h8[#h8+1]=f([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],hr-5,hq-20,hr+5,hq-20,hr,hq-10)if bM then hh="HDG"end;h8[#h8+1]=cl(gk(960),gl(100),ho.."°","dim txt txtmid size14","")h8[#h8+1]=cl(gk(960),gl(85),hh,"dim txt txtmid size20","")h8[#h8+1]=[[</g>]]end;local function hu(h8,hv,hg,centerX,centerY,bM,hw,eI)local hi=circleRad;local hx=e(hi*3/5)if hi>0 then local hy=e(hv)local len=0;local hs=f([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*hg,centerX,centerY)if not aq then hs=f([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;h8[#h8+1]=f([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],hi-1,centerX,centerY)h8[#h8+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=e(hy-30-hy%5+0.5),e(hy+30+hy%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local cn=centerY+-i*5+hv*5;if len==30 then hs=f([[%s M %d %f h %d]],hs,centerX-hx-len,cn,len)if aq then h8[#h8+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*hg,centerX,centerY,centerX-hx+10,cn+4,i)h8[#h8+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*hg,centerX,centerY,centerX+hx-10,cn+4,i)if i==0 or i==180 or i==-180 then h8[#h8+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*hg,centerX,centerY,centerX-hx+20,cn,hx*2-40)end else h8[#h8+1]=cl(centerX-hx+10,cn,i,"pdim txt txtmid")h8[#h8+1]=cl(centerX+hx-10,cn,i,"pdim txt txtmid")end;hs=f([[%s M %d %f h %d]],hs,centerX+hx,cn,len)else hs=f([[%s M %d %f h %d]],hs,centerX-hx-len,cn,len)hs=f([[%s M %d %f h %d]],hs,centerX+hx,cn,len)end end;h8[#h8+1]=hs..[["/>]]local hz="PITCH"if not bM then hz="REL PITCH"end;if hv>90 and not aq then hv=90-(hv-90)elseif hv<-90 and not aq then hv=-90-(hv+90)end;if hi>200 then if aq then if eI>Q then h8[#h8+1]=cl(centerX,centerY-15,"Yaw","pdim txt txtmid")h8[#h8+1]=cl(centerX,centerY+20,hw,"pdim txt txtmid")end;h8[#h8+1]=f([[<g transform="rotate(%f,%d,%d)">]],-hg,centerX,centerY)else h8[#h8+1]=f([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;h8[#h8+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-hx+25,centerY-5,centerX-hx+20,centerY,centerX-hx+25,centerY+5,centerX-hx+50,centerY+4,hy)h8[#h8+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+hx-25,centerY-5,centerX+hx-20,centerY,centerX+hx-25,centerY+5,centerX+hx-30,centerY+4,hy)h8[#h8+1]="</g>"end;local hA=e(hi/3)h8[#h8+1]=f([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-hA,centerY,hi-hA)if not aq and bM then h8[#h8+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*hg,centerX,centerY,centerX-hx+10,centerY,hx*2-20)end;h8[#h8+1]="</g>"if hi<200 then if aq and eI>Q then h8[#h8+1]=cl(centerX,centerY-hi,hz,"pdim txt txtmid")h8[#h8+1]=cl(centerX,centerY-hi+10,hy,"pdim txt txtmid")h8[#h8+1]=cl(centerX,centerY-15,"Yaw","pdim txt txtmid")h8[#h8+1]=cl(centerX,centerY+20,hw,"pdim txt txtmid")else h8[#h8+1]=cl(centerX,centerY-hi,hz,"pdim txt txtmid")h8[#h8+1]=cl(centerX,centerY-hi+15,hy,"pdim txt txtmid")end end end end;local function hB(h8,dv,bM)local hC=altMeterX;local hD=altMeterY;local hE=78;local hF=19;local hG=ao;if ao~=-1 then h8[#h8+1]=cl(hC+hE,hD+hF+20,f("AGL: %.1fm",ao),"pdim altsm txtend")end;if bM and(dv<200000 and not aq or dv and aq)then table.insert(h8,f([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],hC-1,hD-4,hE+2,hF+6,hC+1,hD-1,hE-4,hF))local fV=0;local hH=1;local hI=0;local hJ=dv<0;local hK=dv<planet.surfaceMaxAltitude;local hL=9;if hJ then hL=0 end;local dv=d(dv)while fV<6 do local hM=11;local hN=16;local hO=9;local hP=14;local cp="altsm"if fV>2 then hN=hN+3;hM=hM+2;hP=hP+2;hO=hO-6;cp="altbig"end;if hJ then cp=cp.." red"elseif hK then cp=cp.." orange"end;local hQ=dv/hH%10;local hR=e(hQ)local hS=e((hR+1)%10)local hT=hI;if fV==0 then hT=hQ-hR;if hJ then hT=1-hT end end;if hJ and(fV==0 or hI~=0)then local hU=hS;hS=hR;hR=hU end;local hV=hN*(hT-1)local hW=hV+hN;local cm=hC+hO+(6-fV)*hM;local cn=hD+hP;h8[#h8+1]=cl(cm,cn+hV,hS,cp)h8[#h8+1]=cl(cm,cn+hW,hR,cp)fV=fV+1;hH=hH*10;if hR==hL then hI=hT else hI=0 end end;table.insert(h8,[[</g></g>]])end end;local function hX(eL)local hY=-math.deg(n(eL.y,eL.z))+180;hY=hY-90;if hY<0 then hY=360+hY end;if hY>180 then hY=-180+hY-180 end;return-hY end;local function hZ(eL)local hm=math.deg(n(eL.y,eL.x))-90;if hm<-180 then hm=360+hm end;return hm end;local function h_(h8,eL,eI,centerX,centerY)if eI>5 and not aq or eI>Q then local hi=circleRad;local i0=20;local i1=20;local i2=hX(eL)local i3=hZ(eL)local i4=14;local i5=i4/2;local i6=-i3/i1*hi;local i7=i2/i0*hi;local cm=centerX+i6;local cn=centerY+i7;local aj=y(i6^2+i7^2)local i8=[[<circle
                            cx="]]..cm..[["
                            cy="]]..cn..[["
                            r="]]..i5/i4 ..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..cm..[["
                            cy="]]..cn..[["
                            r="]]..i5 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..cm-i4 ..[[,]]..cn..[[ h ]]..i5 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cm+i5 ..[[,]]..cn..[[ h ]]..i5 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cm..[[,]]..cn-i4 ..[[ v ]]..i5 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if aj<hi then h8[#h8+1]=i8 else local h9=n(i7,i6)local i9=4;local ia=centerX+hi*math.cos(h9)local ib=centerY+hi*math.sin(h9)h8[#h8+1]=f('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',h9*180/math.pi,ia,ib,ia-i9,ib-i9/2,i9*2,i9,ia+i9,ib-i9,i9,i9,-i9,i9)end;if not aq then local ic=vec3(eL)i2=hX(-ic)i3=hZ(-ic)i6=-i3/i1*hi;i7=i2/i0*hi;cm=centerX+i6;cn=centerY+i7;aj=y(i6^2+i7^2)if aj<hi then local id=[[<circle
                                    cx="]]..cm..[["
                                    cy="]]..cn..[["
                                    r="]]..i5 ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..cm..[[,]]..cn-i4 ..[[ v ]]..i5 ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..cm..[[,]]..cn..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..cm..[[,]]..cn..[[)" />
                                <path
                                    d="M ]]..cm-i5 ..[[,]]..cn..[[ h ]]..i4 ..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..cm..[[,]]..cn..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..cm..[[,]]..cn..[[)"/>]]h8[#h8+1]=id end end end end;local function ie(h8,gy,ig,ih)ig=e(ig+0.5)local gX=throtPosY+10;local gY=throtPosY+20;if m()==1 and not RemoteHud then gX=55;gY=65 end;local ii="CRUISE"local unit="km/h"local cs=ih;if gy=="TRAVEL"or gy=="AUTOPILOT"then ii="THROT"unit="%"cs=ig;local ij="dim"if ig<0 then ij="red"end;h8[#h8+1]=f([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],ij,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-d(ig),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;h8[#h8+1]=cl(throtPosX+10,gX,ii,"pbright txtstart")h8[#h8+1]=cl(throtPosX+10,gY,f("%.0f %s",cs,unit),"pbright txtstart")if aq and AtmoSpeedAssist and bA and M then ig=e(N*100+0.5)local ij="red"if ig<0 then ij="red"end;h8[#h8+1]=f([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],ij,1-d(ig),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)h8[#h8+1]=cl(throtPosX+10,gX+40,"LIMIT","pbright txtstart")h8[#h8+1]=cl(throtPosX+10,gY+40,ig.."%","pbright txtstart")end;if aq and AtmoSpeedAssist or Reentry then h8[#h8+1]=cl(throtPosX+10,gX-40,"LIMIT: "..b7 .." km/h","dim txtstart")elseif not aq and Autopilot then h8[#h8+1]=cl(throtPosX+10,gX-40,"LIMIT: "..e(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function ik(h8,il)local im=throtPosY-10;local io=throtPosX+10;h8[#h8+1]=cl(0,0,"","pdim txt txtend")if m()==1 and not RemoteHud then im=75 end;h8[#h8+1]=cl(io,im,e(il).." km/h","pbright txtbig txtstart")end;local function ip(h8)h8[#h8+1]=cl(gk(1900),gl(1070),f("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")h8[#h8+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then h8[#h8+1]=cl(gk(960),gl(550),"Warning: Invalid Control Scheme Detected","warnings")h8[#h8+1]=cl(gk(960),gl(600),"Keyboard Scheme must be selected","warnings")h8[#h8+1]=cl(gk(960),gl(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local iq=gk(960)local ir=gl(860)local is=gl(880)local it=gl(900)local iu=gl(960)local iv=gl(200)local iw=gl(250)local ix=gl(960)if m()==1 and not RemoteHud then ir=gl(135)is=gl(155)it=gl(175)iv=gl(115)iw=gl(95)end;local iy="#222222"local iz="white"local iA="dimmer"local iB="pbright"local iC="#110000"local iD=iy;local iE=iA;if BrakeIsOn then h8[#h8+1]=cl(iq,ir,"Brake Engaged","warnings")iC="#440000"iD=iz;iE=iB elseif L>0 then h8[#h8+1]=cl(iq,ir,"Auto-Brake Engaged","warnings","opacity:"..L)end;local iF="#110000"local iG=iy;local iH=iA;if aq and b2 and ao==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not by and not VertTakeOff and not AutoTakeoff then h8[#h8+1]=cl(iq,iv+50,"** STALL WARNING **","warnings")iF="#ff0000"iG=iz;iH=iB;c8("stall","SW",2)end end;if bK then h8[#h8+1]=cl(iq,iv+90,"Flight Assist in Progress","warnings")end;if ax then h8[#h8+1]=cl(iq,ix,"Gyro Enabled","warnings")end;local iI="#111100"local iJ=iy;local iK=iA;if GearExtended then iI="#775500"iJ=iz;iK=iB;if S then h8[#h8+1]=cl(iq,is,"Gear Extended","warn")else h8[#h8+1]=cl(iq,is,"Landed (G: Takeoff)","warnings")end;local iL=cy(a:getTargetGroundAltitude())h8[#h8+1]=cl(iq,it,"Hover Height: "..iL,"warn")end;local iM="#000011"local iN=iy;local iO=iA;if a7 then iM="#0000DD"iN=iz;iO=iB;h8[#h8+1]=cl(iq,iu+20,"ROCKET BOOST ENABLED","warn")end;local iP="#001100"local iQ=iy;local iR=iA;if antigrav and not ExternalAGG and by and AntigravTargetAltitude~=nil then iP="#00DD00"iQ=iz;iR=iB;if d(as-antigrav.getBaseAltitude())<501 then h8[#h8+1]=cl(iq,iv+15,f("Target Altitude: %d Singularity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warn")else h8[#h8+1]=cl(iq,iv+15,f("Target Altitude: %d Singluarity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then h8[#h8+1]=cl(iq,iv+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then h8[#h8+1]=cl(iq,iv+20,f("LockedPitch: %d",e(LockPitch)),"warn")elseif a0 then h8[#h8+1]=cl(iq,iv+20,"Follow Mode Engaged","warn")elseif Reentry or an then h8[#h8+1]=cl(iq,iv+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local iL=cy(HoldAltitude,2)if VertTakeOff then if by then iL=cy(antigrav.getBaseAltitude(),2).." AGG singularity height"end;h8[#h8+1]=cl(iq,iv,"VTO to "..iL,"warn")elseif AutoTakeoff and not IntoOrbit then if am then h8[#h8+1]=cl(iq,iv,"Takeoff to "..AutopilotTargetName,"warn")else h8[#h8+1]=cl(iq,iv,"Takeoff to "..iL,"warn")end;if BrakeIsOn and not VertTakeOff then h8[#h8+1]=cl(iq,iv+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else h8[#h8+1]=cl(iq,iv,"Altitude Hold: "..iL,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if ar>0.1 then h8[#h8+1]=cl(iq,iv+20,"Beginning ascent","warn")elseif ar<0.09 and ar>0.05 then h8[#h8+1]=cl(iq,iv+20,"Aligning trajectory","warn")elseif ar<0.05 then h8[#h8+1]=cl(iq,iv+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if b9~=nil then h8[#h8+1]=cl(iq,iv,b9,"warn")end end;if BrakeLanding then if StrongBrakes then h8[#h8+1]=cl(iq,iv,"Brake-Landing","warnings")else h8[#h8+1]=cl(iq,iv,"Coast-Landing","warnings")end end;if ProgradeIsOn then h8[#h8+1]=cl(iq,iv,"Prograde Alignment","crit")end;if RetrogradeIsOn then h8[#h8+1]=cl(iq,iv,"Retrograde Alignment","crit")end;local iS="#110000"local iT=iy;local iU=iA;if bN then iS="#FF0000"iT=iz;iU=iB;local type;if string.find(bN,"COLLISION")then type="warnings"else type="crit"end;h8[#h8+1]=cl(iq,iw+20,bN,type)elseif ar==0 then local c3,c7=c1(br:normalize())if c7~=nil then iU=iB;iS="#FF0000"iT=iz;local iL=cy(c7)local travelTime=aS.computeTravelTime(bs,0,c7)local iV="Collision"if c3.noAtmosphericDensityAltitude>0 then iV="Atmosphere"end;h8[#h8+1]=cl(iq,iw+20,c3.name.." "..iV.." "..cL(travelTime).." In "..iL,"crit")end end;if VectorToTarget and not IntoOrbit then h8[#h8+1]=cl(iq,iv+35,VectorStatus,"warn")end;local iW="#111100"local iX=iy;local iY=iA;if passengers and#passengers>1 then iW="#DDDD00"iX=iz;iY=iB end;local iZ=gk;local i_=gl;local iA="topButton"local j0="topButtonActive"local j1=iA;if Autopilot or VectorToTarget or am or IntoOrbit then j1=j0 end;local j2=iA;if ProgradeIsOn then j2=j0 end;local j3=iA;if BrakeLanding or GearExtended then j3=j0 end;local j4=iA;if AltitudeHold or VectorToTarget then j4=j0 end;local j5=iA;if RetrogradeIsOn then j5=j0 end;local j6=iA;if IntoOrbit or bi and Autopilot then j6=j0 end;local j7=i_(30)h8[#h8+1]=f([[ 
                            <g class="pdim txt txtmid">
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],j1,iZ(960),i_(54),i_(-53),iZ(-120),iZ(25),i_(50))h8[#h8+1]=cl(iZ(910),j7,"AUTOPILOT")h8[#h8+1]=f([[
                                </g>
        
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],j2,iZ(865),i_(51),iZ(-25),i_(-50),iZ(-110),iZ(25),i_(46))h8[#h8+1]=cl(iZ(800),j7,"PROGRADE")h8[#h8+1]=f([[
                                </g>
        
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],j3,iZ(755),i_(47),iZ(-25),i_(-46),iZ(-98),iZ(44),i_(44))h8[#h8+1]=cl(iZ(700),j7,"LAND")h8[#h8+1]=f([[
                                </g>
        
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],j4,iZ(960),i_(54),i_(-53),iZ(120),iZ(-25),i_(50))h8[#h8+1]=cl(iZ(1010),j7,"ALT HOLD")h8[#h8+1]=f([[
                                </g>
        
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],j5,iZ(1055),i_(51),iZ(25),i_(-50),iZ(110),iZ(-25),i_(46))h8[#h8+1]=cl(iZ(1122),j7,"RETROGRADE")h8[#h8+1]=f([[
                                </g>
        
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],j6,iZ(1165),i_(47),iZ(25),i_(-46),iZ(98),iZ(-44),i_(44))h8[#h8+1]=cl(iZ(1220),j7,"ORBIT")h8[#h8+1]=[[
                                </g>
                            </g>]]h8[#h8+1]="</g>"return h8 end;local function j8(eI)return e(A(eI*3.6,0)+0.5).." km/h"end;local function j9(h8)local cm=OrbitMapX+10;local cn=OrbitMapY+20;local ja={}local jb={"Alt-4: AutoTakeoff to Target"}local jc={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local jd={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local je={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}table.insert(ja,"--------------DYNAMIC-----------------")if aq then if ao~=-1 then cb(ja,jb)if ac and planet and ac.name==planet.name then table.insert(ja,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or VertTakeOffEngine then if antigrav then if by then table.insert(ja,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(ja,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(ja,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(ja,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(ja,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if GearExtended then table.insert(ja,"G: Takeoff to hover height, raise gear")else table.insert(ja,"G: Lowergear and Land")end else cb(ja,jc)table.insert(ja,"G: Begin BrakeLanding or Land")end;if VertTakeOff then table.insert(ja,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else cb(ja,jd)if shield_1 then table.insert(ja,"Alt-Shift-5: Toggle shield off and on")table.insert(ja,"Alt-Shift-6: Vent shields")end end;if gyro then table.insert(ja,"Alt-9: Activate Gyroscope")end;if ExtraLateralTags~="none"or ExtraLongitudeTags~="none"or ExtraVerticalTags~="none"then table.insert(ja,"Alt-Shift-9: Cycles engines with Extra tags")end;if AltitudeHold then table.insert(ja,"Alt-Spacebar/C will raise/lower target height")table.insert(ja,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if AtmoSpeedAssist or not aq then table.insert(ja,"LALT+Mousewheel will lower/raise speed limit")end;cb(ja,je)for i=1,#ja do cn=cn+12;h8[#h8+1]=cl(cm,cn,ja[i],"pdim txttick txtstart")end end;local jf={Generic_Moon="assets.prod.novaquark.com/20368/f410e727-9d4d-4eab-98bf-22994b3fbdcf.png",Sun="assets.prod.novaquark.com/20368/0936494e-9b3d-4d60-9ea0-d93a3f3e29cd.png",Alioth="assets.prod.novaquark.com/20368/954f3adb-3369-4ea9-854d-a14606334152.png",Alioth_bis="assets.prod.novaquark.com/20368/b83225ed-fb96-404c-8c91-86ac15dfbbec.png",Sanctuary="assets.prod.novaquark.com/20368/1a70dbff-24bc-44cb-905c-6d375d9613b8.png",Feli="assets.prod.novaquark.com/20368/da91066c-b3fd-41f4-8c01-26131b0a7841.png",Ion="assets.prod.novaquark.com/20368/91d10712-dc51-4b73-9fc0-6f07d96605a6.png",Madis="assets.prod.novaquark.com/20368/46d57ef4-40ee-46ca-8cc5-5aee1504bbfe.png",Jago="assets.prod.novaquark.com/20368/7fca8389-6b70-4198-a9c3-4875d15edb38.png",Lacobus="assets.prod.novaquark.com/20368/cb67a6a4-933c-4688-a637-898c89eb5b94.png",Sicari="assets.prod.novaquark.com/20368/f6e2f801-075f-4ccd-ab94-46d060517e8f.png",Sinnen="assets.prod.novaquark.com/20368/54a99084-7c2b-461b-ab1f-ae4229b3b821.png",Symeon="assets.prod.novaquark.com/20368/97940324-f194-4e03-808d-d71733ad545a.png",Talemai="assets.prod.novaquark.com/20368/f68628d9-3245-4d76-968e-ad9c63a19c19.png",Teoma="assets.prod.novaquark.com/20368/5a01dd8c-3cf8-4151-99a2-83b22f1e7249.png",Thades="assets.prod.novaquark.com/20368/59f997a2-bcca-45cf-aa35-26e0e41ed5c1.png"}local function jg(h8)local jh=gk(OrbitMapX)local ji=gl(OrbitMapY)local jj=OrbitMapSize;local jk=4;local jl=15;local cm=0;local cn=0;local jm,jn,jo,jp;local jq;local function jr(type)local js,E,eI,jt,cp,ju;if type=="Periapsis"then js=jq.periapsis.altitude;E=jq.timeToPeriapsis;eI=jq.periapsis.speed;cp="txtend"jt=12;ju=math.min(cm,jh+jj-planet.radius/jo-jk*2)else js=jq.apoapsis.altitude;E=jq.timeToApoapsis;eI=jq.apoapsis.speed;jt=-12;cp="txtstart"ju=cm end;if bs<1 then E=0 end;h8[#h8+1]=f([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],ju+jt,cn-5,cm,cn-5)h8[#h8+1]=f([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],ju-jt*4,cn+2,cm,cn+2)h8[#h8+1]=cl(ju,cn,type,cp)cm=ju-jt*2;cn=cn+jl;local iL=cy(js)h8[#h8+1]=cl(cm,cn,iL,cp)cn=cn+jl;h8[#h8+1]=cl(cm,cn,cL(E),cp)cn=cn+jl;h8[#h8+1]=cl(cm,cn,j8(eI),cp)end;local jv=jj*1.5;if SelectedTab=="INFO"then jv=25*7 end;if SelectedTab~="HIDE"then h8[#h8+1]=[[<g class="pbright txtorb txtmid">]]h8[#h8+1]=f('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',jj*2,jv,jh,ji)h8[#h8+1]=f([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],jj*2,jv,jh,ji)end;if SelectedTab=="ORBIT"then ji=ji+jk;jm=jj/2;jp=0;jq={}jq.periapsis={}jq.apoapsis={}if orbit~=nil then if orbit.periapsis~=nil then jq.periapsis.altitude=orbit.periapsis.altitude;jq.periapsis.speed=orbit.periapsis.speed end;if orbit.apoapsis~=nil then jq.apoapsis.altitude=orbit.apoapsis.altitude;jq.apoapsis.speed=orbit.apoapsis.speed end;jq.period=orbit.period;jq.eccentricity=orbit.eccentricity;jq.timeToApoapsis=orbit.timeToApoapsis;jq.timeToPeriapsis=orbit.timeToPeriapsis;jq.eccentricAnomaly=orbit.eccentricAnomaly;jq.trueAnomaly=orbit.trueAnomaly end;if jq.periapsis==nil then jq.periapsis={}jq.periapsis.altitude=-planet.radius;jq.periapsis.speed=MaxGameVelocity end;if jq.eccentricity==nil then jq.eccentricity=1 end;if jq.apoapsis==nil then jq.apoapsis={}jq.apoapsis.altitude=as;jq.apoapsis.speed=0 end;if bs<1 then jq.apoapsis.altitude=as;jq.apoapsis.speed=0 end;if jq.apoapsis.altitude then jo=(jq.apoapsis.altitude+jq.periapsis.altitude+planet.radius*2)/(jm*2)jn=(planet.radius+jq.apoapsis.altitude)/jo*(1-jq.eccentricity)jp=jm-jq.periapsis.altitude/jo-planet.radius/jo;local jw=math.pi;if jq.period~=nil and jq.period>0 and jq.timeToApoapsis~=nil then jw=jq.eccentricAnomaly;if jq.timeToPeriapsis<jq.timeToApoapsis then jw=2*math.pi-jw end end;if bs<1 or jw~=jw then jw=math.pi end;local jx=-jm*math.cos(jw)+jh+jj+jk;local jy=jn*math.sin(jw)+ji+jj*1.5/2+jk;local jz=""h8[#h8+1]='<g clip-path="url(#orbitRect)">'h8[#h8+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],jz,jh+jj+jk,ji+jj*1.5/2+jk,jm,jn)if jn<1 then h8[#h8+1]=f([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],jh+jj+jk-jp,ji+jj*1.5/2+jk,jx,jy)end;h8[#h8+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',jh+jj+jk-jp,ji+jj*1.5/2+jk,(planet.radius+planet.noAtmosphericDensityAltitude)/jo)h8[#h8+1]=f('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',jh+jj+jk-jp,ji+jj*1.5/2+jk,(planet.radius+planet.noAtmosphericDensityAltitude)/jo)h8[#h8+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",jh+jj+jk,ji+jj*1.5/2+jk,jm,jn)h8[#h8+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',jh+jj+jk-jp,ji+jj*1.5/2+jk,planet.radius/jo)h8[#h8+1]='</g>'local jA=math.floor(planet.radius/jo+0.5)local jB=jf.Generic_Moon;if jf[planet.name]then jB=jf[planet.name]end;cm=jh+jj+jk*4+jm;cn=ji+jj*1.5/2+5+jk;if jq.apoapsis~=nil and jq.apoapsis.speed<MaxGameVelocity then jr("Apoapsis")end;cn=ji+jj*1.5/2+5+jk;cm=jh+jj-jk*2-jm;if jq.periapsis~=nil and jq.periapsis.speed<MaxGameVelocity and jq.periapsis.altitude>0 then jr("Periapsis")end;h8[#h8+1]=cl(jh+jj+jk,ji+20+jk,planet.name,"txtorbbig")h8[#h8+1]=f('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',jx,jy)h8[#h8+1]=[[</g>]]return h8 else h8[#h8+1]='<g clip-path="url(#orbitRect)">'local jC=""local jD=1.2*(maxAtlasX-minAtlasX)/(jj*2)local jE=1.4*(maxAtlasY-minAtlasY)/(jj*1.5)for cU,cV in pairs(b[0])do if cV.center then local cm=jh+jj+cV.center.x/jD;local cn=ji+jj*1.5/2+cV.center.y/jE;jC=jC..'<circle cx="'..cm..'" cy="'..cn..'" r="'..cV.radius/jD*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(cV.name,"Moon")and not string.match(cV.name,"Sanctuary")and not string.match(cV.name,"Space")then jC=jC.."<text x='"..cm.."' y='"..cn+cV.radius/jD*30+20 .."' font-size='12' fill="..ay.." text-anchor='middle' font-family='Montserrat'>"..cV.name.."</text>"end end end;local eM=vec3(core.getConstructWorldPos())local cm=jh+jj+eM.x/jD;local cn=ji+jj*1.5/2+eM.y/jE;jC=jC..'<circle cx="'..cm..'" cy="'..cn..'" r="2" stroke="white" stroke-width="1" fill="red"/>'jC=jC.."<text x='"..cm.."' y='"..cn-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"aN=jD;aO=jE;local jF=eM+br*1000000;local jG=jh+jj+jF.x/jD;local gY=ji+jj*1.5/2+jF.y/jE;jC=jC..'<line x1="'..cm..'" y1="'..cn..'" x2="'..jG..'" y2="'..gY..'" stroke="purple" stroke-width="1"/>'h8[#h8+1]=jC;h8[#h8+1]='</g>'end elseif SelectedTab=="INFO"then h8=aV.DrawOdometer(h8,ad,TotalDistanceTravelled,ae)elseif SelectedTab=="HELP"then h8=j9(h8)elseif SelectedTab=="SCOPE"then h8[#h8+1]='<g clip-path="url(#orbitRect)">'local jC=""local jD=(maxAtlasX-minAtlasX)/(jj*2)local jE=(maxAtlasY-minAtlasY)/(jj*1.5)local jH=40;for cU,cV in pairs(b[0])do if cV.center then local fd=cV.center-bv;local jI=bV(bp,fd,bo)*constants.rad2deg;local jJ=bV(bn,fd,bo)*constants.rad2deg;local cm=jh+jj+jJ/jH*jj*2;local cn=ji+jj*1.5/2+jI/jH*jj*1.5;local jK=cV.center+cV.radius*fd:normalize():cross(bp)-bv;local jL=bV(bp,jK,fd)*constants.rad2deg;local jM=d(jL*2/jH)*jj*1.5;local jN=cV.center+cV.radius*fd:normalize():cross(bn)-bv;local jO=bV(bn,jN,fd)*constants.rad2deg;local jP=d(jO*2/jH)*jj*2;jC=jC..'<ellipse cx="'..cm..'" cy="'..cn..'" rx="'..jP..'" ry="'..jM..'" stroke="white" stroke-width="1" fill="blue" opacity="0.8" />'jC=jC.."<text x='"..cm.."' y='"..cn.."' font-size='12' fill="..ay.." text-anchor='middle' font-family='Montserrat'>"..cV.name.."</text>"end end;if bs>1 then local jI=bV(bp,br,bo)*constants.rad2deg;local jJ=bV(bn,br,bo)*constants.rad2deg;local cm=jh+jj+jJ/jH*jj*2;local cn=ji+jj*1.5/2+jI/jH*jj*1.5;local i4=14;local i5=i4/2;local i8=[[<circle
                                    cx="]]..cm..[["
                                    cy="]]..cn..[["
                                    r="]]..i5/i4 ..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..cm..[["
                                    cy="]]..cn..[["
                                    r="]]..i5 ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..cm-i4 ..[[,]]..cn..[[ h ]]..i5 ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..cm+i5 ..[[,]]..cn..[[ h ]]..i5 ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..cm..[[,]]..cn-i4 ..[[ v ]]..i5 ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jC=jC..i8 end;h8[#h8+1]=jC;h8[#h8+1]='</g>'else return h8 end end;local function jQ(jR,jS)local jT;local jU=(jS-jR):normalize()local eN=(bv-jR):dot(jU)/jU:dot(jU)if eN<=0.then return(bv-jR):len()elseif eN>=(jS-jR):len()then return(bv-jS):len()end;local jV=jR+eN*jU;jT=(jV-bv):len()return jT end;local function jW()local jT;local jX=nil;local jY=nil;local jZ=nil;for cU,j_ in pairs(b[0])do if j_.hasAtmosphere then local aj=jQ(planet.center,j_.center)if jX==nil or aj<jX then jY=j_;jX=aj;jZ=planet end;if ac and ac.hasAtmosphere and ac.name~=planet.name then local e8=jQ(ac.center,j_.center)if e8<jX then jY=j_;jX=e8;jZ=ac end end end end;local k0=gk(1770)local k1=gl(330)if jX then local k2="txttick "local k3=500000;if jX<jY.radius+k3 or jX<jZ.radius+k3 then if bH then k2="txttick red "else k2="txttick orange "end end;jT=cy(jX,2)bJ=cl(k0,k1,"Pipe ("..jZ.name.."--"..jY.name.."): "..jT,k2 .."pbright txtmid")end end;local k4={}local k5=nil;function k4.HUDPrologue(h8)bH,bI=gu(bv)if not bH then H=PvPR;J=PvPG;I=PvPB;if shield_1 and AutoShieldToggle and shield_1.getState()==0 then shield_1.toggle()end else H=SafeR;J=SafeG;I=SafeB;if shield_1 and AutoShieldToggle and shield_1.getState()==1 then shield_1.toggle()end end;ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]az=[[rgb(]]..e(H*0.8+0.5)..","..e(J*0.8+0.5)..","..e(I*0.8+0.5)..[[)]]local k6=ay;local k7=az;local k8=[[rgb(]]..e(H*0.3+0.5)..","..e(J*0.3+0.5)..","..e(I*0.3+0.5)..[[)]]local k9=ay;local ka=az;if gw()and not brightHud then k6=[[rgb(]]..e(H*0.5+0.5)..","..e(J*0.5+0.5)..","..e(I*0.5+0.5)..[[)]]k7=[[rgb(]]..e(H*0.3+0.5)..","..e(J*0.3+0.5)..","..e(I*0.2+0.5)..[[)]]end;local iZ=gk;local i_=gl;h8[#h8+1]=f([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none;stroke:%s}
                                .linethick {stroke-width:3px;fill:none}
                                .linethin {stroke-width:1px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}
                                .warn {fill:orange; font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                text.bright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pbright {fill:%s;stroke:%s}
                                text.pbright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dim {fill:%s;stroke:%s}
                                text.dim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pdim {fill:%s;stroke:%s}
                                text.pdim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .red {fill:red;stroke:red}
                                text.red {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .orange {fill:orange;stroke:orange}
                                text.orange {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                                text { stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dimstroke {stroke:%s}
                                .brightstroke {stroke:%s}
                                .indicatorText {font-size:20px;fill:white}
                                .size14 {font-size:14px}
                                .size20 {font-size:20px}
                                .topButton {fill:%s;opacity:0.5;stroke-width:2;stroke:%s}
                                .topButtonActive {fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}
                                .topButton text {font-size:13px; fill: %s; opacity:1; stroke-width:20px}
                                .topButtonActive text {font-size:13px;fill:%s; stroke-width:0px; opacity:1}
                                .indicatorFont {font-size:20px;font-family:Bank}
                                .dimmer {stroke: %s;}
                                .dimfill {fill: %s;}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                                <defs>
                                    <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="100%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/>
                                    </radialGradient>
                                </defs>
                                <g class="pdim txt txtend">
                                
                            ]],k6,k6,k6,k9,k9,k7,k7,ka,ka,k7,k6,k8,ka,k6,k6,k8,k8,k8,aG,aH,k7,k7,k7,k7,k7,k9,k7)if not k5 then k5=f([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],iZ(630),i_(0),iZ(675),i_(45),iZ(960),i_(55),iZ(1245),i_(45),iZ(1290),i_(0),iZ(1000),i_(105),iZ(1040),i_(59),iZ(1250),i_(51),iZ(1300),i_(0),iZ(1920),i_(0),iZ(1920),i_(20),iZ(1400),i_(20),iZ(1300),i_(105),iZ(920),i_(105),iZ(880),i_(59),iZ(670),i_(51),iZ(620),i_(0),iZ(0),i_(0),iZ(0),i_(20),iZ(520),i_(20),iZ(620),i_(105),iZ(890),i_(59),iZ(960),i_(62),iZ(1030),i_(59),iZ(985),i_(112),iZ(1150),i_(112),iZ(1100),i_(152),iZ(820),i_(152),iZ(780),i_(112),iZ(935),i_(112),iZ(890),i_(59),iZ(960),i_(62),iZ(1030),i_(59),iZ(985),i_(112),iZ(1150),i_(112),iZ(1100),i_(152),iZ(820),i_(152),iZ(780),i_(112),iZ(935),i_(112))end;h8[#h8+1]=k5;return h8 end;function k4.DrawVerticalSpeed(h8,dv)h7(h8,dv)end;function k4.UpdateHud(h8)local hY=bB;local kb=bC;local hg=kb;local hv=hY;local ig=e(unit.getThrottle())local il=bs*3.6;local ih=unit.getAxisCommandValue(0)local kc=gk(1770)local kd=gl(310)if AtmoSpeedAssist and bA then ih=K;ig=K*100 end;local gy=gx()local hh="ROLL"if ig==nil then ig=0 end;if not bM then if bs>5 then hY=hX(bq)kb=hZ(bq)else hY=0;kb=0 end;hh="YAW"end;if bI>50000 and not aq then local ke;ke=cy(bI)h8[#h8+1]=cl(kc,kd,"PvP Boundary: "..ke,"pbright txtbig txtmid")end;h8[#h8+1]=ak;h8[#h8+1]=aD;h8[#h8+1]=gz;if bJ~=""then h8[#h8+1]=bJ end;if gA~=""then h8[#h8+1]=gA end;if gB~=""then h8[#h8+1]=gB end;h7(h8,as)if m()==0 or RemoteHud then if bM then hf(h8,centerX,centerY,hg,hh,bM)else hf(h8,centerX,centerY,kb,hh,bM)end;if not gw()or brightHud then if bM then hf(h8,centerX,centerY,hg,hh,bM)hu(h8,hv,hg,centerX,centerY,bM,e(hZ(bq)),bs)else hf(h8,centerX,centerY,kb,hh,bM)hu(h8,hY,kb,centerX,centerY,bM,e(kb),bs)end;hB(h8,as,bM)h_(h8,bq,bs,centerX,centerY)end end;ie(h8,gy,ig,ih)ik(h8,il)ip(h8)jg(h8)return h8 end;function k4.HUDEpilogue(h8)h8[#h8+1]="</svg>"return h8 end;function k4.ExtraData(h8)local kf=gk(1240)local kg=gl(55)local kh=kg+10;local ki;local iZ=gk;local i_=gl;local kj=0;local gy=gx()local kk=iZ(99)local kl=iZ(80)local km=i_(85)local kn=i_(31)local ko=0;local kp=0;local kq=av>1000000 and A(av/1000000,2).."kT"or A(av/1000,2).."T"if aq then kj=LastMaxBrakeInAtmo else kj=LastMaxBrake end;local kr,ks=aS.computeDistanceAndTime(bs,0,av,0,0,kj)if kr<0 then kr=0 end;kj=A(kj/(av*gn),2).."g"local kt=a:maxForceForward()ki=core.g()if ki>0.1 then kp=av*ki;kp=A(kp/(av*gn),2).."g"ko=0.5*kt/ki;ko=ko>1000000 and A(ko/1000000,2).."kT"or A(ko/1000,2).."T"end;kt=A(kt/(av*gn),2).."g"local ku=vec3(core.getWorldAcceleration()):len()/9.80665;ki=core.g()h8[#h8+1]=[[<g class="dim txt txtend size14">]]if m()==1 and not RemoteHud then kf=gk(1120)kg=gl(55)kh=kg+10 elseif aq then local kv=gk(770)h8[#h8+1]=cl(iZ(895),kk,"ATMO","")h8[#h8+1]=f([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],iZ(895),km,iZ(-80))h8[#h8+1]=cl(iZ(815),kl,f("%.1f%%",ar*100),"txtstart size20")end;h8[#h8+1]=cl(iZ(1025),kk,"GRAVITY","txtstart")h8[#h8+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iZ(1025),km,iZ(80))h8[#h8+1]=cl(iZ(1105),kl,f("%.2fg",ki/9.80665),"size20")h8[#h8+1]=cl(iZ(1125),kk,"ACCEL","txtstart")h8[#h8+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iZ(1125),km,iZ(80))h8[#h8+1]=cl(iZ(1205),kl,f("%.2fg",ku),"size20")h8[#h8+1]=cl(iZ(695),kk,"BRAKE","")h8[#h8+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iZ(695),km,iZ(-80))h8[#h8+1]=cl(iZ(615),kl,f("%s",cL(ks)),"txtstart size20")h8[#h8+1]=cl(iZ(635),i_(45),"TRIP","")h8[#h8+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iZ(635),i_(31),iZ(-90))if travelTime then h8[#h8+1]=cl(iZ(532),i_(23),f("%s",cL(travelTime)),"txtstart size20")end;h8[#h8+1]=cl(iZ(795),kk,"BRAKE","")h8[#h8+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iZ(795),km,iZ(-80))h8[#h8+1]=cl(iZ(715),kl,f("%s",cy(kr)),"txtstart size20")h8[#h8+1]=cl(iZ(1285),i_(45),"MASS","txtstart")h8[#h8+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iZ(1285),i_(31),iZ(90))h8[#h8+1]=cl(iZ(1388),i_(23),f("%s",kq),"size20")h8[#h8+1]=cl(iZ(1220),kk,"THRUST","txtstart")h8[#h8+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iZ(1220),km,iZ(80))h8[#h8+1]=cl(iZ(1300),kl,f("%s",kt),"size20")h8[#h8+1]=cl(gk(960),gl(175),gy,"pbright txtbig txtmid size20")h8[#h8+1]="</g>"end;function k4.DrawOdometer(h8,ad,TotalDistanceTravelled,ae)if SelectedTab~="INFO"then return h8 end;local ki;local ko=0;local kp=0;local kj=0;local kq=av>1000000 and A(av/1000000,2).." kTons"or A(av/1000,2).." Tons"if aq then kj=LastMaxBrakeInAtmo else kj=LastMaxBrake end;local kr,ks=aS.computeDistanceAndTime(bs,0,av,0,0,kj)kj=A(kj/(av*gn),2).." g"local kt=a:maxForceForward()ki=core.g()if ki>0.1 then kp=av*ki;kp=A(kp/(av*gn),2).." g"ko=0.5*kt/ki;ko=ko>1000000 and A(ko/1000000,2).." kTons"or A(ko/1000,2).." Tons"end;kt=A(kt/(av*gn),2).." g"if m()==0 or RemoteHud then local kw=gk(OrbitMapX+10)local kx=gl(OrbitMapY+20)local ky=gk(OrbitMapX+10+OrbitMapSize)local kz=25;h8[#h8+1]="<g class='txtstart size14 bright'>"h8[#h8+1]=cl(kw,kx,f("BrkTime: %s",cL(ks)))h8[#h8+1]=cl(ky,kx,f("Trip: %.2f km",ad))h8[#h8+1]=cl(kw,kx+kz,f("Lifetime: %.2f kSU",TotalDistanceTravelled/200000))h8[#h8+1]=cl(ky,kx+kz,f("BrkDist: %s",cy(kr)))h8[#h8+1]=cl(kw,kx+kz*2,"Trip Time: "..cL(ae))h8[#h8+1]=cl(ky,kx+kz*2,"Total Time: "..cL(TotalFlightTime))h8[#h8+1]=cl(kw,kx+kz*3,f("Mass: %s",kq))h8[#h8+1]=cl(ky,kx+kz*3,f("Max Brake: %s",kj))h8[#h8+1]=cl(kw,kx+kz*4,f("Max Thrust: %s",kt))if ki>0.1 then h8[#h8+1]=cl(ky,kx+kz*4,f("Max Thrust Mass: %s",ko))h8[#h8+1]=cl(kw,kx+kz*5,f("Req Thrust: %s",kp))else h8[#h8+1]=cl(ky,kx+kz*5,"Max Mass: n/a")h8[#h8+1]=cl(kw,kx+kz*6,"Req Thrust: n/a")end end;h8[#h8+1]="</g></g>"return h8 end;function k4.DrawWarnings(h8)return ip(h8)end;function k4.DisplayOrbitScreen(h8)return jg(h8)end;function k4.DisplayMessage(h8,iL)if iL~="empty"then local cn=310;for kA in string.gmatch(iL,"([^\n]+)")do cn=cn+35;h8[#h8+1]=cl("50%",cn,kA,"msg")end end;if ai~=0 then unit.setTimer("msgTick",ai)ai=0 end end;function k4.DrawDeadZone(h8)h8[#h8+1]=f([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function k4.UpdatePipe()if aq then bJ=""return end;jW()end;function k4.DrawSettings(h8)if#bE>0 then local cm=gk(640)local cn=gl(200)h8[#h8+1]=[[<g class="pbright txtvspd txtstart">]]for cU,cV in pairs(bE)do h8[#h8+1]=cl(cm,cn,cV..": ".._G[cV])cn=cn+20;if cU%12==0 then cm=cm+gk(350)cn=gl(200)end end;h8[#h8+1]=cl(gk(640),gl(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")h8[#h8+1]="</g>"end;return h8 end;local kB;local kC=gk(1770)local kD=gl(350)local kE=gl(15)local kF=gk(1370)local bU,kG;local kH=0;function k4.DrawRadarInfo()local function kI()if radarPanelID~=nil and kH==0 then t(radarPanelID)radarPanelID=nil;if kB~=nil then t(kB)kB=nil end else if kH==1 then t(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(bP,1,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")kB=_autoconf.panels[_autoconf.panels_size]end;if radarPanelID==nil then _autoconf.displayCategoryPanel(bP,1,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]end;kH=0 end end;local fd,fe,fc,ff,fg,f9=aY.GetRadarHud()local B=ff or 0;if fc>0 then if CollisionSystem then bU=B.."/"..fg.." Plotted : "..fc-fg.." Ignored"else bU="Radar Contacts: "..fc end;gz=cl(kC,kD,bU,"pbright txtbig txtmid")if#f9>0 then gz=gz..cl(kF,kE,"Friendlies In Range","pbright txtbig txtmid")for cU,cV in pairs(f9)do kE=kE+20;gz=gz..cl(kF,kE,bP[1].getConstructName(cV),"pdim txtmid")end end;if fd==nil and kB==nil then kH=1;kI()end;if fd~=nil and kB~=nil then kI()end;if radarPanelID==nil then kI()end else if fe then gz=cl(kC,kD,bQ.." Radar: Jammed","pbright txtbig txtmid")else gz=cl(kC,kD,"Radar: No "..bQ.." Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then kH=0;kI()end end end;function k4.DrawTanks()if fuelX~=0 and fuelY~=0 then gA=cl(fuelX,fuelY,"","txtstart pdim txtfuel")tankY=fuelY;gR(fuelX,"Atmospheric ","ATMO",aI,gP,gQ)gR(fuelX,"Space Fuel T","SPACE",aJ,gN,gO)gR(fuelX,"Rocket Fuel ","ROCKET",aK,gL,gM)end end;function k4.DrawShield()local kJ=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local kK=core.getPvPTimer()local kL=shield_1.getResistances()local kM="A: "..10+kL[1]*100 .."% / E: "..10+kL[2]*100 .."% / K:"..10+kL[3]*100 .."% / T: "..10+kL[4]*100 .."%"local cm,cn=shieldX-60,shieldY+30;local kN=e(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())local h4=e(kN*2.55)local h5=f("rgb(%d,%d,%d)",255-h4,h4,0)local cp=""gB=cl(cm,cn,"","txtmid pdim txtfuel")if kN<10 and kJ~="Shield Disabled"then cp="red "end;kK=kK>0 and"   PvPTime: "..cL(kK)or""gB=gB..f([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],cm,cn,h5,kN*2,cm,cn,cm+2,cn+10,kN,kK)gB=gB..cl(cm,cn-5,kJ,cp.."txtstart pbright txtbig")gB=gB..cl(cm,cn+30,kM,cp.."txtstart pbright txtsmall")end;return k4 end;local function kO()local function kP(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=b[0][0]end;return p end;local function kQ()local function kR(kS,kT)return kS.name<kT.name end;bG={}for cU,cV in pairs(b[0])do bG[#bG+1]={name=cV.name,index=cU}end;table.sort(bG,kR)end;local function kU(kV)for cU,cV in pairs(kV)do if cV.name and cV.name==CustomTarget.name then return cU end end;return-1 end;local function kW()bS=AutopilotTargetIndex;if AutopilotTargetIndex==0 then AutopilotTargetName="None"ac=nil;CustomTarget=nil;return true end;local kX=bG[AutopilotTargetIndex].index;local kY=b[0][kX]if kY.center then AutopilotTargetName=kY.name;ac=aR[0][kX]if CustomTarget~=nil then if ar==0 then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end;if u(widgetTargetOrbitText,widgetTargetOrbit)~=1 then v(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=kY;for _,cV in pairs(aR[0])do if cV.name==CustomTarget.planetname then ac=cV;AutopilotTargetName=CustomTarget.name;break end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ac.center)else AutopilotTargetCoords=CustomTarget.position end;if ac.planetname~="Space"then if ac.hasAtmosphere then AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=aU(ac):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function kZ(hc)if not Autopilot and not VectorToTarget and not am and not IntoOrbit then if hc==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bG then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bG end end;if AutopilotTargetIndex==0 then kW()else local kX=bG[AutopilotTargetIndex].index;local kY=b[0][kX]if kY~=nil and kY.name=="Space"or iphCondition=="Custom Only"and kY.center or iphCondition=="No Moons"and string.find(kY.name,"Moon")~=nil then if hc==nil then kZ()else kZ(1)end else kW()end end else a2="Disengage autopilot before changing Interplanetary Helper"c8("iph","AP")end end;local function k_()local fV=-1;fV=kU(b[0])if fV>-1 then table.remove(b[0],fV)end;fV=-1;fV=kU(SavedLocations)if fV~=-1 then a2=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,fV)end;kZ()kQ()end;local function l0(g9,position,hU,l1)if dbHud_1 or hU then local p=kP(position)local ki=p.gravity;if l1 then ki=unit.getClosestPlanetInfluence()end;local l2={position=position,name=g9,planetname=p.name,gravity=ki,safe=l1}if not hU then SavedLocations[#SavedLocations+1]=l2 else for cU,cV in pairs(b[0])do if cV.name and g9==cV.name then table.remove(b[0],cU)end end end;table.insert(b[0],l2)kQ()kW()a2="Location saved as "..g9 .."("..p.name..")"else a2="Databank must be installed to save permanent locations"end end;local l3={}function l3.UpdateAtlasLocationsList()kQ()end;function l3.UpdateAutopilotTarget()kW()end;function l3.adjustAutopilotTargetIndex(hc)kZ(hc)end;function l3.findAtlasIndex(kV)kU(kV)end;function l3.UpdatePosition(l4)local fV=kU(SavedLocations)if fV~=-1 then if l4~=nil then SavedLocations[fV].name=l4;AutopilotTargetIndex=AutopilotTargetIndex-1;kZ()else local l5=SavedLocations[fV]l5.gravity=unit.getClosestPlanetInfluence()l5.position=bv;l5.safe=true end;a2=SavedLocations[fV].name.." position updated ("..SavedLocations[fV].planetname..")"else a2="Name Not Found"end end;function l3.AddNewLocation(g9,position,hU,l1)l0(g9,position,hU,l1)end;function l3.ClearCurrentPosition()k_()end;for cU,cV in pairs(SavedLocations)do table.insert(b[0],cV)end;kQ()if AutopilotTargetIndex>#bG then AutopilotTargetIndex=0 end;l3.UpdateAutopilotTarget()return l3 end;local function l6()local cF={}local function l7(eI)local l8=AutopilotEndSpeed;if not Autopilot then l8=0 end;if not aq then return aS.computeDistanceAndTime(eI,l8,av,0,0,LastMaxBrake-AutopilotPlanetGravity*av)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return aS.computeDistanceAndTime(eI,l8,av,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*av)else return 0,0 end end end;local function l9(eI)local l8=AutopilotEndSpeed;if not Autopilot then l8=0 end;return aS.computeDistanceAndTime(eI,l8,av,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*av)end;local la=false;local lb=0;function cF.GetAutopilotBrakeDistanceAndTime(eI)return l7(eI)end;function cF.GetAutopilotTBBrakeDistanceAndTime(eI)return l9(eI)end;local function lc()local function ld()local le=-1;local lf=-1;if vBooster then le=vBooster.getDistance()end;if hover then lf=hover.getDistance()end;if le~=-1 and lf~=-1 then if le<lf then return le else return lf end elseif le~=-1 then return le elseif lf~=-1 then return lf else return-1 end end;local lg=ld()local lh=-1;if telemeter_1 then lh=telemeter_1.getDistance()end;if lg~=-1 and lh~=-1 then if lg<lh then return lg else return lh end elseif lg~=-1 then return lg else return lh end end;local function li(planet,e4,lj)local function lk(ll,dp)local ea=vec3(dp)if ll.id==0 then return setmetatable({latitude=ea.x,longitude=ea.y,altitude=ea.z,id=0,systemId=ll.systemId},MapPosition)end;local eb=ea-ll.center;local aj=eb:len()local dv=aj-ll.radius;local dt=0;local du=0;if not cv(aj,0)then local ec=n(eb.y,eb.x)du=ec>=0 and ec or 2*math.pi+ec;dt=math.pi/2-math.acos(eb.z/aj)end;return setmetatable({latitude=math.deg(dt),longitude=math.deg(du),altitude=dv,id=ll.id,systemId=ll.systemId},MapPosition)end;local lm=lk(planet,e4)lm="::pos{"..lm.systemId..","..lm.id..","..lm.latitude..","..lm.longitude..","..lm.altitude.."}"if lj then return lm else system.setWaypoint(lm)return true end end;local ln=false;function cF.showWayPoint(planet,e4,lj)return li(planet,e4,lj)end;function cF.APTick()local function lo()if bO and not BrakeLanding then local c6=bO[1]local ga,gb=bO[2],bO[3]local lp=math.min(ga,gb or ga)local lq=lp/bs;local lr=AutoTakeoff and(bs<42 or ao~=-1)local ls=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if ls and not lr and(a8*1.5>lp or lq<1)then BrakeIsOn=true;cr(0)if AltitudeHold then cD()end;if LockPitch then ToggleLockPitch()end;a2="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then cG()end;StrongBrakes=true;BrakeLanding=true;b0=true end;if lq<11 then bN=c6.name.." COLLISION "..cL(lq).." / "..cy(lp,2)else bN=c6.name.." collision "..cL(lq)end;if lq<6 then c8("alarm","AL",2)end else bN=false end end;local function lt(c2,lu,lv)local function lw(c2,dR)c2=vec3(c2)dR=vec3(dR):normalize()local da=c2*dR;return da.x+da.y+da.z end;local lx=0.001;local ly=1;if not aq or not b2 or ao~=-1 or bs<Q then if lv==nil then lv=DampingMultiplier end;if lu==nil then lu=lx end;c2=vec3(c2):normalize()local lz=vec3()-c2;local lA=-lw(lz,core.getConstructWorldOrientationRight())*ly;local lB=-lw(lz,core.getConstructWorldOrientationUp())*ly;if aB==0 then aB=lA/2 end;if aC==0 then aC=lB/2 end;if d(lA)<0.1 then V=V-lA*2 else V=V-(lA+(lA-aB)*lv)end;if d(lB)<0.1 then U=U+lB*2 else U=U+lB+(lB-aC)*lv end;aB=lA;aC=lB;if d(lA)<lu and d(lB)<lu then return true end;return false elseif b2 and ao==-1 then c2=br;if lv==nil then lv=DampingMultiplier end;if lu==nil then lu=lx end;c2=vec3(c2):normalize()local lz=bo-c2;local lA=-lw(lz,core.getConstructWorldOrientationRight())*ly;local lB=-lw(lz,core.getConstructWorldOrientationUp())*ly;if aB==0 then aB=lA/2 end;if aC==0 then aC=lB/2 end;if d(lA)<0.1 then V=V-lA*5 else V=V-(lA+(lA-aB)*lv)end;if d(lB)<0.1 then U=U+lB*5 else U=U+lB+(lB-aC)*lv end;aB=lA;aC=lB;if d(lA)<lu and d(lB)<lu then return true end;return false end end;aq=k()>0;ar=k()as=core.getAltitude()ao=lc()E=q()b3=E;if CollisionSystem then lo()end;if antigrav then by=antigrav.getState()==1 end;local lC=1;local lD=1;local lE=E-b3;local lF=-math.deg(bV(bn,br,bo))local lG=math.deg(bV(bp,br,bo))local hc=bt*-1;b2=aq and lF<-YawStallAngle or lF>YawStallAngle or lG<-PitchStallAngle or lG>PitchStallAngle;local lH=system.getMouseDeltaX()local lI=system.getMouseDeltaY()if InvertMouse and not a1 then lI=-lI end;V=0;Z=0;U=0;sys=aR[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=aU(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),br)if as==0 then as=(bv-planet.center):len()-planet.radius end;bM=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local ki=planet:getGravity(core.getConstructWorldPos()):len()*av;b4=0;aT=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if x()==0 then if m()==1 and a1 then if not aZ then ag=r(ag+lH,-aG/2,aG/2)ah=r(ah+lI,-aH/2,aH/2)end else ag=0;ah=0 end else ag=r(ag+lH,-aG/2,aG/2)ah=r(ah+lI,-aH/2,aH/2)aj=y(ag*ag+ah*ah)if not a1 and m()==0 then if userControlScheme=="virtual joystick"then if ag>0 and ag>DeadZone then V=V-(ag-DeadZone)*MouseXSensitivity elseif ag<0 and ag<DeadZone*-1 then V=V-(ag+DeadZone)*MouseXSensitivity else V=0 end;if ah>0 and ah>DeadZone then U=U-(ah-DeadZone)*MouseYSensitivity elseif ah<0 and ah<DeadZone*-1 then U=U-(ah+DeadZone)*MouseYSensitivity else U=0 end else ag=0;ah=0;if userControlScheme=="mouse"then U=(-utils.smoothstep(lI,-100,100)+0.5)*2*lC;V=(-utils.smoothstep(lH,-100,100)+0.5)*2*lD end end end end;local lJ=bs>8334;if bs>SpaceSpeedLimit/3.6 and not aq and not Autopilot and not lJ then a2="Space Speed Engine Shutoff reached"cr(0)end;if not lJ and LastIsWarping then if not BrakeIsOn then cI()end;if Autopilot then cG()end end;LastIsWarping=lJ;if aq and ar>0.09 then if bs>b7/3.6 and not AtmoSpeedAssist and not la then BrakeIsOn=true;la=true elseif not AtmoSpeedAssist and la then if bs<b7/3.6 then BrakeIsOn=false;la=false end end end;if BrakeIsOn then Y=1 else Y=0 end;if ProgradeIsOn then if al then BrakeIsOn=false;local lK=false;if CustomTarget and al~=1 then lK=lt(CustomTarget.position-bv,0.1)else lK=lt(vec3(br),0.01)end;b0=true;if lK then cu(e(b7))if(d(bC)<2 or d(bB)>85)and bs>=b7/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;R=true;if al~=1 then an=true end;al=false;Autopilot=false;cJ()end elseif aq and AtmoSpeedAssist then cr(1)end elseif bs>Q then lt(vec3(br),0.01)end end;if RetrogradeIsOn then if aq then RetrogradeIsOn=false elseif bs>Q then lt(-vec3(br))end end;if not ProgradeIsOn and al and not IntoOrbit then if ar==0 then R=true;cJ()al=false;an=true else al=false;cG()end end;if an and CustomTarget and(as<HoldAltitude+250 and as>HoldAltitude-250)and bs*3.6>b7-250 and d(bu)<25 and ar>=0.1 and(CustomTarget.position-bv):len()>2000+as then cG()an=false end;if VertTakeOff then b0=true;local lL=HoldAltitude;if bu<-30 then a2="Unable to achieve lift. Safety Landing."af=0;b0=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and by or HoldAltitude<planet.spaceEngineMinAltitude then if by then lL=antigrav.getBaseAltitude()end;if as<lL-100 then b8=0;af=15;BrakeIsOn=false elseif bu>0 then BrakeIsOn=true;af=0 elseif bu<-30 then BrakeIsOn=true;af=15 elseif as>=lL then if by then if Autopilot or VectorToTarget then cB()else BrakeIsOn=true;VertTakeOff=false end;a2="Takeoff complete. Singularity engaged"c8("aggLk","AG")else BrakeIsOn=false;a2="VTO complete. Engaging Horizontal Flight"c8("vtoc","VT")cB()end;af=0 end else if ar>0.08 then b8=0;BrakeIsOn=false;af=20 elseif ar<0.08 and ar>0 then BrakeIsOn=false;if bk then b8=0;af=20 else af=0;b8=36;cu(3500)end else b0=autoRollPreference;IntoOrbit=true;bi=false;CancelIntoOrbit=false;bc=false;ba=nil;bb=nil;if bh==nil then bh=planet end;bg=lL;bf=true;VertTakeOff=false end end;if b8~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local lM=r(b8-bB,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(lM)local lN=r(vTpitchPID:get(),-1,1)U=lN end end;if IntoOrbit then local lz;local lO=false;local lP=cy(bg)if bh==nil then bh=planet;if VectorToTarget then bh=ac end end;if not bf then bg=e(bh.radius+bh.surfaceMaxAltitude+LowOrbitHeight)if bh.hasAtmosphere then bg=e(bh.radius+bh.noAtmosphericDensityAltitude+LowOrbitHeight)end;bf=true end;if be.VectorToTarget and CustomTarget then lz=CustomTarget.position-bv end;local lQ,lR=aU(bh):escapeAndOrbitalSpeed((bv-bh.center):len()-bh.radius)local lS=bC;if not bc then local lT=false;local lU=false;cr(0)bb=0;b9="Aligning to orbital path - OrbitHeight: "..lP;if be.VectorToTarget then lt(lz:normalize():project_on_plane(bt))lO=bo:dot(lz:project_on_plane(bn):normalize())>0.95 else lt(br)lO=lF<0.5;if bs<150 then lO=true end end;U=0;ba=0;if bB<=ba+1 and bB>=ba-1 then lT=true else lT=false end;if lS<=bb+1 and lS>=bb-1 then lU=true else lU=false end;if lT and lU and lO then ba=nil;bb=nil;bc=true end else if be.VectorToTarget then lt(lz:normalize():project_on_plane(bt))elseif bs>150 then lt(br)end;U=0;if be.VectorToTarget and CustomTarget then local a8,_=aS.computeDistanceAndTime(bs,b7/3.6,av,0,0,LastMaxBrake)if bi and lz:len()>15000+a8+as then b9="Orbiting to Target"if as-100<=bh.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<bh.noAtmosphericDensityAltitude then bi=false end elseif bi or lz:len()<15000+a8+as then a2="Orbit complete, proceeding with reentry"c8("orCom","OB")AutopilotTargetCoords=CustomTarget.position;R=true;an=true;be.VectorToTarget,be.AutopilotAlign=false,false;cC()cJ()return end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and as>bg*0.9 and as<bg*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bg*0.99 and orbit.apoapsis.altitude>=bg*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bi then if bi then BrakeIsOn=false;cr(0)ba=0;if not be.VectorToTarget then a2="Orbit complete"c8("orCom","OB")cC()end else bm=bm+1;if bm>=2 then bi=true end end else b9="Adjusting Orbit - OrbitHeight: "..lP;bd=true;cu(lR*3.6+1)local lV=bg-as;if VSpdPID==nil then VSpdPID=pid.new(0.1,0,1*0.1)end;VSpdPID:inject(lV-bu*r(utils.smoothstep(2000-lV,-2000,2000)^6*10,1,10))ba=r(VSpdPID:get(),-60,60)end end else local lW=2.75;local lX=d(A(lQ*lW))local lY=lX%50;if lY>0 then lX=lX-lY+50 end;BrakeIsOn=false;if as<bg*0.8 then b9="Escaping planet gravity - OrbitHeight: "..lP;ba=utils.map(bu,200,0,-15,80)elseif as>=bg*0.8 and as<bg*1.15 then b9="Approaching orbital corridor - OrbitHeight: "..lP;lX=lX*0.75;ba=utils.map(bu,100,-100,-15,65)elseif as>=bg*1.15 and as<bg*1.5 then b9="Approaching orbital corridor - OrbitHeight: "..lP;lX=lX*0.75;if bu<0 or bd then ba=utils.map(as,bg*1.5,bg*1.01,-30,0)else ba=utils.map(as,bg*0.99,bg*1.5,0,30)end elseif as>bg*1.5 then b9="Reentering orbital corridor - OrbitHeight: "..lP;ba=-65;local lZ=utils.map(bu,-150,-400,1,0.55)lX=lX*lZ end;cu(e(lX))end end;if ba~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local l_=ba-bB;OrbitPitchPID:inject(l_)local m0=r(OrbitPitchPID:get(),-0.5,0.5)U=m0 end end;if Autopilot and ar==0 and not al then local function m1(bU,orbit)system.print(bU)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cr(0)P=false;a2=bU;c8("apCom","AP")if orbit or al then if orbit and AutopilotTargetOrbit~=nil and not al then if not as or as==0 then return end;bg=as;bf=true end;cC()end end;local m2,m3=AutopilotTargetCoords,false;if CustomTarget and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local m4=(CustomTarget.position-ac.center):normalize()local m5=m4:project_on_plane((ac.center-bv):normalize()):normalize()local m6=ac.center+m5*(ac.radius+AutopilotTargetOrbit)local m7=CustomTarget.position+(CustomTarget.position-ac.center):normalize()*(AutopilotTargetOrbit-ac:getAltitude(CustomTarget.position))if(bv-m6):len()<(bv-m7):len()then m2=m6 else m2=m7;AutopilotEndSpeed=0 end;AutopilotTargetCoords=m2;aX.showWayPoint(ac,AutopilotTargetCoords)m3=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget and CustomTarget.planetname=="Space"then if not TargetSet then AutopilotPlanetGravity=0;m3=true;AutopilotRealigned=true;TargetSet=true;m2=CustomTarget.position+(bv-CustomTarget.position):normalize()*AutopilotSpaceDistance;AutopilotTargetCoords=m2 end elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local m4=(bv+br*100000-ac.center):normalize()local m5=m4:project_on_plane((ac.center-bv):normalize()):normalize()if m5:len()<1 then m4=(bv+bo*100000-ac.center):normalize()m5=m4:project_on_plane((ac.center-bv):normalize()):normalize()end;m2=ac.center+m5*(ac.radius+AutopilotTargetOrbit)AutopilotTargetCoords=m2;TargetSet=true;m3=true;AutopilotRealigned=true;aX.showWayPoint(ac,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(m2)-bv):len()local c3,c4,c5=aR:getPlanetarySystem(0):castIntersections(bv,br:normalize(),function(c6)if c6.noAtmosphericDensityAltitude>0 then return c6.radius+c6.noAtmosphericDensityAltitude else return c6.radius+c6.surfaceMaxAltitude*1.5 end end)local c7=c4;if c5~=nil and c4~=nil then c7=math.min(c5,c4)end;if c7~=nil and c7<AutopilotDistance and c3.name==ac.name then AutopilotDistance=c7 end;local lK=true;local m8=(ac.center-(bv+vec3(br):normalize()*AutopilotDistance)):len()-ac.radius;local iL=cy(m8)u(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..iL..'"}')local a8,a9;if not TurnBurn then a8,a9=l7(bs)else a8,a9=l9(bs)end;if bs>50 and AutopilotAccelerating then local lz=vec3(m2)-bv;local m9=r(math.deg(bV(bn,br:normalize(),lz:normalize()))*bs/500,-90,90)local ma=r(math.deg(bV(bp,br:normalize(),lz:normalize()))*bs/500,-90,90)if d(m9)<20 and d(ma)<20 then m9=m9*2;ma=ma*2 end;if d(m9)<2 and d(ma)<2 then m9=m9*2;ma=ma*2 end;local lF=-math.deg(bV(bn,bo,br:normalize()))local lG=-math.deg(bV(bp,bo,br:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(ma-lG)local mb=r(apPitchPID:get(),-1,1)U=U+mb;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(m9-lF)local mc=r(apYawPID:get(),-1,1)V=V+mc;m3=true;if d(m9)>2 or d(ma)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"c8("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"c8("apAcc","AP")end end elseif AutopilotAccelerating and bs<=50 then lt((m2-bv):normalize())end;if m8<AutopilotTargetOrbit*1.5 then if CustomTarget and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=aU(ac):escapeAndOrbitalSpeed(m8)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local c3,c7=c1((AutopilotTargetCoords-bv):normalize())if ac.name~=planet.name then if c3~=nil and ac.name~=c3.name and c7<AutopilotDistance then a2="Collision with "..c3.name.." in "..cy(c7).."\nClear LOS to continue."ai=5;ln=true else ln=false;a2=""end end end;if not ln then if not AutopilotCruising and not AutopilotBraking and not m3 then lK=lt((m2-bv):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then lK=lt(-vec3(br):normalize())end end;if AutopilotAccelerating then if not P then BrakeIsOn=false;cr(AutopilotInterplanetaryThrottle)K=A(AutopilotInterplanetaryThrottle,2)P=true end;local md=unit.getThrottle()if AtmoSpeedAssist then md=K end;local me=99999;local ku=-vec3(core.getWorldAcceleration()):dot(br:normalize())local mf=r(br:dot((m2-bv):normalize()),0,bs)if mf>0 or ku>0 then me=aS.computeTravelTime(mf,ku,AutopilotDistance-a8)end;if bq:len()>=MaxGameVelocity or md==0 and P or warmup/4>me then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then c8("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;cr(0)end;local mg=AutopilotDistance;if mg<=a8 or PreventPvP and bI<=a8+10000 and bH then if PreventPvP and bI<=a8+10000 and bH then if bI<lb and bI>2000 then cG()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;lb=bI else lb=bI;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then c8("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;cr(0)P=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;Y=1 end;if TurnBurn then cr(1,true)end;local _,lR=aU(ac):escapeAndOrbitalSpeed((bv-planet.center):len()-planet.radius)local lz;if CustomTarget then lz=CustomTarget.position-bv end;if CustomTarget and CustomTarget.planetname=="Space"and bs<50 then m1("Autopilot complete, arrived at space location")BrakeIsOn=true;Y=1 elseif CustomTarget and CustomTarget.planetname~="Space"and bs<=lR and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then m1("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aX.showWayPoint(ac,AutopilotTargetCoords)elseif(CustomTarget and CustomTarget.planetname~="Space"or CustomTarget==nil)and orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then c8("apCir","AP")AutopilotStatus="Circularizing"end;if bs<=lR then if CustomTarget then if br:normalize():dot(lz:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then c8("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;aX.showWayPoint(ac,CustomTarget.position)WaypointSet=true end else m1("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aX.showWayPoint(ac,CustomTarget.position)WaypointSet=false end else m1("Autopilot completed, setting orbit",true)Y=0 end end elseif AutopilotStatus=="Circularizing"then m1("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then local mg=AutopilotDistance;if mg<=a8 or PreventPvP and bI<=a8+10000 and bH then if PreventPvP and bI<=a8+10000 and bH then if bI<lb and bI>2000 then cG()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;lb=bI else lb=bI;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then c8("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local md=unit.getThrottle()if AtmoSpeedAssist then md=K end;if md>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"c8("apAcc","AP")end;AutopilotCruising=false end else if lK then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget and CustomTarget.planetname~="Space"then if not al then AutopilotTargetCoords=vec3(ac.center)+(AutopilotTargetOrbit+ac.radius)*bp;AutopilotShipUp=bn;AutopilotShipRight=bp end;AutopilotRealigned=true elseif lK and not ln then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"c8("apAcc","AP")end;if not P then cr(AutopilotInterplanetaryThrottle,true)K=A(AutopilotInterplanetaryThrottle,2)P=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and ar>0)then a2="Autopilot complete, starting reentry"c8("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"Y=0;cr(0)P=false;ProgradeIsOn=true;al=true;aX.showWayPoint(ac,CustomTarget.position)end;if a0 then b0=true;local ma=0;local eM=bv+vec3(unit.getMasterPlayerRelativePosition())local mh=eM-bv;local mi=vec3(mh):project_on(bo):len()local mj=vec3(mh):project_on(bp):len()local aj=y(mi*mi+mj*mj)lt(mh:normalize())local mk=40;local ml=aj<mk;local mm=100;local mn=r((aj-mk)/2,10,mm)U=0;local lK=d(V)<0.1;if lK and bs<mn and not ml then BrakeIsOn=false;ma=-20 else BrakeIsOn=true;ma=0 end;local mo=0;if d(ma-bB)>mo then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(ma-bB)local mb=pitchPID:get()U=mb end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local mp=LastMaxBrakeInAtmo;if mp then mp=mp*r(bs/100,0.1,1)*ar else mp=LastMaxBrake end;if ar<0.01 then mp=LastMaxBrake end;local mq=bo:project_on_plane(bt):normalize():dot(br)local mr=vec3(core.getWorldAirFrictionAcceleration())local ms=mr:len()*av;if mq>100 then a8,a9=aS.computeDistanceAndTime(mq,100,av,0,0,mp)local mt,mu=aS.computeDistanceAndTime(100,0,av,0,0,mp*0.55)a8=a8+mt else a8,a9=aS.computeDistanceAndTime(mq,0,av,0,0,mp*0.55)end;local lV=HoldAltitude-as-bu;local mv=200+bs;if Reentry or al then minMax=2000+bs end;local mw=1;if AutoTakeoff then mw=r(bs/100,0.1,1)end;local ma=(utils.smoothstep(lV,-mv,mv)-0.5)*2*MaxPitch*mw;if not Reentry and not al and not VectorToTarget and bo:dot(br:normalize())<0.99 then ma=(utils.smoothstep(lV,-mv*r(20-19*ar*10,1,20),mv*r(20-19*ar*10,1,20))-0.5)*2*MaxPitch*r(2-ar*10,1,2)*mw end;if not AltitudeHold then ma=0 end;if LockPitch~=nil then if bM and not IntoOrbit then ma=LockPitch else LockPitch=nil end end;b0=true;local mx=U;if Reentry then local my=e(b7)local mz,mA=aS.computeDistanceAndTime(bs,my/3.6,av,0,0,LastMaxBrake-planet.gravity*9.8*av)mz=mz==-1 and 5000 or mz;local mB=as-(planet.noAtmosphericDensityAltitude+mz)local mC=as>planet.noAtmosphericDensityAltitude+mz*1.35;if mC then ma=ReEntryPitch;if bs<=my/3.6 and bs>my/3.6-10 and d(br:normalize():dot(bo))>0.9 and not bA then O=false;cr(1)end elseif bA and not mC and not aq then cu(my,true)end;if bA then if bs>my/3.6 and not mC then BrakeIsOn=true else BrakeIsOn=false end else BrakeIsOn=false end;if bu>0 then BrakeIsOn=true end;if not R then ma=-80;if ar>0.02 then a2="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;ma=0;b0=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and mC then b0=true elseif not mC then if not aq and(bA or s:getTargetSpeed(axisCommandId.longitudinal)~=my)then cu(my)end;if bs<my/3.6+1 then BrakeIsOn=false;R=false;Reentry=false;b0=true end end end;if bs>Q and not am and not VectorToTarget and not BrakeLanding and ForceAlignment then lt(vec3(br))end;if bK or(VectorToTarget or am)and AutopilotTargetIndex>0 and ar>0.01 then local lz;if bK then if type(bK)=="table"then lz=bK elseif bK<3 and bK>0 then lz=-bt:cross(br)*5000 elseif bK>=3 then lz=bt:cross(br)*5000 elseif bK<0 then lz=br*25000 end elseif CustomTarget~=nil then lz=CustomTarget.position-bv else lz=ac.center-bv end;local m9=math.deg(bV(bt:normalize(),br,lz))*2;local mD=math.rad(d(bC))if bs>minRollVelocity and ar>0.01 then local mE=1000+bs;local mF=(utils.smoothstep(lV-bu*10,-mE,mE)-0.5)*2*MaxPitch;local mG=r(90-mF,0,180)b4=r(m9*2,-mG,mG)local mH=m9;m9=r(r(m9,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(mD)+4*(bB-ma)*math.sin(math.rad(bC)),-YawStallAngle*0.80,YawStallAngle*0.80)local mI=1;if b4~=0 then mI=d(mD/b4)end;mI=(90-r(d(b4-bC),0,90))/90;local mJ=ma;if d(bC)>90 then mJ=-mJ end;ma=mI*r(r(mJ*math.cos(mD),-PitchStallAngle*0.8,PitchStallAngle*0.8)+d(r(d(mH)*math.sin(mD),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else b4=0;m9=r(m9,-YawStallAngle*0.80,YawStallAngle*0.80)end;local mK=lF-m9;if bK and d(mK)<=0.0001 and(type(bK)=="table"or type(bK)~="table"and bK<0 and d(bC)<1)then if bK==-2 then cD()end;bK=nil;c8("180Off","BR")return end;if not b2 and bs>minRollVelocity and ar>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(mK)local mc=r(yawPID:get(),-1,1)V=V+mc elseif aq and ao>-1 or bs<minRollVelocity then lt(lz)elseif b2 and ar>0.01 then if(lF<-YawStallAngle or lF>YawStallAngle)and ar>0.01 then lt(br)end;if(lG<-PitchStallAngle or lG>PitchStallAngle)and ar>0.01 then ma=r(bB-lG,bB-PitchStallAngle*0.80,bB+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not am then local lL=planet:getAltitude(CustomTarget.position)local mB=lz:project_on_plane(bt):len()StrongBrakes=true;if not am and not Reentry and mB<=a8 and(br:project_on_plane(bt):normalize():dot(lz:project_on_plane(bt):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"cr(0)if AltitudeHold then cD()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(mq<0.1 or mB<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<mB)then if not by then c8("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bN=false end;LastDistanceToTarget=mB end elseif VectorToTarget and ar==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(am or Reentry)then if CustomTarget~=nil and ac.name==planet.name then local lz=CustomTarget.position-bv;local lL=planet:getAltitude(CustomTarget.position)local mB=y(lz:len()^2-(as-lL)^2)local mp=LastMaxBrakeInAtmo;if mp then a8,a9=aS.computeDistanceAndTime(bs,0,av,0,0,mp/2)StrongBrakes=true;if mB<=a8+bs*lE/2 and br:project_on_plane(bt):normalize():dot(lz:project_on_plane(bt):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;R=true;al=false;an=true;Autopilot=false;cJ()end end;LastDistanceToTarget=mB end end end;if ar==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(am or IntoOrbit or Reentry)then if not bi and not IntoOrbit then bg=HoldAltitude;bf=true;if VectorToTarget then be.VectorToTarget=true end;cC()VectorToTarget=false;bc=true end end;if b2 and ar>0.01 and ao==-1 and bs>minRollVelocity and VectorStatus~="Finalizing Approach"then lt(br)ma=r(bB-lG,bB-PitchStallAngle*0.80,bB+PitchStallAngle*0.80)end;U=mx;local lh=-1;if BrakeLanding then ma=0;local mL=false;local mM=30;if aT~=nil and aT>0 then local mN=r(ar,0.4,2)local mp=LastMaxBrakeInAtmo*r(bs/100,0.1,1)*mN;local mO=aT*mN+mp-ki;local mP=mp/2-ki;local mQ=bs-y(d(mP/2)*20/(0.5*av))*utils.sign(mP)if mQ<0 then mQ=0 end;local mR;if bs>100 then local mS,_=aS.computeDistanceAndTime(bs,100,av,0,0,mp)local mT,_=aS.computeDistanceAndTime(100,0,av,0,0,y(mp))mR=mS+mT else mR=aS.computeDistanceAndTime(bs,0,av,0,0,y(mp))end;if mR<20 then BrakeIsOn=false else local mU=0;if mQ>100 then local mV,_=aS.computeDistanceAndTime(mQ,100,av,0,0,mO)local mW,_=aS.computeDistanceAndTime(100,0,av,0,0,aT*mN+y(mp)-ki)mU=mV+mW else mU,_=aS.computeDistanceAndTime(mQ,0,av,0,0,aT*mN+y(mp)-ki)end;mU=(mU+15+bs*lE)*1.1;local mX=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if mX then local lL=planet:getAltitude(CustomTarget.position)local mY=as-lL-100;local lz=CustomTarget.position-bv;local mZ=y(lz:len()^2-(as-lL)^2)if mZ>100 then mX=false elseif mY<=mU or mU==-1 then BrakeIsOn=true;mL=true else BrakeIsOn=false;mL=true end end;if not mX and CalculateBrakeLandingSpeed then if mU>=mM then BrakeIsOn=true else BrakeIsOn=false end;mL=true end end end;if not bA then cr(0)end;s:setTargetGroundAltitude(500)s:activateGroundEngineAltitudeStabilization(500)stablized=true;lh=ao;if lh>-1 then b0=autoRollPreference;if bs<1 or br:normalize():dot(bt)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if S then a.control.extendLandingGears()c8("grOut","LG",1)end;s:setTargetGroundAltitude(LandingGearGroundHeight)af=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and br:normalize():dot(-hc)<0.999 then BrakeIsOn=true elseif bu<-brakeLandingRate and not mL then BrakeIsOn=true elseif not mL then BrakeIsOn=false end end;if AutoTakeoff or am then local c3,c5,c4;if AutopilotTargetCoords~=nil then c3,c5,c4=aR:getPlanetarySystem(0):castIntersections(bv,(AutopilotTargetCoords-bv):normalize(),function(c6)return c6.radius+c6.noAtmosphericDensityAltitude end)end;if by then if as>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;cr(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif d(ma)<15 and as/HoldAltitude>0.75 then AutoTakeoff=false;if not am then if bA and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif am and bs<Q then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;cr(0)elseif am then cr(0)BrakeIsOn=true end elseif am and ar==0 and ac~=nil and(c3==nil or c3.name==ac.name)then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;if not bA then cr(0)end;AutopilotAccelerating=true end end;local m_=ao>-1;local n0=bB;if(VectorToTarget or am or bK)and not m_ and bs>minRollVelocity and ar>0.01 then local mD=math.rad(d(bC))n0=bB*d(math.cos(mD))+lG*math.sin(mD)end;local n1=r(ma-n0,-PitchStallAngle*0.80,PitchStallAngle*0.80)if ar<0.01 and VectorToTarget then n1=r(ma-n0,-85,MaxPitch)elseif ar<0.01 then n1=r(ma-n0,-MaxPitch,MaxPitch)end;if d(bC)<5 or VectorToTarget or bK or BrakeLanding or m_ or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(n1)local mb=pitchPID:get()U=U+mb end end;if antigrav~=nil and(antigrav and not ExternalAGG and as<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;ao=lc()return cF end;function script.onStart()local n2={}local n3={}local n4=false;local function n5()local function n6(n7)local n8=dbHud_1.hasKey;for cU,cV in pairs(n7)do if n8(cV)then local da=g(dbHud_1.getStringValue(cV))if da~=nil then _G[cV]=da;n4=true end end end end;if dbHud_1 then if not useTheseSettings then n6(ce())coroutine.yield()n6(c)else n6(c)a2="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ai=5;n4=false end;coroutine.yield()if n4 then a2="Loaded Saved Variables"aG=ResolutionX;aH=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)b0=autoRollPreference;b7=AtmoSpeedLimit;ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]elseif not useTheseSettings then a2="No Saved Variables Found - Exit HUD to save settings"end;if LastVersionUpdate<1.500 then if LowOrbitHeight<2000 then a2="Updating LowOrbitHeight to new minimum default of 2000."LowOrbitHeight=2000 end end;LastVersionUpdate=VERSION_NUMBER else a2="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<E then LastMaxBrakeInAtmo=0 end;LastStartTime=E;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a2="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ai=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function n9()local function na(nb,nc)if nb>nc then nc=nb end;local nd,ne=0,0;if ContainerOptimization>0 then nd=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then ne=FuelTankOptimization*0.05 end;nc=nc*(1-(nd+ne))return nc end;local nf=core.getElementNameById;local ng=fuelX~=0 and fuelY~=0;for cU in pairs(at)do local type=core.getElementTypeById(at[cU])if o(type,'^.*Atmospheric Engine$')then if o(tostring(core.getElementTagsById(at[cU])),'^.*vertical.*$')and core.getElementForwardById(at[cU])[3]>0 then bx=true end end;if o(type,'^.*Space Engine$')then bl=true;if o(tostring(core.getElementTagsById(at[cU])),'^.*vertical.*$')then local nh=core.getElementForwardById(at[cU])if nh[3]<0 then bj=true else bk=true end end end;if type=="Landing Gear"then S=true end;if type=="Dynamic Core Unit"then local ni=j(at[cU])if ni>10000 then G=110 elseif ni>1000 then G=55 elseif ni>150 then G=27 end end;aL=aL+j(at[cU])if ng and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local ni=j(at[cU])local kq=l(at[cU])local nb=0;local h0=q()if type=="Atmospheric Fuel Tank"then local nc=400;local nj=35.03;if ni>10000 then nc=51200;nj=5480 elseif ni>1300 then nc=6400;nj=988.67 elseif ni>150 then nc=1600;nj=182.67 end;nb=kq-nj;if fuelTankHandlingAtmo>0 then nc=nc+nc*fuelTankHandlingAtmo*0.2 end;nc=na(nb,nc)aI[#aI+1]={at[cU],nf(at[cU]),nc,nj,nb,h0}end;if type=="Rocket Fuel Tank"then local nc=320;local nj=173.42;if ni>65000 then nc=40000;nj=25740 elseif ni>6000 then nc=5120;nj=4720 elseif ni>700 then nc=640;nj=886.72 end;nb=kq-nj;if fuelTankHandlingRocket>0 then nc=nc+nc*fuelTankHandlingRocket*0.1 end;nc=na(nb,nc)aK[#aK+1]={at[cU],nf(at[cU]),nc,nj,nb,h0}end;if type=="Space Fuel Tank"then local nc=600;local nj=35.03;if ni>10000 then nc=76800;nj=5480 elseif ni>1300 then nc=9600;nj=988.67 elseif ni>150 then nc=2400;nj=182.67 end;nb=kq-nj;if fuelTankHandlingSpace>0 then nc=nc+nc*fuelTankHandlingSpace*0.2 end;nc=na(nb,nc)aJ[#aJ+1]={at[cU],nf(at[cU]),nc,nj,nb,h0}end end end;if not bx then VertTakeOff,VertTakeOffEngine=false,false end end;local function nk()if gyro~=nil then ax=gyro.getState()==1 end;if not stablized then s:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then w(1)else w(0)end;if door and(aq or not aq and as<10000)then for _,cV in pairs(door)do cV.toggle()end end;if switch then for _,cV in pairs(switch)do cV.toggle()end end;if forcefield and(aq or not aq==0 and as<10000)then for _,cV in pairs(forcefield)do cV.toggle()end end;if antigrav then by=antigrav.getState()==1;if by and not ExternalAGG then antigrav.show()end end;if m()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if S then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ao~=-1 or not aq and bq:len()<50 then BrakeIsOn=true;GearExtended=true;if S then a.control.extendLandingGears()end else BrakeIsOn=false end;s:setTargetGroundAltitude(b1)if aq and ao~=-1 then aT=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=aq end;local function nl(cm,cn,nm,kz,ii)local nn={x=cm,y=cn,width=nm,height=kz,label=ii}bT[ii]=nn;return nn end;local function no(np,nq,nm,kz,cm,cn,nr,ns,nt,nu)local nn={enableName=np,disableName=nq,width=nm,height=kz,x=cm,y=cn,toggleVar=nr,toggleFunction=ns,drawCondition=nt,hovered=false}if nu then table.insert(n3,nn)else table.insert(n2,nn)end;return nn end;local function nw(nx)if not bD then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif nx=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif nx=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif nx=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bE=ce(nx)showHud=false else bE={}showHud=true end end;local function ny()bD=not bD;if bD then aF=n3;a2="Hold SHIFT to see Settings"bF=showHud else aF=n2;a2="Hold SHIFT to see Control Buttons"nw()showHud=bF end end;local function nz(cV)_G[cV]=not _G[cV]if _G[cV]then a2=cV.." set to true"else a2=cV.." set to false"end;if cV=="showHud"then bF=_G[cV]elseif cV=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local function nA()local nB=50;local nC=340;local cm=500;local cn=aH/2-400;local nD=0;for cU,cV in pairs(ce("boolean"))do if type(_G[cV])=="boolean"then no(cV,cV,nC,nB,cm,cn,function()return _G[cV]end,function()nz(cV)end,function()return true end,true)cn=cn+nB+20;if nD==9 then cm=cm+nC+20;cn=aH/2-400;nD=0 else nD=nD+1 end end end;no("Control View","Control View",nC,nB,10,aH/2-500,function()return true end,ny,function()return true end,true)no("View Handling Settings",'Hide Handling Settings',nC,nB,10,aH/2-(500-nB),function()return showHandlingVariables end,function()nw("handling")end,function()return true end,true)no("View Hud Settings",'Hide Hud Settings',nC,nB,10,aH/2-(500-nB*2),function()return showHudVariables end,function()nw("hud")end,function()return true end,true)no("View Physics Settings",'Hide Physics Settings',nC,nB,10,aH/2-(500-nB*3),function()return showPhysicsVariables end,function()nw("physics")end,function()return true end,true)end;local function nE()local function l0()local position=bv;local g9=planet.name..". "..#SavedLocations;if bP[1]then local dm,_=bP[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dm~=nil and dm~=""then g9=g9 .." "..bP[1].getConstructName(dm)end end;return aW.AddNewLocation(g9,position,false,true)end;local function nF()TurnBurn=not TurnBurn end;local function nG(nH)if nH==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;a0=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function nI()aW.UpdatePosition()end;local function k_()aW.ClearCurrentPosition()end;local function nJ(fV)local g9=AutopilotTargetName;if fV~=nil and type(fV)=="number"then if fV==0 then return"None"end;g9=bG[fV].name end;if g9==nil then g9=CustomTarget.name end;if g9==nil then g9="None"end;return g9 end;local function nK(fV)return"Engage Autopilot: "..nJ(fV)end;local function nL(fV)return"Disable Autopilot: "..nJ(fV)end;local function nM()if m()==1 then a0=not a0;if a0 then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)c8("folOn","F")else c8("folOff","F")BrakeIsOn=true;b0=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end end else a2="Follow Mode only works with Remote controller"a0=false end end;local nB=50;local nC=260;local nN=no("Enable Brake Toggle","Disable Brake Toggle",nC,nB,aG/2-nC/2,aH/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a2="Brakes in Toggle Mode"else a2="Brakes in Default Mode"end end)no("Align Prograde","Disable Prograde",nC,nB,aG/2-nC/2-50-nN.width,aH/2-nB+380,function()return ProgradeIsOn end,function()nG(1)end)no("Align Retrograde","Disable Retrograde",nC,nB,aG/2-nC/2+nN.width+50,aH/2-nB+380,function()return RetrogradeIsOn end,nG,function()return ar==0 end)apbutton=no(nK,nL,600,60,aG/2-600/2,aH/2-60/2-330,function()return Autopilot or VectorToTarget or am or IntoOrbit end,function()end)local i;local function nO(nP)local fV=bS+nP;if fV>#bG then fV=fV-#bG-1 end;if fV<0 then fV=#bG+fV end;return fV end;apExtraButtons={}for i=0,10 do local button=no(function(cx)local fV=nO(cx.apExtraIndex)if Autopilot or VectorToTarget or am or IntoOrbit then return"Redirect: "..nJ(fV)end;return nK(fV)end,function(cx)local fV=nO(cx.apExtraIndex)return nL(fV)end,600,60,aG/2-600/2,aH/2-60/2-330+60*i,function(cx)local fV=nO(cx.apExtraIndex)return fV==AutopilotTargetIndex and(Autopilot or VectorToTarget or am or IntoOrbit)end,function(cx)local fV=nO(cx.apExtraIndex)local nQ=AutopilotTargetIndex==fV;AutopilotTargetIndex=fV;aW.UpdateAutopilotTarget()cG()if not nQ and not(Autopilot or VectorToTarget or am or IntoOrbit)then cG()end end,function()return bR end)button.apExtraIndex=i;apExtraButtons[i]=button end;no("Save Position","Save Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,l0,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)no("Update Position","Update Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,nI,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)no("Clear Position","Clear Position",200,apbutton.height,apbutton.x-200-30,apbutton.y,function()return true end,k_,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)nB=60;nC=300;local cm=aG-nC-10;local cn=aH/2-150;no("View Settings","View Settings",nC,nB,cm,cn,function()return true end,ny)cn=cn+nB+20;no("Enable Turn and Burn","Disable Turn and Burn",nC,nB,cm,cn,function()return TurnBurn end,nF)cm=10;cn=aH/2-300;no("Horizontal Takeoff Mode","Vertical Takeoff Mode",nC,nB,cm+nC+20,cn,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a2="Vertical Takeoff Mode"else a2="Horizontal Takeoff Mode"end end,function()return bx end)cn=cn+nB+20;no("Engage Orbiting","Cancel Orbiting",nC,nB,cm+nC+20,cn,function()return IntoOrbit end,cC,function()return ar==0 and bM end)cn=cn+nB+20;no("Glide Re-Entry","Cancel Glide Re-Entry",nC,nB,cm,cn,function()return Reentry end,function()al=1;nG(1)end,function()return planet.hasAtmosphere and not aq end)no("Parachute Re-Entry","Cancel Parachute Re-Entry",nC,nB,cm+nC+20,cn,function()return Reentry end,cJ,function()return planet.hasAtmosphere and not aq end)cn=cn+nB+20;no("Engage Follow Mode","Disable Follow Mode",nC,nB,cm,cn,function()return a0 end,nM,function()return m()==1 end)no("Enable Repair Arrows","Disable Repair Arrows",nC,nB,cm+nC+20,cn,function()return aM end,function()aM=not aM;if aM then a2="Repair Arrows Enabled"else a2="Repair Arrows Diabled"end end,function()return m()==1 end)cn=cn+nB+20;if not ExternalAGG then no("Enable AGG","Disable AGG",nC,nB,cm,cn,function()return by end,cK,function()return antigrav~=nil end)end;no(function()return f("Switch IPH Mode - Current: %s",iphCondition)end,function()return f("IPH Mode: %s",iphCondition)end,nC*2,nB,cm,cn,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a2="IPH Mode: "..iphCondition end)cn=cn+nB+20;no(function()return f("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return f("Control Scheme: %s",userControlScheme)end,nC*2,nB,cm,cn,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a2="New Control Scheme: "..userControlScheme end)local nR=gl(20)local button=nl(0,0,gk(70),nR,"INFO")button=nl(button.x+button.width,button.y,gk(80),nR,"ORBIT")button=nl(button.x+button.width,button.y,gk(70),nR,"HELP")button=nl(button.x+button.width,button.y,gk(70),nR,"HIDE")button=nl(button.x+button.width,button.y,gk(70),nR,"SCOPE")end;local function nS()local nT={}local function nU()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local nV={[1]=4480,[6]=4480,[7]=6270}for nW,nX in pairs(b)do b[nW][0]=nU()b[nW][0].systemId=nW;nT[nW]={}for nY,planet in pairs(b[nW])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]planet.noAtmosphericDensityAltitude=planet.atmosphereThickness or planet.atmosphereRadius-planet.radius;planet.spaceEngineMinAltitude=nV[planet.id]or 0.68377*(planet.atmosphereThickness or planet.atmosphereRadius-planet.radius)planet.planetarySystemId=nW;planet.bodyId=planet.id;nT[nW][nY]=planet;if minAtlasX==nil or planet.center.x<minAtlasX then minAtlasX=planet.center.x end;if maxAtlasX==nil or planet.center.x>maxAtlasX then maxAtlasX=planet.center.x end;if minAtlasY==nil or planet.center.y<minAtlasY then minAtlasY=planet.center.y end;if maxAtlasY==nil or planet.center.y>maxAtlasY then maxAtlasY=planet.center.y end end end;aQ=cW()aR=aQ(nT)aS=eg()aU=eK()aY=f7()aV=gm()aW=kO()end;SetupComplete=false;beginSetup=coroutine.create(function()s:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})n5()coroutine.yield()n9()coroutine.yield()aX=l6()nk()nA()nE()aF=n2;coroutine.yield()nS()coroutine.yield()unit.hide()system.showScreen(1)system.showHelper(0)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)bP[1]=nil;if radar_1 then bP[1]=radar_1;aY.pickType()end;c8("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(ar>0 or ar==0 and as<10000)then for _,cV in pairs(door)do cV.toggle()end end;if switch then for _,cV in pairs(switch)do cV.toggle()end end;if forcefield and(ar>0 or ar==0 and as<10000)then for _,cV in pairs(forcefield)do cV.toggle()end end;cQ()if button then button.activate()end;if SetWaypointOnExit then aX.showWayPoint(planet,bv)end;c8("stop","SU")end;function script.onTick(nZ)local n_=nil;if nZ=="contact"then if not contactTimer then contactTimer=0 end;if E>contactTimer+10 then a2="Radar Contact"c8("rdrCon","RC")contactTimer=E end;unit.stopTimer("contact")elseif nZ=="tenthSecond"then local function o0()local o1=system.createData;local o2=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=o2(panelInterplanetary,"value")interplanetaryHeaderText=o1('{"label": "Target Planet", "value": "N/A", "unit":""}')v(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=o2(panelInterplanetary,"value")widgetDistanceText=o1('{"label": "distance", "value": "N/A", "unit":""}')v(widgetDistanceText,widgetDistance)widgetTravelTime=o2(panelInterplanetary,"value")widgetTravelTimeText=o1('{"label": "Travel Time", "value": "N/A", "unit":""}')v(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=o2(panelInterplanetary,"value")widgetMaxMassText=o1('{"label": "Maximum Mass", "value": "N/A", "unit":""}')v(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=o2(panelInterplanetary,"value")widgetTargetOrbitText=o1('{"label": "Target Altitude", "value": "N/A", "unit":""}')v(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=o2(panelInterplanetary,"value")widgetCurBrakeDistanceText=o1('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=o2(panelInterplanetary,"value")widgetCurBrakeTimeText=o1('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=o2(panelInterplanetary,"value")widgetMaxBrakeDistanceText=o1('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=o2(panelInterplanetary,"value")widgetMaxBrakeTimeText=o1('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=o2(panelInterplanetary,"value")widgetTrajectoryAltitudeText=o1('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not aq then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)v(widgetCurBrakeTimeText,widgetCurBrakeTime)v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function o3()t(panelInterplanetary)panelInterplanetary=nil end;local function o4()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ac.center-bv):len()else AutopilotDistance=(CustomTarget.position-bv):len()end end;local eI=bs;local md=unit.getThrottle()/100;if AtmoSpeedAssist then md=K end;local o5,o6=aS.computeDistanceAndTime(bs,MaxGameVelocity,av,a:maxForceForward()*md,warmup,0)local a8,a9;if not TurnBurn then a8,a9=aX.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aX.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,o7;if not TurnBurn and eI>0 then _,o7=aX.GetAutopilotBrakeDistanceAndTime(eI)else _,o7=aX.GetAutopilotTBBrakeDistanceAndTime(eI)end;local o8=0;local o9=0;if AutopilotCruising or not Autopilot and eI>5 then o9=aS.computeTravelTime(eI,0,AutopilotDistance)elseif a8+o5<AutopilotDistance then o8=AutopilotDistance-(a8+o5)o9=aS.computeTravelTime(8333.0556,0,o8)else local oa=(AutopilotDistance-a8)/o5;o5=AutopilotDistance-a8;o6=o6*oa end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return o9 elseif AutopilotBraking then return o7 elseif AutopilotCruising then return o9+o7 else return o6+a9+o9 end end;local function ob(ki,oc)if ki==nil then ki=core.g()end;ki=A(ki,5)if oc~=nil and oc or(n_==nil or n_~=ki)then local eI=bq:len()local od=g(unit.getData()).maxBrake;if od~=nil and od>0 and aq then od=od/r(eI/100,0.1,1)od=od/ar;if ar>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+od)/2 else LastMaxBrakeInAtmo=od end end end;if od~=nil and od>0 then LastMaxBrake=od end;n_=ki end end;ob(nil,true)if bz~=nil then if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or s:getTargetSpeed(axisCommandId.longitudinal)~=bz then cu(bz)else bz=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then o0()end;if AutopilotTargetName~=nil then local oe=CustomTarget~=nil;local of=0.5*LastMaxBrakeInAtmo/ac:getGravity(ac.center+vec3(0,0,1)*ac.radius):len()of=of>1000000 and A(of/1000000,2).." kTons"or A(of/1000,2).." Tons"u(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=o4()if oe and not Autopilot then aj=(bv-CustomTarget.position):len()else aj=(AutopilotTargetCoords-bv):len()end;if not TurnBurn then a8,a9=aX.GetAutopilotBrakeDistanceAndTime(bs)aa,ab=aX.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aX.GetAutopilotTBBrakeDistanceAndTime(bs)aa,ab=aX.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local iL=cy(aj)u(widgetDistanceText,'{"label": "distance", "value": "'..iL..'"}')u(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..cL(travelTime)..'", "unit":""}')iL=cy(a8)u(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..iL..'"}')u(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..cL(a9)..'", "unit":""}')iL=cy(aa)u(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..iL..'"}')u(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..cL(ab)..'", "unit":""}')u(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..f("%s",of)..'", "unit":""}')iL=cy(AutopilotTargetOrbit)u(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..iL..'"}')if ar>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not bA and AtmoSpeedAssist and(AltitudeHold or Reentry or an)then cr(1)BrakeIsOn=false;O=false end end;if ar==0 and WasInAtmo then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else o3()end;if warpdrive~=nil then if g(warpdrive.getData()).destination~="Unknown"and g(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;aV.DrawTanks()if shield_1 then aV.DrawShield()end elseif nZ=="oneSecond"then local function og(h8)local oh=0;aD=""local oi=aL;local oj=0;local ok=0;local ol=0;local h4=0;local h5=""local om=core.getElementHitPointsById;for cU in pairs(at)do local ni=0;local on=0;on=j(at[cU])ni=om(at[cU])oj=oj+ni;if ni<on then if ni==0 then ol=ol+1 else ok=ok+1 end;if aM and#aA==0 then position=vec3(core.getElementPositionById(at[cU]))local cm=position.x;local cn=position.y;local fC=position.z;table.insert(aA,core.spawnArrowSticker(cm,cn,fC+1,"down"))table.insert(aA,core.spawnArrowSticker(cm,cn,fC+1,"down"))core.rotateSticker(aA[2],0,0,90)table.insert(aA,core.spawnArrowSticker(cm+1,cn,fC,"north"))table.insert(aA,core.spawnArrowSticker(cm+1,cn,fC,"north"))core.rotateSticker(aA[4],90,90,0)table.insert(aA,core.spawnArrowSticker(cm-1,cn,fC,"south"))table.insert(aA,core.spawnArrowSticker(cm-1,cn,fC,"south"))core.rotateSticker(aA[6],90,-90,0)table.insert(aA,core.spawnArrowSticker(cm,cn-1,fC,"east"))table.insert(aA,core.spawnArrowSticker(cm,cn-1,fC,"east"))core.rotateSticker(aA[8],90,0,90)table.insert(aA,core.spawnArrowSticker(cm,cn+1,fC,"west"))table.insert(aA,core.spawnArrowSticker(cm,cn+1,fC,"west"))core.rotateSticker(aA[10],-90,0,90)table.insert(aA,at[cU])end elseif aM and#aA>0 and aA[11]==at[cU]then for g_ in pairs(aA)do core.deleteSticker(aA[g_])end;aA={}end end;oh=e(oj/oi*100)if oh<100 then if oh>0 and oh<WipeDamage then SavedLocations={}aW.UpdateAtlasLocationsList()aW.UpdateAutopilotTarget()cQ()end;h8[#h8+1]=cl(0,0,"","pbright txt")h4=e(oh*2.55)h5=f("rgb(%d,%d,%d)",255-h4,h4,0)if oh<100 then h8[#h8+1]=cl("50%",1035,"Elemental Integrity: "..oh.."%","txtbig txtmid","fill:"..h5)if ol>0 then h8[#h8+1]=cl("50%",1055,"Disabled Modules: "..ol.." Damaged Modules: "..ok,"txtbig txtmid","fill:"..h5)elseif ok>0 then h8[#h8+1]=cl("50%",1055,"Damaged Modules: "..ok,"txtbig txtmid","fill:"..h5)end end end end;local function oo()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then t(WeaponPanelID)WeaponPanelID=nil end end end;local function op()local h0=q()local il=bs;local oq=h0-au;if il>1.38889 then il=il/1000;local os=il*(h0-au)TotalDistanceTravelled=TotalDistanceTravelled+os;ad=ad+os end;ae=ae+oq;TotalFlightTime=TotalFlightTime+oq;au=h0 end;op()aV.UpdatePipe()passengers=core.getPlayersOnBoard()ships=core.getDockedConstructs()oo()local h8={}aV.ExtraData(h8)if ShouldCheckDamage then og(h8)end;ak=table.concat(h8,"")collectgarbage("collect")elseif nZ=="fiveSecond"then if not UseSatNav then return end;ap=dbHud_1.getStringValue("SPBAutopilotTargetName")if ap~=nil and ap~=""and ap~="SatNavNotChanged"then local da=g(dbHud_1.getStringValue("SavedLocations"))if da~=nil then _G["SavedLocations"]=da;local fV=-1;local l2;for cU,cV in pairs(SavedLocations)do if cV.name and cV.name=="SatNav Location"then fV=cU;break end end;if fV~=-1 then l2=SavedLocations[fV]fV=-1;for cU,cV in pairs(b[0])do if cV.name and cV.name=="SatNav Location"then fV=cU;break end end;if fV>-1 then b[0][fV]=l2 end;aW.UpdateAtlasLocationsList()a2=l2.name.." position updated"end end;for i=1,#bG do if bG[i].name==ap then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bG[i].name)aW.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif nZ=="msgTick"then local h8={}aV.DisplayMessage(h8,"empty")a2="empty"unit.stopTimer("msgTick")ai=3 elseif nZ=="animateTick"then a_=true;aZ=false;ag=0;ah=0;unit.stopTimer("animateTick")elseif nZ=="hudTick"then if not planet then return end;local function ot(h8)local ou=e(r(aj/(aG/4)*255,0,255))h8[#h8+1]=f("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ag,ah,e(H+0.5)+ou,e(J+0.5)-ou,e(I+0.5)-ou)end;local function ov()for _,cV in pairs(aF)do if cV.hovered then if not cV.drawCondition or cV.drawCondition(cV)then cV.toggleFunction(cV)end;cV.hovered=false end end;for _,cV in pairs(bT)do if cV.hovered then SelectedTab=cV.label;cV.hovered=false end end end;local function ow()local function ox(oy,oz,cm,cn,nm,kz)if oy>=cm and oy<=cm+nm and oz>=cn and oz<=cn+kz then return true else return false end end;local cm=ag+aG/2;local cn=ah+aH/2;for _,cV in pairs(aF)do cV.hovered=ox(cm,cn,cV.x,cV.y,cV.width,cV.height)end;for _,cV in pairs(bT)do cV.hovered=ox(cm,cn,cV.x,cV.y,cV.width,cV.height)end;if bR then local oA=false;for _,cx in ipairs(apExtraButtons)do if cx.hovered then oA=true;break end end;if apbutton.hovered then oA=true end;bR=oA else bR=apbutton.hovered;if not bR then bS=AutopilotTargetIndex end end end;local function oB(h8)if not SelectedTab or SelectedTab==""then SelectedTab="INFO"end;for cU,cV in pairs(bT)do local cp="dim brightstroke"local oC=0.2;if SelectedTab==cU then cp="pbright dimstroke"oC=0.6 end;local oD=""if cV.hovered then oC=0.8;oD=";stroke:white"end;h8[#h8+1]=f([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],cV.width,cV.height,cV.x,cV.y,cp,oC,oD)h8[#h8+1]=cl(cV.x+cV.width/2,cV.y+cV.height/2+5,cV.label,"txt txtmid pdim")end end;local function oE(h8)local function oF(h8,oG,hover,cm,cn,eB,oH,oI,oJ,oK,oL,button)if type(oK)=="function"then oK=oK(button)end;if type(oL)=="function"then oL=oL(button)end;h8[#h8+1]=f("<rect x='%f' y='%f' width='%f' height='%f' fill='",cm,cn,eB,oH)if oG then h8[#h8+1]=f("%s'",oI)else h8[#h8+1]=oJ end;if hover then h8[#h8+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",SafeR,SafeG,SafeB)else h8[#h8+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",A(SafeR*0.5,0),A(SafeG*0.5,0),A(SafeB*0.5,0))end;h8[#h8+1]=" rx='5'></rect>"h8[#h8+1]=f("<text x='%f' y='%f' font-size='24' fill='",cm+eB/2,cn+oH/2+5)if oG then h8[#h8+1]="black"else h8[#h8+1]="white"end;h8[#h8+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oG then h8[#h8+1]=f("%s</text>",oK)else h8[#h8+1]=f("%s</text>",oL)end end;local oM=f("rgb(%d,%d,%d)'",A(SafeR*0.1,0),A(SafeG*0.1,0),A(SafeB*0.1,0))local oN=f("rgb(%d,%d,%d)",A(SafeR*0.8,0),A(SafeG*0.8,0),A(SafeB*0.8,0))local oO=oF;for _,cV in pairs(aF)do local nq=cV.disableName;local np=cV.enableName;if type(nq)=="function"then nq=nq(cV)end;if type(np)=="function"then np=np(cV)end;if not cV.drawCondition or cV.drawCondition(cV)then oO(h8,cV.toggleVar(cV),cV.hovered,cV.x,cV.y,cV.width,cV.height,oN,oM,nq,np,cV)end end end;local oP=A(ResolutionX/2,0)local oQ=A(ResolutionY/2,0)local h8={}aV.HUDPrologue(h8)if showHud then aV.UpdateHud(h8)else if AlwaysVSpd then aV.DrawVerticalSpeed(h8,as)end;aV.DisplayOrbitScreen(h8)aV.DrawWarnings(h8)end;if bD and bE~={}then aV.DrawSettings(h8)end;if radar_1 or radar_2 then aY.assignRadar()end;if bP[1]then aV.DrawRadarInfo()end;aV.HUDEpilogue(h8)h8[#h8+1]=f([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aG,aH)if a2~="empty"then aV.DisplayMessage(h8,a2)end;if m()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then aV.DrawDeadZone(h8)end end;oB(h8)if x()==0 then if m()==1 and a1 then if not AltIsOn then ow()oE(h8)end;if not aZ and not a_ then local oR=table.concat(h8,"")h8={}h8[#h8+1]=f("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aG,aH)h8[#h8+1]=oR;h8[#h8+1]="</body>"aZ=true;h8[#h8+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(h8,"")system.setScreen(content)elseif a_ then local oR=table.concat(h8,"")h8={}h8[#h8+1]=f("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aG,aH)h8[#h8+1]=oR;h8[#h8+1]="</body>"end;if not aZ then h8[#h8+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oP,oQ,ag,ah)end else ov()end else if not a1 and m()==0 then ov()if aj>DeadZone then if DisplayDeadZone then ot(h8)end end elseif not AltIsOn and a1 then ow()oE(h8)end;h8[#h8+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oP,oQ,ag,ah)end;h8[#h8+1]=[[</svg></body>]]content=table.concat(h8,"")elseif nZ=="apTick"then aX.APTick()elseif nZ=="radarTick"then aY.UpdateRadar()elseif nZ=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;a2="Extra Engine Tags: "..UseExtra;unit.stopTimer("tagTick")end end;function script.onFlush()local function oS(oT,mn)local oU=vec3()local oV=vec3()if oT==axisCommandId.longitudinal then oU=vec3(core.getConstructOrientationForward())oV=bo elseif oT==axisCommandId.vertical then oU=vec3(core.getConstructOrientationUp())oV=bn elseif oT==axisCommandId.lateral then oU=vec3(core.getConstructOrientationRight())oV=bp else return vec3()end;local oW=vec3(core.getWorldGravity())local oX=oW:dot(oV)local oY=vec3(core.getWorldAirFrictionAcceleration())local oZ=oY:dot(oV)local o_=bq:dot(oU)local p0=mn*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(p0-o_)local p1=targetSpeedPID2:get()local p2=(p1-oZ-oX)*oV;return p2 end;local function p3(oT,mn)local oU=vec3()local oV=vec3()if oT==axisCommandId.longitudinal then oU=vec3(core.getConstructOrientationForward())oV=bo elseif oT==axisCommandId.vertical then oU=vec3(core.getConstructOrientationUp())oV=bn elseif oT==axisCommandId.lateral then oU=vec3(core.getConstructOrientationRight())oV=bp else return vec3()end;local oW=vec3(core.getWorldGravity())local oX=oW:dot(oV)local oY=vec3(core.getWorldAirFrictionAcceleration())local oZ=oY:dot(oV)local o_=bq:dot(oU)local p0=mn*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(p0-o_)local p1=targetSpeedPID:get()local p2=(p1-oZ-oX)*oV;return p2 end;local function p4(p5,hb,kT)local p6=p5:cross(kT):normalize_inplace()local hY=math.acos(r(p6:dot(-hb),-1,1))*constants.rad2deg;if p6:cross(-hb):dot(kT)<0 then hY=-hY end;return hY end;if antigrav and not ExternalAGG then if not by and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bA=s:getAxisCommandType(0)==axisCommandType.byThrottle;if bA and O then cr(0)O=false elseif not bA and not O then K=0;O=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local p7=r(T+U+system.getControlDeviceForwardInput(),-1,1)local p8=r(W+Z+system.getControlDeviceYawInput(),-1,1)local p9=r(X+V-system.getControlDeviceLeftRightInput(),-1,1)local pa=Y;bt=vec3(core.getWorldVertical())if bt==nil or bt:len()==0 then bt=(planet.center-bv):normalize()end;bn=vec3(core.getConstructWorldOrientationUp())bo=vec3(core.getConstructWorldOrientationForward())bp=vec3(core.getConstructWorldOrientationRight())br=vec3(core.getWorldVelocity())bq=vec3(core.getVelocity())bv=vec3(core.getConstructWorldPos())av=core.getConstructMass()bs=vec3(br):len()bu=-bt:dot(br)bC=getRoll(bt,bo,bp)local pb=bC/180*math.pi;local pc=math.cos(pb)local pd=math.sin(pb)bB=p4(bt,bo,bp*pc+bn*pd)local pe=br:normalize()local pf=d(bC)local pg=utils.sign(bC)local ph=vec3(core.getWorldAngularVelocity())local pi=p7*pitchSpeedFactor*bp+p8*rollSpeedFactor*bo+p9*yawSpeedFactor*bn;if b0==true and bt:len()>0.01 then local pj=d(b4-bC)if((ProgradeIsOn or Reentry or BrakeLanding or al or AltitudeHold or IntoOrbit)and pj>0 or ar>0.0 and pj<autoRollRollThreshold and autoRollPreference)and p8==0 and d(bB)<85 then local pk=b4;local pl=autoRollFactor;if ar==0 then pl=pl/4;b4=0;pk=0 end;if rollPID==nil then rollPID=pid.new(pl*0.01,0,pl*0.1)end;rollPID:inject(pk-bC)local pm=rollPID:get()pi=pi+pm*bo end end;local pn=1;local po=0;local pp=1;local pq=system.getMouseWheel()if pq>0 then bZ()elseif pq<0 then bZ(true)else aw=true end;L=0;if aq and AtmoSpeedAssist and bA then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(b7/3.6-br:dot(bo))local pr=throttlePID:get()N=r(pr,-1,1)if N<K and ar>0.005 then M=true;s:setThrottleCommand(axisCommandId.longitudinal,r(N,0.01,1))else M=false;s:setThrottleCommand(axisCommandId.longitudinal,K)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(br:len()-b7/3.6)local ps=r(brakePID:get(),0,1)if ar>0 and bu<-80 or ar>0.005 then L=ps end;if L>0 then if M and N==0.01 then s:setThrottleCommand(axisCommandId.longitudinal,0)end else N=r(N,0.01,1)end;local pt=''local pu=vec3()local pv=oS(axisCommandId.vertical,af*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",pv,po)local pw='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then pw=pw..ExtraLongitudeTags end;local px=s:getAxisCommandType(axisCommandId.longitudinal)local py=s:composeAxisAccelerationFromThrottle(pw,axisCommandId.longitudinal)local pz=p3(axisCommandId.lateral,LeftAmount*1000)pt=pt..' , '.."lateral airfoil , lateral ground "pu=pu+pz;if pu:len()>constants.epsilon then a:setEngineForceCommand(pt,pu,po,'','','',pp)end;a:setEngineForceCommand(pw,py,pn)local pA='thrust analog vertical fueled 'local pB='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then pB=pB..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then pA=pA..ExtraVerticalTags end;if af~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(pA,pv,pn)else a:setEngineForceCommand(pA,vec3(),pn)end;if LeftAmount~=0 then a:setEngineForceCommand(pB,pz,pn)else a:setEngineForceCommand(pB,vec3(),pn)end;if pa==0 then pa=L end;local pC=-pa*(brakeSpeedFactor*br+brakeFlatFactor*pe)a:setEngineForceCommand('brake',pC)else if AtmoSpeedAssist then s:setThrottleCommand(axisCommandId.longitudinal,K)end;local mn=unit.getAxisCommandValue(0)if not bA then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(br:len()-mn/3.6)local ps=r(brakePID:get(),0,1)pa=r(pa+ps,0,1)end;local pC=-pa*(brakeSpeedFactor*br+brakeFlatFactor*pe)a:setEngineForceCommand('brake',pC)local pt=''local pu=vec3()local pD=false;local pw='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then pw=pw..ExtraLongitudeTags end;local px=s:getAxisCommandType(axisCommandId.longitudinal)if px==axisCommandType.byThrottle then local py=s:composeAxisAccelerationFromThrottle(pw,axisCommandId.longitudinal)a:setEngineForceCommand(pw,py,pn)elseif px==axisCommandType.byTargetSpeed then local py=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)pt=pt..' , '..pw;pu=pu+py;if s:getTargetSpeed(axisCommandId.longitudinal)==0 or s:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-s:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then pD=true end end;local pB='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then pB=pB..ExtraLateralTags end;local pE=s:getAxisCommandType(axisCommandId.lateral)if pE==axisCommandType.byThrottle then local pF=s:composeAxisAccelerationFromThrottle(pB,axisCommandId.lateral)a:setEngineForceCommand(pB,pF,pn)elseif pE==axisCommandType.byTargetSpeed then local pz=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)pt=pt..' , '..pB;pu=pu+pz end;local pA='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then pA=pA..ExtraVerticalTags end;local pG=s:getAxisCommandType(axisCommandId.vertical)if pG==axisCommandType.byThrottle then local pv=s:composeAxisAccelerationFromThrottle(pA,axisCommandId.vertical)if af~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(pA,pv,pn,'airfoil','ground','',pp)else a:setEngineForceCommand(pA,vec3(),pn)a:setEngineForceCommand('airfoil vertical',pv,pn,'airfoil','','',pp)a:setEngineForceCommand('ground vertical',pv,pn,'ground','','',pp)end elseif pG==axisCommandType.byTargetSpeed then if af<0 then a:setEngineForceCommand('hover',vec3(),pn)end;local pH=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)pt=pt..' , '..pA;pu=pu+pH end;if pu:len()>constants.epsilon then if Y~=0 or pD or d(pe:dot(bo))<0.5 then pt=pt..', brake'end;a:setEngineForceCommand(pt,pu,po,'','','',pp)end end;local pI=torqueFactor*(pi-ph)local pJ=vec3(core.getWorldAirFrictionAngularAcceleration())pI=pI-pJ;a:setEngineTorqueCommand('torque',pI,pn,'airfoil','','',pp)a:setBoosterCommand('rocket_engine')if a7 and not VanillaRockets then local eI=bq:len()local pK=0.15;if not bA then local pL=s:getTargetSpeed(axisCommandId.longitudinal)if eI*3.6>pL*(1-pK)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eI*3.6<pL*(1-pK)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local md=unit.getThrottle()if AtmoSpeedAssist then md=K*100 end;local mn=md/100;if k==0 then mn=mn*MaxGameVelocity;if eI>=mn*(1-pK)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eI<mn*(1-pK)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local my=e(b7)mn=mn*my/3.6;if eI>=mn*(1-pK)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eI<mn*(1-pK)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local gh=coroutine.status(beginSetup)if gh=="suspended"then local cs,gi=coroutine.resume(beginSetup)if gi then system.print("ERROR STARTUP: "..gi)end elseif gh=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not aZ and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(pM)local function pN(b_)local D=1;local function pO(pP,b_)local pQ={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local pR=pP;for _,cV in ipairs(pQ)do if b_ and pR>cV then pP=cV elseif pP<cV and not b_ then pP=cV;break end end;return pP end;if b_ then D=-1 end;if not ExternalAGG and by then if a1 and b_ then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a4;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+D*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a1 then bg=pO(bg,b_)else bg=bg+D*a3 end;if bg<planet.noAtmosphericDensityAltitude then bg=planet.noAtmosphericDensityAltitude end else if a1 and aq then HoldAltitude=pO(HoldAltitude,b_)else HoldAltitude=HoldAltitude+D*a3 end end else s:updateTargetGroundAltitudeFromActionStart(D*1.0)end end;local function pS(pT)if not aq then a2="Flight Assist in Atmo only"return end;local d0=type(pT)if bK==nil then if d0=="table"then if Autopilot or VectorToTarget then cG()end;c8("180On","BR")elseif pT==1 then c8("bnkLft","BR")else c8("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then cD()if d0~="table"then pT=pT+1 end end;bK=pT else c8("180Off","BR")bK=nil end end;if pM=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;cr(0)if vBooster or hover then if aq and ao==-1 then c8("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;b0=true;GearExtended=false else if S then c8("grOut","LG",1)a.control.extendLandingGears()end;s:setTargetGroundAltitude(LandingGearGroundHeight)if aq then BrakeIsOn=true end end end;if S and not BrakeLanding and not(vBooster or hover)then c8("grOut","LG",1)a.control.extendLandingGears()end else if S then c8("grIn","LG",1)a.control.retractLandingGears()end;s:setTargetGroundAltitude(TargetHoverHeight)end elseif pM=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif pM=="forward"then T=T-1 elseif pM=="backward"then if AltIsOn then pS(-br*5000)else T=T+1 end elseif pM=="left"then if AltIsOn then pS(1)else W=W-1 end elseif pM=="right"then if AltIsOn then pS(3)else W=W+1 end elseif pM=="yawright"then X=X-1 elseif pM=="yawleft"then X=X+1 elseif pM=="straferight"then s:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif pM=="strafeleft"then s:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif pM=="up"then af=af+1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif pM=="down"then af=af-1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif pM=="groundaltitudeup"then pN()elseif pM=="groundaltitudedown"then pN(true)elseif pM=="option1"then toggleView=false;if AltIsOn and a1 then local pU=""for i=1,#passengers do pU=pU.."| Name: "..system.getPlayerName(passengers[i]).." Mass: "..A(core.getBoardedPlayerMass(passengers[i])/1000,1).."t "end;system.print("Onboard: "..pU)return end;aW.adjustAutopilotTargetIndex()elseif pM=="option2"then toggleView=false;if AltIsOn and a1 then for i=1,#passengers do core.forceDeboard(passengers[i])end;a2="Deboarded All Passengers"return end;aW.adjustAutopilotTargetIndex(1)elseif pM=="option3"then local function pV()aE=not aE;if not aE then c8("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end;parentingPanelId=system.createWidgetPanel("Docking")parentingWidgetId=system.createWidget(parentingPanelId,"parenting")system.addDataToWidget(unit.getDataId(),parentingWidgetId)coreCombatStressPanelId=system.createWidgetPanel("Core combat stress")coreCombatStressgWidgetId=system.createWidget(coreCombatStressPanelId,"core_stress")system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)if shield_1~=nil then shield_1.show()end else c8("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then t(fuelPanelID)fuelPanelID=nil end;if parentingPanelId~=nil then t(parentingPanelId)parentingPanelId=nil end;if coreCombatStressPanelId~=nil then t(coreCombatStressPanelId)coreCombatStressPanelId=nil end;if spacefuelPanelID~=nil then t(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then t(rocketfuelPanelID)rocketfuelPanelID=nil end;if shield_1~=nil then shield_1.hide()end end end;if AltIsOn and a1 then local pU=""for i=1,#ships do pU=pU.."| ID: "..ships[i].." Mass: "..A(core.getDockedConstructMass(ships[i])/1000,1).."t "end;system.print("Docked Ships: "..pU)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;pV()toggleView=false elseif pM=="option4"then toggleView=false;if AltIsOn and a1 then for i=1,#ships do core.forceUndock(ships[i])end;a2="Undocked all ships"return end;bK=nil;cG()elseif pM=="option5"then toggleView=false;function ToggleLockPitch()if LockPitch==nil then c8("lkPOn","LP")if not a1 then LockPitch=bB else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else c8("lkPOff","LP")LockPitch=nil end end;ToggleLockPitch()elseif pM=="option6"then toggleView=false;if AltIsOn and a1 then if shield_1 then local pW=shield_1.getVentingCooldown()if pW>0 then a2="Cannot vent again for "..pW.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()a2="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else a2="Shields already at max hitpoints"end;return else a2="No shield found"return end end;cD()elseif pM=="option7"then toggleView=false;if AltIsOn and a1 then if shield_1 then shield_1.toggle()return else a2="No shield found"return end end;CollisionSystem=not CollisionSystem;if CollisionSystem then a2="Collision System Enabled"else a2="Collision System Secured"end elseif pM=="option8"then stablized=not stablized;if not stablized then a2="DeCoupled Mode - Ground Stabilization off"s:deactivateGroundEngineAltitudeStabilization()c8("gsOff","GS")else a2="Coupled Mode - Ground Stabilization on"s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)c8("gsOn","GS")end;toggleView=false elseif pM=="option9"then if AltIsOn and a1 then s:resetCommand(axisCommandId.longitudinal)s:resetCommand(axisCommandId.lateral)s:resetCommand(axisCommandId.vertical)cr(0)unit.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ax=gyro.getState()==1;if ax then c8("gyOn","GA")else c8("gyOff","GA")end end;toggleView=false elseif pM=="lshift"then bR=false;if AltIsOn then a1=true end;if x()==1 then a1=true;PrevViewLock=x()w(1)elseif m()==1 and ShiftShowsRemoteButtons then a1=true;a_=false;aZ=false end elseif pM=="brake"then if BrakeToggleStatus or AltIsOn then cI()elseif not BrakeIsOn then cI()else BrakeIsOn=true end elseif pM=="lalt"then toggleView=true;AltIsOn=true;if m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(1)end elseif pM=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a7 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a7=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a7=false end elseif pM=="stopengines"then local function pX()if E-F<1.5 then c8("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bK=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;a0=false;P=false;al=false;am=false;R=false;b0=autoRollPreference;VectorToTarget=false;TurnBurn=false;ax=false;LockPitch=nil;IntoOrbit=false end end;pX()F=E;if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if K~=0 then s:resetCommand(axisCommandId.longitudinal)cr(0)else cr(100)end else if s:getTargetSpeed(axisCommandId.longitudinal)~=0 then s:resetCommand(axisCommandId.longitudinal)else if aq then cu(AtmoSpeedLimit)else cu(MaxGameVelocity*3.6)end end end elseif pM=="speedup"then bZ()elseif pM=="speeddown"then bZ(true)elseif pM=="antigravity"and not ExternalAGG then if antigrav~=nil then cK()end end end;function script.onActionStop(pM)local function pY()if not ExternalAGG and by then a6=a4 end;if AltitudeHold or VertTakeOff or IntoOrbit then a5=a3 end end;if pM=="forward"then T=0 elseif pM=="backward"then T=0 elseif pM=="left"then if bK then if bK==2 then bK=-2 else bK=-1 end end;W=0 elseif pM=="right"then if bK then if bK==4 then bK=-2 else bK=-1 end end;W=0 elseif pM=="yawright"then X=0 elseif pM=="yawleft"then X=0 elseif pM=="straferight"then s:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif pM=="strafeleft"then s:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif pM=="up"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif pM=="down"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif pM=="groundaltitudeup"then pY()toggleView=false elseif pM=="groundaltitudedown"then pY()toggleView=false elseif pM=="lshift"then if x()==1 then ag=0;ah=0;w(PrevViewLock)elseif m()==1 and ShiftShowsRemoteButtons then a_=false;aZ=false end;a1=false elseif pM=="brake"then if not BrakeToggleStatus and not AltIsOn then if BrakeIsOn then cI()else BrakeIsOn=false end end elseif pM=="lalt"then if m()==0 and freeLookToggle then if toggleView then if x()==1 then w(0)else w(1)end else toggleView=true end elseif m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(0)end;AltIsOn=false end end;function script.onActionLoop(pM)local function pZ(b_)local D=1;if b_ then D=-1 end;if not ExternalAGG and by then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a6;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a6=r(a6*1.05,a4,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+D*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bg=bg+D*a5;if bg<planet.noAtmosphericDensityAltitude then bg=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+D*a5 end;a5=r(a5*1.05,a3,50)else s:updateTargetGroundAltitudeFromActionLoop(D*1.0)end end;local function p_(b_)local D=1;if b_ then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then K=r(K+D*speedChangeSmall/100,-1,1)else s:updateCommandFromActionLoop(axisCommandId.longitudinal,D*speedChangeSmall)end end end;if pM=="groundaltitudeup"then if not a1 then pZ()end elseif pM=="groundaltitudedown"then if not a1 then pZ(true)end elseif pM=="speedup"then p_()elseif pM=="speeddown"then p_(true)end end;function script.onInputText(co)local function q0(q1,eM,hU)local function q2(eM)local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local d8='::pos{'..B..','..B..','..B..','..B..','..B..'}'local dl,dm,dt,du,dv=o(eM,d8)if dl=="0"and dm=="0"then return vec3(z(dt),z(du),z(dv))end;du=math.rad(du)dt=math.rad(dt)local planet=b[z(dl)][z(dm)]local ed=math.cos(dt)local q3=vec3(ed*math.cos(du),ed*math.sin(du),math.sin(dt))return planet.center+(planet.radius+dv)*q3 end;local position=q2(eM)return aW.AddNewLocation(q1,position,hU)end;local i;local q4,q5=nil,nil;local q6="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute".."/deletewp - Deletes current selected custom wp"i=string.find(co," ")q4=co;if i~=nil then q4=string.sub(co,0,i-1)q5=string.sub(co,i+1)end;if q4=="/help"or q4=="/commands"then for kA in string.gmatch(q6,"([^\n]+)")do system.print(kA)end;return elseif q4=="/setname"then if q5==nil or q5==""then a2="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then aW.UpdatePosition(q5)else a2="Select a saved target to rename first"end elseif shield_1 and q4=="/resist"then if q5==nil or shield_1.getResistancesCooldown()>0 then a2="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local d8=B..', '..B..', '..B..', '..B;local q7,q8,q9,qa=o(q5,d8)if qa==nil or q7+q8+q9+qa>0.6 then a2="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(q7,q8,q9,qa)==1 then a2="Shield Resistances set"else a2="Resistance setting failed."end elseif q4=="/addlocation"or string.find(co,"::pos")~=nil then local hU=false;local q1="0-Temp"if q5==nil or q5==""then q5=q4;hU=true end;i=string.find(q5,"::")if not hU then q1=string.sub(q5,1,i-2)end;local eM=string.sub(q5,i)q0(q1,eM,hU)elseif q4=="/agg"then if q5==nil or q5==""then a2="Usage: /agg targetheight"return end;q5=z(q5)if q5<1000 then q5=1000 end;AntigravTargetAltitude=q5;a2="AGG Target Height set to "..q5 elseif q4=="/G"then if q5==nil or q5==""then a2="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if q5=="dump"then for cU,cV in pairs(ce())do if type(_G[cV])=="boolean"then if _G[cV]==true then system.print(cV.." true")else system.print(cV.." false")end elseif _G[cV]==nil then system.print(cV.." nil")else system.print(cV.." ".._G[cV])end end;return end;i=string.find(q5," ")local qb=string.sub(q5,0,i-1)local qc=string.sub(q5,i+1)for cU,cV in pairs(ce())do if cV==qb then a2="Variable "..qb.." changed to "..qc;local qd=type(_G[cV])if qd=="number"then qc=z(qc)if cV=="AtmoSpeedLimit"then b7=qc end elseif qd=="boolean"then if string.lower(qc)=="true"then qc=true else qc=false end end;_G[cV]=qc;return end end;a2="No such global variable: "..qb elseif q4=="/deletewp"then if autopilotTargetIndex>0 and CustomTarget~=nil then aW.ClearCurrentPosition()else a2="Select a custom wp to delete first in IPH"end elseif q4=="/copydatabank"then if dbHud_2 then cQ(true)else a2="Spare Databank required to copy databank"end elseif q4=="/iphWP"then if AutopilotTargetIndex>0 then system.print(aX.showWayPoint(ac,AutopilotTargetCoords,true))a2="::pos waypoint shown in lua chat"else a2="No target selected in IPH"end end end;function script.onEnter(dm)if bP[1]and not aq and not bH then unit.setTimer("contact",0.1)end end;function script.onLeave(dm)if bP[1]and CollisionSystem then if#bL>650 then dm=tostring(dm)bL[dm]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
