name: ArchHud - Archaegeo v1.515 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        ShowOdometer = true --export:
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        DisplayOrbit = true --export: 
        SetWaypointOnExit = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        showHelp = true --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        AutoShieldToggle = true --export:
        PreventPvP = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        ReEntryPitch = -30 --export:
        LockPitchTarget = 0 --export:
        AutopilotSpaceDistance = 5000 --export:
        TargetOrbitRadius = 1.2 --export:
        LowOrbitHeight = 2000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 100000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        WipeDamage = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        shieldX = 1750 --export:
        shieldY = 250 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 75 --export:
        OrbitMapY = 0 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)local b=require("atlas")script={}VERSION_NUMBER=1.515;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;iphCondition="All"stablized=true;UseExtra="Off"LastVersionUpdate=0.000;local c={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","iphCondition","stablized","UseExtra","SelectedTab","scopeFOV"}local d=math.abs;local e=math.floor;local f=string.format;local g=json.decode;local h=json.encode;local j=core.getElementMaxHitPointsById;local k=unit.getAtmosphereDensity;local l=core.getElementMassById;local m=a.control.isRemoteControlled;local n=math.atan;local o=string.match;local q=system.getTime;local vec3=vec3;local r=utils.clamp;local s=a.axisCommandManager;local t=system.destroyWidgetPanel;local u=system.updateData;local v=system.addDataToWidget;local w=system.lockView;local x=system.isViewLocked;local y=math.sqrt;local z=tonumber;local core=core;local function A(B,C)local D=10^(C or 0)return e(B*D+0.5)/D end;local E=q()local F=q()local G=13;local H=SafeR;local I=SafeB;local J=SafeG;local K=0;local L=0;local M=false;local N=0;local O=false;local P=false;local Q=55;local R=false;local S=false;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=0;local a0=false;local a1=false;local a2="empty"local a3=5;local a4=5;local a5=a3;local a6=a4;local a7=false;local a8=0;local a9=0;local aa=0;local ab=0;local ac=nil;local ad=0;local ae=0;local af=0;local ag=0;local ah=0;local ai=3;local aj=0;local ak=""local al=false;local am=false;local an=false;local ao=-1;local ap=""local aq=k()>0;local ar=k()local as=core.getAltitude()local at=core.getElementIdList()local au=q()local av=core.getConstructMass()local aw=false;local ax=nil;local ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]local az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]local aA={}local aB=0;local aC=0;local aD=""local aE=true;local aF={}local aG=ResolutionX;local aH=ResolutionY;local aI={}local aJ={}local aK={}local aL=0;local aM=false;local aN=nil;local aO=nil;local aP=nil;local aQ=nil;local aR=nil;local aS=nil;local aT=nil;local aU=nil;local aV=nil;local aW=nil;local aX=nil;local aY=nil;local aZ=false;local a_=false;local b0=autoRollPreference;local b1=LandingGearGroundHeight;local b2=false;local b3=q()local b4=0;local b5=0;local b6=0;local b7=AtmoSpeedLimit;local b8=0;local b9=nil;local ba=0;local bb=0;local bc=false;local bd=false;local be={VectorToTarget=false}local bf=false;local bg=0;local bh=nil;local bi=false;local bj=false;local bk=false;local bl=false;local bm=0;local bn=vec3(core.getConstructWorldOrientationUp())local bo=vec3(core.getConstructWorldOrientationForward())local bp=vec3(core.getConstructWorldOrientationRight())local bq=vec3(core.getVelocity())local br=vec3(core.getWorldVelocity())local bs=vec3(br):len()local bt=vec3(core.getWorldVertical())local bu=-bt:dot(br)local bv=vec3(core.getConstructWorldPos())local bw=0;local bx=false;local by=false;local bz=nil;local bA=true;local bB=0;local bC=0;local bD=false;local bE={}local bF=showHud;local bG={}local bH=false;local bI=50000;local bJ=""local bK=nil;local bL={}local bM=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local bN=false;local bO=nil;local bP={}local bQ="Atmo"local bR=false;local bS=0;local bT={}local bU={}scopeFOV=90;function p(bV)system.print(E..": "..bV)end;local function bW(bX,bY,bZ)bY=bY:project_on_plane(bX)bZ=bZ:project_on_plane(bX)return n(bY:cross(bZ):dot(bX),bY:dot(bZ))end;local function b_(c0)local D=1;if c0 then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn and aw then local c1=K;K=A(r(K+D*speedChangeLarge/100,-1,1),2)if K>=0 and c1<0 then K=0;aw=false end elseif AltIsOn then if ar>0 or Reentry then b7=r(b7+D*speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity+D*speedChangeLarge/3.6*100,0,8333.00)end else s:updateCommandFromActionStart(axisCommandId.longitudinal,D*speedChangeLarge)end else if Autopilot or VectorToTarget or am or IntoOrbit then bS=bS+1*D*-1;if bS>#bG then bS=1 end;if bS<1 then bS=#bG end else if not c0 then D=1 else D=nil end;aW.adjustAutopilotTargetIndex(D)end end end;local function c2(c3)local c4,c5,c6=aR:getPlanetarySystem(0):castIntersections(bv,c3,function(c7)if c7.noAtmosphericDensityAltitude>0 then return c7.radius+c7.noAtmosphericDensityAltitude else return c7.radius+c7.surfaceMaxAltitude*1.5 end end)local c8=c5;if c6~=nil and c5~=nil then c8=math.min(c6,c5)end;if c8~=nil then return c4,c8 else return nil,nil end end;local function c9(ca,cb,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..ca.."|"..cb.."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..ca.."|"..cb.."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..ca.."|"..cb.."|"..soundVolume)end end;local function cc(cd,ce)for i=1,#ce do cd[#cd+1]=ce[i]end;return cd end;local function cf(cg)local ch={}local ci={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit","AlwaysVSpd","BarFuelDisplay","showHelp","voices","alerts","CollisionSystem","AutoShieldToggle","PreventPvP"}local cj={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","ReEntryPitch","LockPitchTarget","AutopilotSpaceDistance","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization","WipeDamage"}local ck={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","shieldX","shieldY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local cl={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not cg then cc(ch,ci)cc(ch,cj)cc(ch,ck)cc(ch,cl)return ch elseif cg=="boolean"then return ci elseif cg=="handling"then return cj elseif cg=="hud"then return ck elseif cg=="physics"then return cl end end;local function cm(cn,co,cp,cq,cr)if cq==nil then cq=""end;if cr==nil then cr=""end;return f([[<text class="%s" x=%s y=%s style="%s">%s</text>]],cq,cn,co,cr,cp)end;local function cs(ct,cu)if s:getAxisCommandType(0)~=axisCommandType.byThrottle and not cu then a.control.cancelCurrentControlMasterMode()end;s:setThrottleCommand(axisCommandId.longitudinal,ct)K=r(A(ct*100,0)/100,-1,1)bz=nil end;local function cv(ct,cu)if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not cu then a.control.cancelCurrentControlMasterMode()end;s:setTargetSpeedCommand(axisCommandId.longitudinal,ct)bz=ct end;local function cw(cx,cy)if cx==0 then return d(cy)<1e-09 end;if cy==0 then return d(cx)<1e-09 end;return d(cx-cy)<math.max(d(cx),d(cy))*epsilon end;local function cz(aj,cA)local cB=aj>100000;if cA==nil then cA=1 end;if cB then return A(aj/1000/200,cA).."SU"elseif aj<1000 then return A(aj,cA).."M"else return A(aj/1000,cA).."KM"end end;local function cC()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;b0=true;af=0;if aq and ao==-1 then BrakeLanding=false;AltitudeHold=true;af=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cv(e(b7))end else bi=false;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;local function cD()bi=false;ba=nil;bb=nil;bm=0;if ar==0 then if IntoOrbit then c9("orOff","AP")IntoOrbit=false;bc=false;bh=nil;b0=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;be.VectorToTarget=false;be.AutopilotAlign=false;bf=false elseif bM then c9("orOn","AP")IntoOrbit=true;b0=true;if bh==nil then bh=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a2="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;bc=false;bh=nil;b0=autoRollPreference;if AltitudeHold then AltitudeHold=false end;be.VectorToTarget=false;be.AutopilotAlign=false;bf=false end end;local function cE()if E-b5<1.5 then if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;c9("11","EP")else if bM then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bg=HoldAltitude;bf=true;if not IntoOrbit then cD()end;bc=true end end;b5=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else b5=E end;if bM and ar==0 then bg=as;bf=true;bc=true;cD()if IntoOrbit then b5=E else b5=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;a0=false;b0=true;LockPitch=nil;bi=false;if ao~=-1 and bs<20 then c9("lfs","LS")AutoTakeoff=true;if b5>-1 then HoldAltitude=as+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;s:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bx then cC()end else c9("altOn","AH")AutoTakeoff=false;if b5>-1 then if bM then HoldAltitude=as end end;if VertTakeOff then cC()end end;if am then HoldAltitude=100000 end else c9("altOff","AH")if IntoOrbit then cD()end;if VertTakeOff then cC()end;b0=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;b5=0 end end;local function cF(cG)if cG then am=false;Autopilot=false;AutopilotRealigned=false;P=false;HoldAltitude=as;TargetSet=false end;VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bK=nil;if not by then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then cC()end;if IntoOrbit then cD()end;b0=autoRollPreference;al=false;an=false;af=0 end;local function cH()local function cI(SpaceTarget)bN=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cE()end end;VectorStatus="Proceeding to Waypoint"end;if E-b6<1.5 and ar>0 then if not bl then a2="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;c9("orH","OH")end;b6=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else b6=E end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not am and not IntoOrbit then if 0.5*a:maxForceForward()/core.g()<av then a2="WARNING: Heavy Loads may affect autopilot performance."ai=5 end;aW.UpdateAutopilotTarget()aX.showWayPoint(ac,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then c9("apSpc","AP")if ar~=0 then am=true;cE()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if ar>0 then if not VectorToTarget then c9("vtt","AP")cI(SpaceTarget)end else c9("apOn","AP")if not(ac.name==planet.name and as<AutopilotTargetOrbit*1.5)then bi=false;Autopilot=true elseif not aq then if IntoOrbit then cD()end;bg=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bf=true;be.AutopilotAlign=true;be.VectorToTarget=true;bc=false;if not IntoOrbit then cD()end end end else c9("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if ar~=0 then am=true;cE()else Autopilot=true end end elseif ar==0 then if CustomTarget==nil and(ac.name==planet.name and bM)and not IntoOrbit then WaypointSet=false;bi=false;bc=false;cD()else c9("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;a0=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;P=false;LockPitch=nil;WaypointSet=false end else c9("apP","AP")am=true;cE()end else c9("apOff","AP")cF(1)end end;local function cJ()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;b0=autoRollPreference end;if BrakeIsOn then c9("bkOn","B",1)cF()else c9("bkOff","B",1)end end;local function cK()if Reentry then a2="Re-Entry cancelled"c9("reOff","RE")Reentry=false;b0=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a2="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ai=5 elseif not R then Reentry=true;if s:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;b0=true;BrakeIsOn=false;a2="Beginning Parachute Re-Entry - Strap In.  Target speed: "..b7;c9("par","RE")else Reentry=true;AltitudeHold=true;b0=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local cp=cz(HoldAltitude)a2="Beginning Re-entry.  Target speed: "..b7 .." Target Altitude: "..cp;c9("glide","RE")cv(e(b7))end;AutoTakeoff=false end;local function cL()if antigrav and not ExternalAGG then if by then c9("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;c9("aggOn","AG")antigrav.activate()antigrav.show()end end end;local function cM(cN)local cO=0;local cP=0;local cQ=0;if cN<60 then cN=e(cN)elseif cN<3600 then cO=e(cN/60)cN=e(cN%60)elseif cN<86400 then cP=e(cN/3600)cO=e(cN%3600/60)else cQ=e(cN/86400)cP=e(cN%86400/3600)end;if cQ>0 then return cQ.."d "..cP.."h "elseif cP>0 then return cP.."h "..cO.."m "elseif cO>0 then return cO.."m "..cN.."s"elseif cN>0 then return cN.."s"else return"0s"end end;local function cR(cS)local function cT(cU)for cV,cW in pairs(cU)do dbHud_1.setStringValue(cW,h(_G[cW]))if cS and dbHud_2 then dbHud_2.setStringValue(cW,h(_G[cW]))end end end;if dbHud_1 then cT(c)cT(cf())system.print("Saved Variables to Datacore")if cS and dbHud_2 then a2="Databank copied.  Remove copy when ready."end end end;local function cX()local function cY(cZ)return type(cZ)=='number'end;local function c_(cZ)return type(z(cZ))=='number'end;local function d0(d1)return type(d1)=='table'end;local function d2(d3)return type(d3)=='string'end;local function d4(cW)return d0(cW)and cY(cW.x and cW.y and cW.z)end;local function d5(d6)return d0(d6)and cY(d6.latitude and d6.longitude and d6.altitude and d6.id and d6.systemId)end;local d7=math.pi/180;local d8=180/math.pi;local epsilon=1e-10;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local d9='::pos{'..B..','..B..','..B..','..B..','..B..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function da(cZ)local db=string.gsub(string.reverse(f('%.4f',cZ)),'^0*%.?','')return db==''and'0'or string.reverse(db)end;local function dc(dd)if d4(dd)then return f('{x=%.3f,y=%.3f,z=%.3f}',dd.x,dd.y,dd.z)end;if d0(dd)and not getmetatable(dd)then local de={}local df=next(dd)if type(df)=='nil'or df==1 then de=dd else for cV,cW in pairs(dd)do local ct=dc(cW)if type(cV)=='number'then table.insert(de,f('[%s]=%s',cV,ct))else table.insert(de,f('%s=%s',cV,ct))end end end;return f('{%s}',table.concat(de,','))end;if d2(dd)then return f("'%s'",dd:gsub("'",[[\']]))end;return tostring(dd)end;local dg={}dg.__index=dg;dg.__tostring=function(dd,dh)local di={}for cV in pairs(dd)do table.insert(di,cV)end;table.sort(di)local de={}for _,cV in ipairs(di)do local ct=dc(dd[cV])if type(cV)=='number'then table.insert(de,f('[%s]=%s',cV,ct))else table.insert(de,f('%s=%s',cV,ct))end end;if dh then return f('%s%s',dh,table.concat(de,',\n'..dh))end;return f('{%s}',table.concat(de,','))end;dg.__eq=function(dj,dk)return dj.systemId==dk.systemId and dj.id==dk.id and cw(dj.radius,dk.radius)and cw(dj.center.x,dk.center.x)and cw(dj.center.y,dk.center.y)and cw(dj.center.z,dk.center.z)and cw(dj.GM,dk.GM)end;local function dl(dm,dn,dp,dq,dr)assert(c_(dm),'Argument 1 (systemId) must be a number:'..type(dm))assert(c_(dn),'Argument 2 (id) must be a number:'..type(dn))assert(c_(dp),'Argument 3 (radius) must be a number:'..type(dp))assert(d0(dq),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dq))assert(c_(dr),'Argument 5 (GM) must be a number:'..type(dr))return setmetatable({systemId=z(dm),id=z(dn),radius=z(dp),center=vec3(dq),GM=z(dr)},dg)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(p)return f('::pos{%d,%d,%s,%s,%s}',p.systemId,p.id,da(p.latitude*d8),da(p.longitude*d8),da(p.altitude))end;MapPosition.__eq=function(dj,dk)return dj.id==dk.id and dj.systemId==dk.systemId and cw(dj.latitude,dk.latitude)and cw(dj.altitude,dk.altitude)and(cw(dj.longitude,dk.longitude)or cw(dj.latitude,math.pi/2)or cw(dj.latitude,-math.pi/2))end;local function ds(dt,dn,du,dv,dw)local dm=dt;if d2(dt)and not dv and not dw and not dn and not du then dm,dn,du,dv,dw=o(dt,d9)assert(dm,'Argument 1 (position string) is malformed.')else assert(c_(dm),'Argument 1 (systemId) must be a number:'..type(dm))assert(c_(dn),'Argument 2 (id) must be a number:'..type(dn))assert(c_(du),'Argument 3 (latitude) must be in degrees:'..type(du))assert(c_(dv),'Argument 4 (longitude) must be in degrees:'..type(dv))assert(c_(dw),'Argument 5 (altitude) must be in meters:'..type(dw))end;dm=z(dm)dn=z(dn)du=z(du)dv=z(dv)dw=z(dw)if dn==0 then return setmetatable({latitude=du,longitude=dv,altitude=dw,id=dn,systemId=dm},MapPosition)end;return setmetatable({latitude=d7*r(du,-90,90),longitude=d7*(dv%360),altitude=dw,id=dn,systemId=dm},MapPosition)end;local dx={}dx.__index=dx;dx.__tostring=function(dd,dh)local dy=dh and dh..'  'local dz={}local di={}for cV in pairs(dd)do table.insert(di,cV)end;table.sort(di)for _,dA in ipairs(di)do bdy=dd[dA]local dB=dg.__tostring(bdy,dy)if dh then table.insert(dz,f('[%s]={\n%s\n%s}',dA,dB,dh))else table.insert(dz,f('  [%s]=%s',dA,dB))end end;if dh then return f('\n%s%s%s',dh,table.concat(dz,',\n'..dh),dh)end;return f('{\n%s\n}',table.concat(dz,',\n'))end;local function dC(dD)local b={}local pid;for _,cW in pairs(dD)do local dn=cW.planetarySystemId;if type(dn)~='number'then error('Invalid planetary system ID: '..tostring(dn))elseif pid and dn~=pid then error('Mistringmatch planetary system IDs: '..dn..' and '..pid)end;local dE=cW.bodyId;if type(dE)~='number'then error('Invalid body ID: '..tostring(dE))elseif b[dE]then error('Duplicate body ID: '..tostring(dE))end;setmetatable(cW.center,getmetatable(vec3.unit_x))b[dE]=setmetatable(cW,dg)pid=dn end;return setmetatable(b,dx)end;aQ={}local function dF(dD)return setmetatable({galaxyAtlas=dD or{}},aQ)end;aQ.__index=function(d1,i)if type(i)=='number'then local system=d1.galaxyAtlas[i]return dC(system)end;return rawget(aQ,i)end;aQ.__pairs=function(dd)return function(d1,cV)local dG,nv=next(d1,cV)return dG,nv and dC(nv)end,dd.galaxyAtlas,nil end;aQ.__tostring=function(dd)local dH={}for _,dI in pairs(dd or{})do local dJ=dI:getPlanetarySystemId()local dK=dx.__tostring(dI,'    ')table.insert(dH,f('  [%s]={%s\n  }',dJ,dK))end;return f('{\n%s\n}\n',table.concat(dH,',\n'))end;aQ.BodyParameters=dl;aQ.MapPosition=ds;aQ.PlanetarySystem=dC;function aQ.createBodyParameters(dm,dn,dL,dM,dN,dO,dP)assert(c_(dm),'Argument 1 (systemId) must be a number:'..type(dm))assert(c_(dn),'Argument 2 (id) must be a number:'..type(dn))assert(c_(dL),'Argument 3 (surfaceArea) must be a number:'..type(dL))assert(d0(dM),'Argument 4 (aPosition) must be an array or vec3:'..type(dM))assert(d0(dN),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(dN))assert(c_(dO),'Argument 6 (altitude) must be in meters:'..type(dO))assert(c_(dP),'Argument 7 (gravityAtPosition) must be number:'..type(dP))local dp=y(dL/4/math.pi)local aj=dp+dO;local dQ=vec3(dM)+aj*vec3(dN)local dr=dP*aj*aj;return dl(dm,dn,dp,dQ,dr)end;aQ.isMapPosition=d5;function aQ:getPlanetarySystem(dt)if i==nil then i=0 end;if nv==nil then nv=0 end;local dm=dt;if d5(dt)then dm=dt.systemId end;if type(dm)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=dx then system=dC(system)end;return system end end end;function dx:sizeCalculator(c7)return 1.05*c7.radius end;function dx:castIntersections(dR,dS,dT,dU,dV,dW)local dX={}local dY=dV or self;for _,c7 in pairs(dY)do table.insert(dX,c7)end;if not dW then table.sort(dX,function(dZ,d_)return(dZ.center-dR):len()<(d_.center-dR):len()end)end;local e0=dS:normalize()for _,c7 in ipairs(dX)do local e1=c7.center-dR;local dp=self:sizeCalculator(c7)local e2=e1:dot(e0)local e3=e2^2-(e1:len2()-dp^2)if e3>=0 then local e4=y(e3)local c5=e2+e4;local c6=e2-e4;if c6>0 then return c7,c5,c6 elseif c5>0 then return c7,c5,nil end end end;return nil,nil,nil end;function dx:closestBody(e5)assert(type(e5)=='table','Invalid coordinates.')local e6,c7;local e7=vec3(e5)for _,e8 in pairs(self)do local e9=(e8.center-e7):len2()if(not c7 or e9<e6)and e8.name~="Space"then c7=e8;e6=e9 end end;return c7 end;function dx:convertToBodyIdAndWorldCoordinates(dt)local ea=dt;if d2(dt)then ea=ds(dt)end;if ea.id==0 then return 0,vec3(ea.latitude,ea.longitude,ea.altitude)end;local e8=self:getBodyParameters(ea)if e8 then return ea.id,e8:convertToWorldCoordinates(ea)end end;function dx:getBodyParameters(dt)local dn=dt;if d5(dt)then dn=dt.id end;assert(c_(dn),'Argument 1 (id) must be a number:'..type(dn))return self[dn]end;function dx:getPlanetarySystemId()local _,cW=next(self)return cW and cW.systemId end;function dg:convertToMapPosition(dq)assert(d0(dq),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dq))local eb=vec3(dq)if self.id==0 then return setmetatable({latitude=eb.x,longitude=eb.y,altitude=eb.z,id=0,systemId=self.systemId},MapPosition)end;local ec=eb-self.center;local aj=ec:len()local dw=aj-self.radius;local du=0;local dv=0;if not cw(aj,0)then local ed=n(ec.y,ec.x)dv=ed>=0 and ed or 2*math.pi+ed;du=math.pi/2-math.acos(ec.z/aj)end;return setmetatable({latitude=du,longitude=dv,altitude=dw,id=self.id,systemId=self.systemId},MapPosition)end;function dg:convertToWorldCoordinates(dt)local ea=d2(dt)and ds(dt)or dt;if ea.id==0 then return vec3(ea.latitude,ea.longitude,ea.altitude)end;assert(d5(ea),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(ea.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(ea.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local ee=math.cos(ea.latitude)return self.center+(self.radius+ea.altitude)*vec3(ee*math.cos(ea.longitude),ee*math.sin(ea.longitude),math.sin(ea.latitude))end;function dg:getAltitude(dq)return(vec3(dq)-self.center):len()-self.radius end;function dg:getDistance(dq)return(vec3(dq)-self.center):len()end;function dg:getGravity(dq)local ef=self.center-vec3(dq)local eg=ef:len2()return self.GM/eg*ef/y(eg)end;return setmetatable(aQ,{__call=function(_,...)return dF(...)end})end;local function eh()local aS={}local ei=30000000/3600;local ej=ei*ei;local ek=100;function aS.computeAccelerationTime(el,em,en)local eo=ei*math.asin(el/ei)return(ei*math.asin(en/ei)-eo)/em end;function aS.computeDistanceAndTime(el,en,ep,eq,er,es)er=er or 0;es=es or 0;local et=el<=en;local eu=eq*(et and 1 or-1)/ep;local ev=-es/ep;local ew=eu+ev;if et and ew<=0 or not et and ew>=0 then return-1,-1 end;local ex,ey=0,0;if eu~=0 and er>0 then local eo=math.asin(el/ei)local ez=math.pi*(eu/2+ev)local eA=eu*er;local eB=ei*math.pi;local cW=function(d1)local eC=(ez*d1-eA*math.sin(math.pi*d1/2/er)+eB*eo)/eB;local eD=math.tan(eC)return ei*eD/y(eD*eD+1)end;local eE=et and function(d3)return d3>=en end or function(d3)return d3<=en end;ey=2*er;if eE(cW(ey))then local eF=0;while d(ey-eF)>0.5 do local d1=(ey+eF)/2;if eE(cW(d1))then ey=d1 else eF=d1 end end end;local eG=el;local eH=ey/ek;for eI=1,ek do local eJ=cW(eI*eH)ex=ex+(eJ+eG)*eH/2;eG=eJ end;if ey<2*er then return ex,ey end;el=eG end;local eo=ei*math.asin(el/ei)local E=(ei*math.asin(en/ei)-eo)/ew;local eK=ej*math.cos(eo/ei)/ew;local aj=eK-ej*math.cos((ew*E+eo)/ei)/ew;return aj+ex,E+ey end;function aS.computeTravelTime(el,em,aj)if aj==0 then return 0 end;if em>0 then local eo=ei*math.asin(el/ei)local eK=ej*math.cos(eo/ei)/em;return(ei*math.acos(em*(eK-aj)/ej)-eo)/em end;if el==0 then return-1 end;assert(el>0,'Acceleration and initial speed are both zero.')return aj/el end;return aS end;local function eL()local vec3=require('cpml.vec3')local cX=cX()local function d2(d3)return type(d3)=='string'end;local function d0(d1)return type(d1)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(dw)assert(self.body)local aj=dw+self.body.radius;if not cw(aj,0)then local orbit=y(self.body.GM/aj)return y(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(dt,eM)assert(self.body)assert(d0(dt)or d2(dt))assert(d0(eM))local eN=(d2(dt)or cX.isMapPosition(dt))and self.body:convertToWorldCoordinates(dt)or vec3(dt)local cW=vec3(eM)local eO=eN-self.body.center;local eP=cW:len2()local eQ=eO:len()local eR=self.body.GM;local eS=((eP-eR/eQ)*eO-eO:dot(cW)*cW)/eR;local cx=eR/(2*eR/eQ-eP)local eT=eS:len()local e0=eS:normalize()local eU=cx*(1-eT)local eV=cx*(1+eT)local eW=eU*e0+self.body.center;local eX=eT<=1 and-eV*e0+self.body.center or nil;local eY=y(cx*eR*(1-eT*eT))local eZ=eX and 2*math.pi*y(cx^3/eR)local e_=math.acos(eS:dot(eO)/(eT*eQ))if eO:dot(cW)<0 then e_=-(e_-2*math.pi)end;local f0=math.acos((math.cos(e_)+eT)/(1+eT*math.cos(e_)))local f1=f0;if f1<0 then f1=f1+2*math.pi end;local f2=f1-eT*math.sin(f1)local f3=0;local f4=0;local f5=0;if eZ~=nil then f3=f2/(2*math.pi/eZ)f4=eZ-f3;f5=f4+eZ/2;if e_-math.pi>0 then f4=f3;f5=f4+eZ/2 end;if f5>eZ then f5=f5-eZ end end;return{periapsis={position=eW,speed=eY/eU,circularOrbitSpeed=y(eR/eU),altitude=eU-self.body.radius},apoapsis=eX and{position=eX,speed=eY/eV,circularOrbitSpeed=y(eR/eV),altitude=eV-self.body.radius},currentVelocity=cW,currentPosition=eN,eccentricity=eT,period=eZ,eccentricAnomaly=f0,meanAnomaly=f2,timeToPeriapsis=f4,timeToApoapsis=f5,trueAnomaly=e_}end;local function f6(f7)local e8=cX.BodyParameters(f7.systemId,f7.id,f7.radius,f7.center,f7.GM)return setmetatable({body=e8},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return f6(...)end})end;local function f8()local f9={}local fa={}local fb={XS=13,S=27,M=55,L=110,XL=221}local fc={}local fd;local fe;local ff;local fg;local fh;local function fi()local function fj(fk,fl,fm,fn,fo,fp,fq,fr)fl,fn,fp,fr=vec3(fl),vec3(fn),vec3(fp),vec3(fr)local fs,ft,fu=fk*fk,fm*fm,fo*fo;local eP=fn-fl;local fv=eP:normalize()local fw=eP:len()local fx=fp-fl;local fy=(fx-fx:project_on(fv)):normalize()local fz,fA=fx:dot(fv),fx:dot(fy)local fB=fz*fz+fA*fA;local fC=fv:cross(fy)local cn=(fs-ft+fw*fw)/(2*fw)local co=(fs-fu+fB-2*fz*cn)/(2*fA)local d6=fs-cn^2-co^2;local fD=y(d6)local fE=fl+fv*cn+fy*co+fC*fD;local fF=fl+fv*cn+fy*co-fC*fD;if d((fr-fE):len()-fq)<d((fr-fF):len()-fq)then return fE else return fF end end;local function fG()local function fH()local fI=core.getConstructWorldOrientationRight()local eP=core.getConstructWorldOrientationForward()local fx=core.getConstructWorldOrientationUp()local fJ=library.systemResolution3(fI,eP,fx,{1,0,0})local fK=library.systemResolution3(fI,eP,fx,{0,1,0})local fL=library.systemResolution3(fI,eP,fx,{0,0,1})return function(fM)return library.systemResolution3(fJ,fK,fL,fM)end end;local fN=fH()local fO=core.getConstructWorldPos()local eN=core.getElementPositionById(1)local fP={eN[1],eN[2],eN[3]}local fQ=fN(fP)local fR={fO[1]-fQ[1],fO[2]-fQ[2],fO[3]-fQ[3]}return fR end;local function fS(fT,eQ,fU)local fV=fT.pts;local fW=#fV;local fX=fT.ref;if fW>3 then local fY,fZ,f_,g0=fV[fW],fV[fW-1],fV[fW-2],fV[fW-3]fT.ref=fU;local eN=fj(fY[1],fY[2],fZ[1],fZ[2],f_[1],f_[2],g0[1],g0[2])local cn,co,fD=eN.x,eN.y,eN.z;if cn==cn and co==co and fD==fD then cn=cn+fX[1]co=co+fX[2]fD=fD+fX[3]local g1=vec3(cn,co,fD)if not fT.lastPos then fT.center=g1 elseif(fT.lastPos-g1):len()<2 then fT.center=g1;fT.skipCalc=true end;fT.lastPos=g1 end;fT.pts={}else local g2={fU[1]-fX[1],fU[2]-fX[2],fU[3]-fX[3]}fV[fW+1]={eQ,g2}end end;if bP[1]then fd=#bP[1].getConstructIds()local g3=bP[1].getData()local g4=g3:gmatch('{"constructId[^}]*}[^}]*}')if fd>0 then local fU=fG()local g5,g6=0,0;fh,fg=0,0;for cW in g4 do local dn,aj,g7=cW:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local g8=fb[g7]aj=z(aj)if bP[1].hasMatchingTransponder(dn)==1 then table.insert(fa,dn)end;local g9=bP[1].getConstructType(dn)if CollisionSystem then if g8>27 or g9=="static"or g9=="space"then fh=fh+1;local ga=bP[1].getConstructName(dn)local fT=bL[dn]if fT==nil then g8=g8+G;bL[dn]={pts={},ref=fU,name=ga,i=0,radius=g8,skipCalc=false}fT=bL[dn]end;if not fT.skipCalc then fS(fT,aj,fU)g6=g6+1 end;if fT.center then table.insert(fc,fT)end end;g5=g5+1;if bM and g5>700 or g6>70 or(not bM and g5>300 or g6>30)then coroutine.yield()g5,g6=0,0 end end end;fg=#fc;if fg>0 and bs>20 then local c7,gb,gc,gd;local ge=0;local gf=aR:getPlanetarySystem(0)gd=br:normalize()while ge<fg do coroutine.yield()local gg={table.unpack(fc,ge,math.min(ge+75,fg))}c7,gb,gc=gf:castIntersections(bv,gd,nil,nil,gg,true)if c7 and gc then bO={c7,gb,gc}break end;ge=ge+75 end;if not c7 then bO=nil end else bO=nil end;fc={}fe=g3:find('identifiedConstructs":%[%]')else ff=g3:find('worksInEnvironment":false')end end end;local function gh()if bP[1]then bQ="Atmo"if bP[1].getData():find('worksInAtmosphere":false')then bQ="Space"end end end;function f9.pickType()gh()end;function f9.assignRadar()if radar_1 and bP[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then bP[1]=radar_2 end;if bP[1]==radar_2 then gh()end elseif radar_2 and bP[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then bP[1]=radar_1 end;if bP[1]==radar_1 then gh()end end end;function f9.UpdateRadar()local gi=coroutine.status(UpdateRadarCoroutine)if gi=="suspended"then local ct,gj=coroutine.resume(UpdateRadarCoroutine)if gj then system.print("ERROR UPDATE RADAR: "..gj)end elseif gi=="dead"then UpdateRadarCoroutine=coroutine.create(fi)local ct,gj=coroutine.resume(UpdateRadarCoroutine)end end;function f9.GetRadarHud()local gk=fa;fa={}return fe,ff,fd,fg,fh,gk end;UpdateRadarCoroutine=coroutine.create(fi)return f9 end;local function gl(cW)if aG==1920 then return cW else return A(aG*cW/1920,0)end end;local function gm(cW)if aH==1080 then return cW else return A(aH*cW/1080,0)end end;local function gn()local go=9.80665;local gp=vec3({13771471,7435803,-128971})local gq=18000000;local gr=500000;local gs,gt=math.huge;local gu;local function gv(gw)gs=vec3(gw):dist(gp)if gs<gq then return true,d(gs-gq)end;gt=vec3(gw):dist(vec3(planet.center))if gt<gr then gu=true else gu=false end;if d(gt-gr)<d(gs-gq)then return gu,d(gt-gr)else return gu,d(gs-gq)end end;local function gx()return x()==0 and userControlScheme~="keyboard"and m()==0 end;local function gy()local gz="TRAVEL"if not bA then gz="CRUISE"end;if Autopilot then gz="AUTOPILOT"end;return gz end;local gA=""local gB=""local gC=""local gD=1;local gE=2;local gF=3;local gG=4;local gH=5;local gI=6;local gJ=""local gK=0;local gL=e(1/apTickRate)*2*hudTickRate;local gM={}local gN={}local gO={}local gP={}local gQ={}local gR={}local function gS(cn,gT,gU,gV,gW,gX)local gY=tankY;local gZ=tankY+5;if not BarFuelDisplay then gZ=gZ+5 end;if m()==1 and not RemoteHud then gY=gY-50;gZ=gZ-50 end;if gU=="ATMO"then gJ="atmofueltank"elseif gU=="SPACE"then gJ="spacefueltank"else gJ="rocketfueltank"end;gK=_G[gJ.."_size"]if#gV>0 then for i=1,#gV do local ga=string.sub(gV[i][gE],1,12)local g_=0;for h0=1,gK do if gV[i][gE]==g(unit[gJ.."_"..h0].getData()).name then g_=h0;break end end;local h1=q()if gW[i]==nil or gX[i]==nil or h1-gV[i][gI]>gL then local h2;local h3=0;if g_~=0 then gX[i]=g(unit[gJ.."_"..g_].getData()).percentage;gW[i]=g(unit[gJ.."_"..g_].getData()).timeLeft;if gW[i]=="n/a"then gW[i]=0 end else h3=l(gV[i][gD])-gV[i][gG]gX[i]=e(0.5+h3*100/gV[i][gF])h2=gV[i][gH]if h2<=h3 then gW[i]=0 else gW[i]=e(0.5+h3/((h2-h3)/(h1-gV[i][gI])))end;gV[i][gH]=h3;gV[i][gI]=h1 end end;if ga==gT then ga=f("%s %d",gU,i)end;if g_==0 then ga=ga.." *"end;local h4;if gW[i]==0 then h4=""else h4=cM(gW[i])end;if gX[i]~=nil then local h5=e(gX[i]*2.55)local h6=f("rgb(%d,%d,%d)",255-h5,h5,0)local cq=""if h4~=""and gW[i]<120 or gX[i]<5 then cq="red "end;local h7=f("rgb(%d,%d,%d)",r(e((255-h5)/2.55),50,100),r(e(h5/2.55),0,50),50)if BarFuelDisplay then gB=gB..f([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="20" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%% %s</text>
                                            </g>]],h7,cn,gZ,h6,e(gX[i]*1.7+0.5),cn,gZ,cn+5,gZ+14,ga,gX[i],h4)gY=gY-22;gZ=gZ-22 else gB=gB..cm(cn,gY,ga,cq.."pdim txtfuel")gB=gB..cm(cn,gZ,f("%d%% %s",gX[i],h4),"pdim txtfuel","fill:"..h6)gY=gY+30;gZ=gZ+30 end end end end;tankY=gY end;local function h8(h9,dw)if dw<200000 and not aq or dw and aq then local ha=0;if d(bu)>1 then ha=45*math.log(d(bu),10)if bu<0 then ha=-ha end end;h9[#h9+1]=f([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,e(bu),e(ha))end;return h9 end;local function hb(hc)local hd=-bt;hc=hc-hc:project_on(hd)local he=vec3(0,0,1)he=he-he:project_on(hd)local hf=he:cross(hd)local ha=he:angle_between(hc)*constants.rad2deg;if hc:dot(hf)<0 then ha=360-ha end;return ha end;local function hg(h9,centerX,centerY,hh,hi,bM)local hj=circleRad;local hk=20;local hl=e(hh)if bM then for i=-45,45,5 do local hm=i;h9[#h9+1]=f([[<g transform="rotate(%f,%d,%d)">]],hm,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;h9[#h9+1]=f([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+hj+hk-len,centerX,centerY+hj+hk)end;h9[#h9+1]=cm(centerX,centerY+hj+hk-35,hi,"pdim txt txtmid")h9[#h9+1]=cm(centerX,centerY+hj+hk-25,hl.." deg","pdim txt txtmid")h9[#h9+1]=f([[<g transform="rotate(%f,%d,%d)">]],-hh,centerX,centerY)h9[#h9+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+hj+hk-20,centerX+5,centerY+hj+hk-20,centerX,centerY+hj+hk-15)h9[#h9+1]="</g>"end;h9[#h9+1]=[[<g style="clip-path: url(#headingClip);">]]local hn=hl;if bM then hn=hb(bo)end;local ho=20;local hp=e(hn)local hq=0;local hr=centerY+hj+hk+20;local hs=centerX;if hi~="YAW"then hr=gm(130)hs=gl(960)end;local ht=[[<path class="txttick line" d="]]local hu=e(hp-(ho+10)-hp%5+0.5)for i=hu+70,hu,-5 do local cn=hs-(-i*5+hn*5)if i%10==0 then hq=10;local B=i;if B==360 then B=0 elseif B>360 then B=B-360 elseif B<0 then B=B+360 end;h9[#h9+1]=cm(cn,hr+15,B,"txtmid bright")elseif i%5==0 then hq=5 end;if hq==10 then ht=f([[%s M %f %f v %d]],ht,cn,hr-5,hq)else ht=f([[%s M %f %f v %d]],ht,cn,hr-2.5,hq)end end;h9[#h9+1]=ht..[["/>]]h9[#h9+1]=f([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],hs-5,hr-20,hs+5,hr-20,hs,hr-10)if bM then hi="HDG"end;h9[#h9+1]=cm(gl(960),gm(100),hp.."°","dim txt txtmid size14","")h9[#h9+1]=cm(gl(960),gm(85),hi,"dim txt txtmid size20","")h9[#h9+1]=[[</g>]]end;local function hv(h9,hw,hh,centerX,centerY,bM,hx,eJ)local hj=circleRad;local hy=e(hj*3/5)if hj>0 then local hz=e(hw)local len=0;local ht=f([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*hh,centerX,centerY)if not aq then ht=f([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;h9[#h9+1]=f([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],hj-1,centerX,centerY)h9[#h9+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=e(hz-30-hz%5+0.5),e(hz+30+hz%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local co=centerY+-i*5+hw*5;if len==30 then ht=f([[%s M %d %f h %d]],ht,centerX-hy-len,co,len)if aq then h9[#h9+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*hh,centerX,centerY,centerX-hy+10,co+4,i)h9[#h9+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*hh,centerX,centerY,centerX+hy-10,co+4,i)if i==0 or i==180 or i==-180 then h9[#h9+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*hh,centerX,centerY,centerX-hy+20,co,hy*2-40)end else h9[#h9+1]=cm(centerX-hy+10,co,i,"pdim txt txtmid")h9[#h9+1]=cm(centerX+hy-10,co,i,"pdim txt txtmid")end;ht=f([[%s M %d %f h %d]],ht,centerX+hy,co,len)else ht=f([[%s M %d %f h %d]],ht,centerX-hy-len,co,len)ht=f([[%s M %d %f h %d]],ht,centerX+hy,co,len)end end;h9[#h9+1]=ht..[["/>]]local hA="PITCH"if not bM then hA="REL PITCH"end;if hw>90 and not aq then hw=90-(hw-90)elseif hw<-90 and not aq then hw=-90-(hw+90)end;if hj>200 then if aq then if eJ>Q then h9[#h9+1]=cm(centerX,centerY-15,"Yaw","pdim txt txtmid")h9[#h9+1]=cm(centerX,centerY+20,hx,"pdim txt txtmid")end;h9[#h9+1]=f([[<g transform="rotate(%f,%d,%d)">]],-hh,centerX,centerY)else h9[#h9+1]=f([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;h9[#h9+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-hy+25,centerY-5,centerX-hy+20,centerY,centerX-hy+25,centerY+5,centerX-hy+50,centerY+4,hz)h9[#h9+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+hy-25,centerY-5,centerX+hy-20,centerY,centerX+hy-25,centerY+5,centerX+hy-30,centerY+4,hz)h9[#h9+1]="</g>"end;local hB=e(hj/3)h9[#h9+1]=f([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-hB,centerY,hj-hB)if not aq and bM then h9[#h9+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*hh,centerX,centerY,centerX-hy+10,centerY,hy*2-20)end;h9[#h9+1]="</g>"if hj<200 then if aq and eJ>Q then h9[#h9+1]=cm(centerX,centerY-hj,hA,"pdim txt txtmid")h9[#h9+1]=cm(centerX,centerY-hj+10,hz,"pdim txt txtmid")h9[#h9+1]=cm(centerX,centerY-15,"Yaw","pdim txt txtmid")h9[#h9+1]=cm(centerX,centerY+20,hx,"pdim txt txtmid")else h9[#h9+1]=cm(centerX,centerY-hj,hA,"pdim txt txtmid")h9[#h9+1]=cm(centerX,centerY-hj+15,hz,"pdim txt txtmid")end end end end;local function hC(h9,dw,bM)local hD=altMeterX;local hE=altMeterY;local hF=78;local hG=19;local hH=ao;if ao~=-1 then h9[#h9+1]=cm(hD+hF,hE+hG+20,f("AGL: %.1fm",ao),"pdim altsm txtend")end;if bM and(dw<200000 and not aq or dw and aq)then table.insert(h9,f([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],hD-1,hE-4,hF+2,hG+6,hD+1,hE-1,hF-4,hG))local fW=0;local hI=1;local hJ=0;local hK=dw<0;local hL=dw<planet.surfaceMaxAltitude;local hM=9;if hK then hM=0 end;local dw=d(dw)while fW<6 do local hN=11;local hO=16;local hP=9;local hQ=14;local cq="altsm"if fW>2 then hO=hO+3;hN=hN+2;hQ=hQ+2;hP=hP-6;cq="altbig"end;if hK then cq=cq.." red"elseif hL then cq=cq.." orange"end;local hR=dw/hI%10;local hS=e(hR)local hT=e((hS+1)%10)local hU=hJ;if fW==0 then hU=hR-hS;if hK then hU=1-hU end end;if hK and(fW==0 or hJ~=0)then local hV=hT;hT=hS;hS=hV end;local hW=hO*(hU-1)local hX=hW+hO;local cn=hD+hP+(6-fW)*hN;local co=hE+hQ;h9[#h9+1]=cm(cn,co+hW,hT,cq)h9[#h9+1]=cm(cn,co+hX,hS,cq)fW=fW+1;hI=hI*10;if hS==hM then hJ=hU else hJ=0 end end;table.insert(h9,[[</g></g>]])end end;local function hY(eM)local hZ=-math.deg(n(eM.y,eM.z))+180;hZ=hZ-90;if hZ<0 then hZ=360+hZ end;if hZ>180 then hZ=-180+hZ-180 end;return-hZ end;local function h_(eM)local hn=math.deg(n(eM.y,eM.x))-90;if hn<-180 then hn=360+hn end;return hn end;local function i0(h9,eM,eJ,centerX,centerY)if eJ>5 and not aq or eJ>Q then local hj=circleRad;local i1=20;local i2=20;local i3=hY(eM)local i4=h_(eM)local i5=14;local i6=i5/2;local i7=-i4/i2*hj;local i8=i3/i1*hj;local cn=centerX+i7;local co=centerY+i8;local aj=y(i7^2+i8^2)local i9=[[<circle
                            cx="]]..cn..[["
                            cy="]]..co..[["
                            r="]]..i6/i5 ..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..cn..[["
                            cy="]]..co..[["
                            r="]]..i6 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..cn-i5 ..[[,]]..co..[[ h ]]..i6 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cn+i6 ..[[,]]..co..[[ h ]]..i6 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cn..[[,]]..co-i5 ..[[ v ]]..i6 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if aj<hj then h9[#h9+1]=i9 else local ha=n(i8,i7)local ia=4;local ib=centerX+hj*math.cos(ha)local ic=centerY+hj*math.sin(ha)h9[#h9+1]=f('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',ha*180/math.pi,ib,ic,ib-ia,ic-ia/2,ia*2,ia,ib+ia,ic-ia,ia,ia,-ia,ia)end;if not aq then local id=vec3(eM)i3=hY(-id)i4=h_(-id)i7=-i4/i2*hj;i8=i3/i1*hj;cn=centerX+i7;co=centerY+i8;aj=y(i7^2+i8^2)if aj<hj then local ie=[[<circle
                                    cx="]]..cn..[["
                                    cy="]]..co..[["
                                    r="]]..i6 ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..cn..[[,]]..co-i5 ..[[ v ]]..i6 ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..cn..[[,]]..co..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..cn..[[,]]..co..[[)" />
                                <path
                                    d="M ]]..cn-i6 ..[[,]]..co..[[ h ]]..i5 ..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..cn..[[,]]..co..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..cn..[[,]]..co..[[)"/>]]h9[#h9+1]=ie end end end end;local function ig(h9,gz,ih,ii)ih=e(ih+0.5)local gY=throtPosY+10;local gZ=throtPosY+20;if m()==1 and not RemoteHud then gY=55;gZ=65 end;local ij="CRUISE"local unit="km/h"local ct=ii;if gz=="TRAVEL"or gz=="AUTOPILOT"then ij="THROT"unit="%"ct=ih;local ik="dim"if ih<0 then ik="red"end;h9[#h9+1]=f([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],ik,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-d(ih),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;h9[#h9+1]=cm(throtPosX+10,gY,ij,"pbright txtstart")h9[#h9+1]=cm(throtPosX+10,gZ,f("%.0f %s",ct,unit),"pbright txtstart")if aq and AtmoSpeedAssist and bA and M then ih=e(N*100+0.5)local ik="red"if ih<0 then ik="red"end;h9[#h9+1]=f([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],ik,1-d(ih),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)h9[#h9+1]=cm(throtPosX+10,gY+40,"LIMIT","pbright txtstart")h9[#h9+1]=cm(throtPosX+10,gZ+40,ih.."%","pbright txtstart")end;if aq and AtmoSpeedAssist or Reentry then h9[#h9+1]=cm(throtPosX+10,gY-40,"LIMIT: "..b7 .." km/h","dim txtstart")elseif not aq and Autopilot then h9[#h9+1]=cm(throtPosX+10,gY-40,"LIMIT: "..e(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function il(h9,im)local io=throtPosY-10;local ip=throtPosX+10;h9[#h9+1]=cm(0,0,"","pdim txt txtend")if m()==1 and not RemoteHud then io=75 end;h9[#h9+1]=cm(ip,io,e(im).." km/h","pbright txtbig txtstart")end;local function iq(h9)h9[#h9+1]=cm(gl(1900),gm(1070),f("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")h9[#h9+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then h9[#h9+1]=cm(gl(960),gm(550),"Warning: Invalid Control Scheme Detected","warnings")h9[#h9+1]=cm(gl(960),gm(600),"Keyboard Scheme must be selected","warnings")h9[#h9+1]=cm(gl(960),gm(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local ir=gl(960)local is=gm(860)local it=gm(880)local iu=gm(900)local iv=gm(960)local iw=gm(200)local ix=gm(250)local iy=gm(960)if m()==1 and not RemoteHud then is=gm(135)it=gm(155)iu=gm(175)iw=gm(115)ix=gm(95)end;local iz="#222222"local iA="white"local iB="dimmer"local iC="pbright"local iD="#110000"local iE=iz;local iF=iB;if BrakeIsOn then h9[#h9+1]=cm(ir,is,"Brake Engaged","warnings")iD="#440000"iE=iA;iF=iC elseif L>0 then h9[#h9+1]=cm(ir,is,"Auto-Brake Engaged","warnings","opacity:"..L)end;local iG="#110000"local iH=iz;local iI=iB;if aq and b2 and ao==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not by and not VertTakeOff and not AutoTakeoff then h9[#h9+1]=cm(ir,iw+50,"** STALL WARNING **","warnings")iG="#ff0000"iH=iA;iI=iC;c9("stall","SW",2)end end;if bK then h9[#h9+1]=cm(ir,iw+90,"Flight Assist in Progress","warnings")end;if ax then h9[#h9+1]=cm(ir,iy,"Gyro Enabled","warnings")end;local iJ="#111100"local iK=iz;local iL=iB;if GearExtended then iJ="#775500"iK=iA;iL=iC;if S then h9[#h9+1]=cm(ir,it,"Gear Extended","warn")else h9[#h9+1]=cm(ir,it,"Landed (G: Takeoff)","warnings")end;local iM=cz(a:getTargetGroundAltitude())h9[#h9+1]=cm(ir,iu,"Hover Height: "..iM,"warn")end;local iN="#000011"local iO=iz;local iP=iB;if a7 then iN="#0000DD"iO=iA;iP=iC;h9[#h9+1]=cm(ir,iv+20,"ROCKET BOOST ENABLED","warn")end;local iQ="#001100"local iR=iz;local iS=iB;if antigrav and not ExternalAGG and by and AntigravTargetAltitude~=nil then iQ="#00DD00"iR=iA;iS=iC;if d(as-antigrav.getBaseAltitude())<501 then h9[#h9+1]=cm(ir,iw+15,f("Target Altitude: %d Singularity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warn")else h9[#h9+1]=cm(ir,iw+15,f("Target Altitude: %d Singluarity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then h9[#h9+1]=cm(ir,iw+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then h9[#h9+1]=cm(ir,iw+20,f("LockedPitch: %d",e(LockPitch)),"warn")elseif a0 then h9[#h9+1]=cm(ir,iw+20,"Follow Mode Engaged","warn")elseif Reentry or an then h9[#h9+1]=cm(ir,iw+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local iM=cz(HoldAltitude,2)if VertTakeOff then if by then iM=cz(antigrav.getBaseAltitude(),2).." AGG singularity height"end;h9[#h9+1]=cm(ir,iw,"VTO to "..iM,"warn")elseif AutoTakeoff and not IntoOrbit then if am then h9[#h9+1]=cm(ir,iw,"Takeoff to "..AutopilotTargetName,"warn")else h9[#h9+1]=cm(ir,iw,"Takeoff to "..iM,"warn")end;if BrakeIsOn and not VertTakeOff then h9[#h9+1]=cm(ir,iw+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else h9[#h9+1]=cm(ir,iw,"Altitude Hold: "..iM,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if ar>0.1 then h9[#h9+1]=cm(ir,iw+20,"Beginning ascent","warn")elseif ar<0.09 and ar>0.05 then h9[#h9+1]=cm(ir,iw+20,"Aligning trajectory","warn")elseif ar<0.05 then h9[#h9+1]=cm(ir,iw+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if b9~=nil then h9[#h9+1]=cm(ir,iw,b9,"warn")end end;if BrakeLanding then if StrongBrakes then h9[#h9+1]=cm(ir,iw,"Brake-Landing","warnings")else h9[#h9+1]=cm(ir,iw,"Coast-Landing","warnings")end end;if ProgradeIsOn then h9[#h9+1]=cm(ir,iw,"Prograde Alignment","crit")end;if RetrogradeIsOn then h9[#h9+1]=cm(ir,iw,"Retrograde Alignment","crit")end;local iT="#110000"local iU=iz;local iV=iB;if bN then iT="#FF0000"iU=iA;iV=iC;local type;if string.find(bN,"COLLISION")then type="warnings"else type="crit"end;h9[#h9+1]=cm(ir,ix+20,bN,type)elseif ar==0 then local c4,c8=c2(br:normalize())if c8~=nil then iV=iC;iT="#FF0000"iU=iA;local iM=cz(c8)local travelTime=aS.computeTravelTime(bs,0,c8)local iW="Collision"if c4.noAtmosphericDensityAltitude>0 then iW="Atmosphere"end;h9[#h9+1]=cm(ir,ix+20,c4.name.." "..iW.." "..cM(travelTime).." In "..iM,"crit")end end;if VectorToTarget and not IntoOrbit then h9[#h9+1]=cm(ir,iw+35,VectorStatus,"warn")end;local iX="#111100"local iY=iz;local iZ=iB;if passengers and#passengers>1 then iX="#DDDD00"iY=iA;iZ=iC end;local i_=gl;local j0=gm;local iB="topButton"local j1="topButtonActive"local j2=iB;if Autopilot or VectorToTarget or am or IntoOrbit then j2=j1 end;local j3=iB;if ProgradeIsOn then j3=j1 end;local j4=iB;if BrakeLanding or GearExtended then j4=j1 end;local j5=iB;if AltitudeHold or VectorToTarget then j5=j1 end;local j6=iB;if RetrogradeIsOn then j6=j1 end;local j7=iB;if IntoOrbit or bi and Autopilot then j7=j1 end;local j8=j0(30)h9[#h9+1]=f([[ 
                            <g class="pdim txt txtmid">
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],j2,i_(960),j0(54),j0(-53),i_(-120),i_(25),j0(50))h9[#h9+1]=cm(i_(910),j8,"AUTOPILOT")h9[#h9+1]=f([[
                                </g>
        
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],j3,i_(865),j0(51),i_(-25),j0(-50),i_(-110),i_(25),j0(46))h9[#h9+1]=cm(i_(800),j8,"PROGRADE")h9[#h9+1]=f([[
                                </g>
        
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],j4,i_(755),j0(47),i_(-25),j0(-46),i_(-98),i_(44),j0(44))h9[#h9+1]=cm(i_(700),j8,"LAND")h9[#h9+1]=f([[
                                </g>
        
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],j5,i_(960),j0(54),j0(-53),i_(120),i_(-25),j0(50))h9[#h9+1]=cm(i_(1010),j8,"ALT HOLD")h9[#h9+1]=f([[
                                </g>
        
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],j6,i_(1055),j0(51),i_(25),j0(-50),i_(110),i_(-25),j0(46))h9[#h9+1]=cm(i_(1122),j8,"RETROGRADE")h9[#h9+1]=f([[
                                </g>
        
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],j7,i_(1165),j0(47),i_(25),j0(-46),i_(98),i_(-44),j0(44))h9[#h9+1]=cm(i_(1220),j8,"ORBIT")h9[#h9+1]=[[
                                </g>
                            </g>]]h9[#h9+1]="</g>"return h9 end;local function j9(eJ)return e(A(eJ*3.6,0)+0.5).." km/h"end;local function ja(h9)local cn=OrbitMapX+10;local co=OrbitMapY+20;local jb={}local jc={"Alt-4: AutoTakeoff to Target"}local jd={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local je={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local jf={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}table.insert(jb,"--------------DYNAMIC-----------------")if aq then if ao~=-1 then cc(jb,jc)if ac and planet and ac.name==planet.name then table.insert(jb,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or VertTakeOffEngine then if antigrav then if by then table.insert(jb,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(jb,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(jb,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(jb,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(jb,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if GearExtended then table.insert(jb,"G: Takeoff to hover height, raise gear")else table.insert(jb,"G: Lowergear and Land")end else cc(jb,jd)table.insert(jb,"G: Begin BrakeLanding or Land")end;if VertTakeOff then table.insert(jb,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else cc(jb,je)if shield_1 then table.insert(jb,"Alt-Shift-5: Toggle shield off and on")table.insert(jb,"Alt-Shift-6: Vent shields")end end;if gyro then table.insert(jb,"Alt-9: Activate Gyroscope")end;if ExtraLateralTags~="none"or ExtraLongitudeTags~="none"or ExtraVerticalTags~="none"then table.insert(jb,"Alt-Shift-9: Cycles engines with Extra tags")end;if AltitudeHold then table.insert(jb,"Alt-Spacebar/C will raise/lower target height")table.insert(jb,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if AtmoSpeedAssist or not aq then table.insert(jb,"LALT+Mousewheel will lower/raise speed limit")end;cc(jb,jf)for i=1,#jb do co=co+12;h9[#h9+1]=cm(cn,co,jb[i],"pdim txttick txtstart")end end;local jg={Generic_Moon="assets.prod.novaquark.com/20368/f410e727-9d4d-4eab-98bf-22994b3fbdcf.png",Sun="assets.prod.novaquark.com/20368/0936494e-9b3d-4d60-9ea0-d93a3f3e29cd.png",Alioth="assets.prod.novaquark.com/20368/954f3adb-3369-4ea9-854d-a14606334152.png",Alioth_bis="assets.prod.novaquark.com/20368/b83225ed-fb96-404c-8c91-86ac15dfbbec.png",Sanctuary="assets.prod.novaquark.com/20368/1a70dbff-24bc-44cb-905c-6d375d9613b8.png",Feli="assets.prod.novaquark.com/20368/da91066c-b3fd-41f4-8c01-26131b0a7841.png",Ion="assets.prod.novaquark.com/20368/91d10712-dc51-4b73-9fc0-6f07d96605a6.png",Madis="assets.prod.novaquark.com/20368/46d57ef4-40ee-46ca-8cc5-5aee1504bbfe.png",Jago="assets.prod.novaquark.com/20368/7fca8389-6b70-4198-a9c3-4875d15edb38.png",Lacobus="assets.prod.novaquark.com/20368/cb67a6a4-933c-4688-a637-898c89eb5b94.png",Sicari="assets.prod.novaquark.com/20368/f6e2f801-075f-4ccd-ab94-46d060517e8f.png",Sinnen="assets.prod.novaquark.com/20368/54a99084-7c2b-461b-ab1f-ae4229b3b821.png",Symeon="assets.prod.novaquark.com/20368/97940324-f194-4e03-808d-d71733ad545a.png",Talemai="assets.prod.novaquark.com/20368/f68628d9-3245-4d76-968e-ad9c63a19c19.png",Teoma="assets.prod.novaquark.com/20368/5a01dd8c-3cf8-4151-99a2-83b22f1e7249.png",Thades="assets.prod.novaquark.com/20368/59f997a2-bcca-45cf-aa35-26e0e41ed5c1.png"}local function jh(h9)local ji=gl(OrbitMapX)local jj=gm(OrbitMapY)local jk=OrbitMapSize;local jl=4;local jm=15;local cn=0;local co=0;local jn,jo,jp,jq;local jr;local function js(type)local jt,E,eJ,ju,cq,jv;if type=="Periapsis"then jt=jr.periapsis.altitude;E=jr.timeToPeriapsis;eJ=jr.periapsis.speed;cq="txtend"ju=12;jv=math.min(cn,ji+jk-planet.radius/jp-jl*2)else jt=jr.apoapsis.altitude;E=jr.timeToApoapsis;eJ=jr.apoapsis.speed;ju=-12;cq="txtstart"jv=cn end;if bs<1 then E=0 end;h9[#h9+1]=f([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],jv+ju,co-5,cn,co-5)h9[#h9+1]=f([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],jv-ju*4,co+2,cn,co+2)h9[#h9+1]=cm(jv,co,type,cq)cn=jv-ju*2;co=co+jm;local iM=cz(jt)h9[#h9+1]=cm(cn,co,iM,cq)co=co+jm;h9[#h9+1]=cm(cn,co,cM(E),cq)co=co+jm;h9[#h9+1]=cm(cn,co,j9(eJ),cq)end;local jw=jk*1.5;if SelectedTab=="INFO"then jw=25*7 end;if SelectedTab~="HIDE"then h9[#h9+1]=[[<g class="pbright txtorb txtmid">]]h9[#h9+1]=f('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',jk*2,jw,ji,jj)h9[#h9+1]=f([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],jk*2,jw,ji,jj)end;local jx=jk*1.5;local jy=jk*2;local jz=jx/2;local jA=jk;local jB=ji+jA;local jC=jj+jz;local jD=ji+jy;local jE=jj+jx;if SelectedTab=="ORBIT"then jj=jj+jl;jn=jk/2;jq=0;jr={}jr.periapsis={}jr.apoapsis={}if orbit~=nil then if orbit.periapsis~=nil then jr.periapsis.altitude=orbit.periapsis.altitude;jr.periapsis.speed=orbit.periapsis.speed end;if orbit.apoapsis~=nil then jr.apoapsis.altitude=orbit.apoapsis.altitude;jr.apoapsis.speed=orbit.apoapsis.speed end;jr.period=orbit.period;jr.eccentricity=orbit.eccentricity;jr.timeToApoapsis=orbit.timeToApoapsis;jr.timeToPeriapsis=orbit.timeToPeriapsis;jr.eccentricAnomaly=orbit.eccentricAnomaly;jr.trueAnomaly=orbit.trueAnomaly end;if jr.periapsis==nil then jr.periapsis={}jr.periapsis.altitude=-planet.radius;jr.periapsis.speed=MaxGameVelocity end;if jr.eccentricity==nil then jr.eccentricity=1 end;if jr.apoapsis==nil then jr.apoapsis={}jr.apoapsis.altitude=as;jr.apoapsis.speed=0 end;if bs<1 then jr.apoapsis.altitude=as;jr.apoapsis.speed=0 end;if jr.apoapsis.altitude then jp=(jr.apoapsis.altitude+jr.periapsis.altitude+planet.radius*2)/(jn*2)jo=(planet.radius+jr.apoapsis.altitude)/jp*(1-jr.eccentricity)jq=jn-jr.periapsis.altitude/jp-planet.radius/jp;local jF=math.pi;if jr.period~=nil and jr.period>0 and jr.timeToApoapsis~=nil then jF=jr.eccentricAnomaly;if jr.timeToPeriapsis<jr.timeToApoapsis then jF=2*math.pi-jF end end;if bs<1 or jF~=jF then jF=math.pi end;local jG=-jn*math.cos(jF)+ji+jA+jl;local jH=jo*math.sin(jF)+jj+jz+jl;local jI=""h9[#h9+1]='<g clip-path="url(#orbitRect)">'h9[#h9+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],jI,ji+jk+jl,jj+jk*1.5/2+jl,jn,jo)if jo<1 then h9[#h9+1]=f([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],ji+jk+jl-jq,jj+jk*1.5/2+jl,jG,jH)end;h9[#h9+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',ji+jk+jl-jq,jj+jk*1.5/2+jl,(planet.radius+planet.noAtmosphericDensityAltitude)/jp)h9[#h9+1]=f('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',ji+jk+jl-jq,jj+jk*1.5/2+jl,(planet.radius+planet.noAtmosphericDensityAltitude)/jp)h9[#h9+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",ji+jk+jl,jj+jk*1.5/2+jl,jn,jo)h9[#h9+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',ji+jk+jl-jq,jj+jk*1.5/2+jl,planet.radius/jp)h9[#h9+1]='</g>'local jJ=math.floor(planet.radius/jp+0.5)local jK=jg.Generic_Moon;if jg[planet.name]then jK=jg[planet.name]end;cn=ji+jk+jl*4+jn;co=jj+jk*1.5/2+5+jl;if jr.apoapsis~=nil and jr.apoapsis.speed<MaxGameVelocity then js("Apoapsis")end;co=jj+jk*1.5/2+5+jl;cn=ji+jk-jl*2-jn;if jr.periapsis~=nil and jr.periapsis.speed<MaxGameVelocity and jr.periapsis.altitude>0 then js("Periapsis")end;h9[#h9+1]=cm(ji+jk+jl,jj+20+jl,planet.name,"txtorbbig")h9[#h9+1]=f('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',jG,jH)h9[#h9+1]=[[</g>]]return h9 else h9[#h9+1]='<g clip-path="url(#orbitRect)">'local jL=""local jM=1.2*(maxAtlasX-minAtlasX)/(jk*2)local jN=1.4*(maxAtlasY-minAtlasY)/(jk*1.5)for cV,cW in pairs(b[0])do if cW.center then local cn=ji+jk+cW.center.x/jM;local co=jj+jk*1.5/2+cW.center.y/jN;jL=jL..'<circle cx="'..cn..'" cy="'..co..'" r="'..cW.radius/jM*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(cW.name,"Moon")and not string.match(cW.name,"Sanctuary")and not string.match(cW.name,"Space")then jL=jL.."<text x='"..cn.."' y='"..co+cW.radius/jM*30+20 .."' font-size='12' fill="..ay.." text-anchor='middle' font-family='Montserrat'>"..cW.name.."</text>"end end end;local eN=vec3(core.getConstructWorldPos())local cn=ji+jk+eN.x/jM;local co=jj+jk*1.5/2+eN.y/jN;jL=jL..'<circle cx="'..cn..'" cy="'..co..'" r="2" stroke="white" stroke-width="1" fill="red"/>'jL=jL.."<text x='"..cn.."' y='"..co-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"aN=jM;aO=jN;local jO=eN+br*1000000;local jP=ji+jk+jO.x/jM;local gZ=jj+jk*1.5/2+jO.y/jN;jL=jL..'<line x1="'..cn..'" y1="'..co..'" x2="'..jP..'" y2="'..gZ..'" stroke="purple" stroke-width="1"/>'h9[#h9+1]=jL;h9[#h9+1]='</g>'end elseif SelectedTab=="INFO"then h9=aV.DrawOdometer(h9,ad,TotalDistanceTravelled,ae)elseif SelectedTab=="HELP"then h9=ja(h9)elseif SelectedTab=="SCOPE"then h9[#h9+1]='<g clip-path="url(#orbitRect)">'local jM=(maxAtlasX-minAtlasX)/jy;local jN=(maxAtlasY-minAtlasY)/jx;local jQ=scopeFOV;table.sort(bU,function(cx,cy)return(cx.center-bv):len2()>(cy.center-bv):len2()end)local ff={}local jR={}local jS=120;local jT=100;local jU=nil;local jV=nil;for i=#bU,1,-1 do local cW=bU[i]local fe=cW.center-bv;local jW=fe:len()local jX=fe:normalize()local jY=fe:cross(bo):normalize()local jZ=math.acos(jY:dot(bp))if jY:cross(bp):dot(bo)<0 then jZ=-jZ end;local j_=fe:project_on_plane(bo):len()local k0=fe:project_on_plane(bp)local k1=fe:project_on_plane(bn)local k2=math.sin(jZ)*math.asin(j_/jW)*constants.rad2deg;local k3=math.cos(jZ)*math.asin(j_/jW)*constants.rad2deg;if jX:dot(bo)<0 then k3=90*math.cos(jZ)+90*math.cos(jZ)-k3;k2=90*math.sin(jZ)+90*math.sin(jZ)-k2 end;local cn=jB+k2/jQ*jx;local co=jC+k3/jQ*jx;local k4=(cn-jB)*(cn-jB)+(co-jC)*(co-jC)local k5=math.asin((cW.radius+cW.surfaceMaxAltitude)/jW)*constants.rad2deg;local g7=k5/jQ*jx;local k6=math.asin(cW.atmosphereRadius/jW)*constants.rad2deg;local k7=k6/jQ*jx;local aj=cz(jW,1)local k8=cW.name;local k9=false;if co>jj then if co>jE then if co-k7<=jE then k9=true end else k9=true end else if co+k7>=jj then k9=true end end;local ka=false;local kb=cn;if cW.systemId==0 then kb=cn+jS else kb=cn-jS end;if kb+jS>ji then if kb+jS>jD then if kb-k7-jS<=jD then ka=true end else ka=true end else if kb+k7+jS>=ji then ka=true end end;local kc={}kc.x=cn;kc.y=co;kc.planet=cW;kc.atmoSize=k7;if not jU or k4<jU then jU=k4;jV=kc end;if ka and k9 then local kd=math.max(k7,5)if k4<kd*kd then k8=k8 .." - "..aj end;kc.size=g7;kc.i=i;kc.displayString=k8;kc.distance=aj;kc.visible=true;jR[#jR+1]=kc else kc.visible=false end end;local ke=false;table.sort(jR,function(cx,cy)return cx.y<cy.y end)for cV,eQ in ipairs(jR)do local cW,g7,i,k7,cn,co,k8,aj=eQ.planet,eQ.size,eQ.i,eQ.atmoSize,eQ.x,eQ.y,eQ.displayString,eQ.distance;local jv,kf,kg,kh;local ki=15;local cq="pdim"if cW.systemId~=0 then kg=gl(string.len(k8)*5)ki=-(15+kg)kh=gm(10)cq="pdimfill"else kg=gl(string.len(k8)*9)kh=gm(15)end;if g7*2>kg then jv=r(cn,ji+kg/2,jD-kg/2)kf=r(co,jj+kh,jE-5)jv=r(jv,cn-g7+kg/2,cn+g7-kg/2)kf=r(kf,co-g7+kh,co+g7)else jv=cn+ki;kf=co end;local kj;repeat kj=false;for kk,eQ in pairs(ff)do local kl=eQ.textPositions;local km=kl.y-kf;if kk~=i and d(km)<kl.height and kl.x+kl.width>jv and kl.x<jv+kg then if g7>kg then kf=r(kf+kh,jj+15,jE-5)else kf=kl.y+kl.height+1;kj=true end;break end end until not kj;local kn=k8~=cW.name or jv<=jB and jv+kg>=jB and kf-kh<=jC and kf>=jC;eQ.hovered=kn;local ko=1;if kn then ko=2;if g7*2<kg then ko=10 end;if k8==cW.name then k8=k8 .." - "..aj end;cq="pbright"if cW.systemId~=0 then kg=gl(string.len(k8)*5)ki=-(15+kg)else kg=gl(string.len(k8)*7)end;if g7*2>kg then jv=r(cn,ji+kg/2,jD-kg/2)jv=r(jv,cn-g7+kg/2,cn+g7-kg/2)else jv=cn+ki end;if not Autopilot and not VectorToTarget and not IntoOrbit and not ke then ke=true;if AutopilotTargetName~=cW.name then for kp,dn in ipairs(bG)do if dn.index==cW.id then AutopilotTargetIndex=kp;aW.UpdateAutopilotTarget()break end end end end end;ff[i]={}ff[i].textPositions={}ff[i].textPositions.y=kf;ff[i].textPositions.x=jv;ff[i].textPositions.width=kg;ff[i].textPositions.height=kh;ff[i].output=""if g7*2>kg then cq=cq.." txtmid"else cq=cq.." txtstart"end;if k7-g7>2 then ff[i].output=f('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',cn,co,k7,az,0.1*ko)end;ff[i].output=ff[i].output..f('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',cn,co,g7,az,0.2*ko)if cW.systemId==0 then ff[i].output=ff[i].output..f([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],jv,kf,ay,cq,k8)if g7*2<=kg then ff[i].output=ff[i].output..f("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",jv+kg,kf+2,jv,kf+2,cn,co)end else ff[i].output=ff[i].output..f([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],jv,kf,az,cq,k8)if g7*2<=kg then ff[i].output=ff[i].output..f("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",jv,kf+2,jv+kg,kf+2,cn,co)end end end;for cV,cW in ipairs(bU)do if ff[cV]then h9[#h9+1]=ff[cV].output end end;if jV~=nil and scopeFOV<90 and not jV.hovered then local kq=jV.planet.atmosphereRadius/jV.atmoSize;local kr=y(jU)*kq;local ks=cz(kr,1)local kg=gl(math.max(string.len(ks)*7,string.len(jV.planet.name)*7))local kh=gm(12)local jv=r(jV.x+(jB-jV.x)/2,ji+kg/2,jD-kg/2)local kf=r(jV.y+(jC-jV.y)/2,jj+kh*2,jE-5)h9[#h9+1]=f("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",jV.x,jV.y,jB,jC)h9[#h9+1]=f([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],jv,kf,"white",ks)if not jV.visible then h9[#h9+1]=f([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],jv,kf-kh,"white",jV.planet.name)end end;if bs>1 then local fe=br*1000;local jX=fe:normalize()local j_=fe:project_on_plane(bo):len()local k0=fe:project_on_plane(bp)local k1=fe:project_on_plane(bn)local jY=fe:cross(bo):normalize()local jZ=math.acos(jY:dot(bp))if jY:cross(bp):dot(bo)<0 then jZ=-jZ end;local k2=math.sin(jZ)*math.asin(j_/fe:len())*constants.rad2deg;local k3=math.cos(jZ)*math.asin(j_/fe:len())*constants.rad2deg;if jX:dot(bo)<0 then k3=90*math.cos(jZ)+90*math.cos(jZ)-k3;k2=90*math.sin(jZ)+90*math.sin(jZ)-k2 end;local cn=jB+k2/jQ*jx;local co=jC+k3/jQ*jx;local i5=14;local i6=i5/2;local i9=[[<circle
                                    cx="]]..cn..[["
                                    cy="]]..co..[["
                                    r="]]..i6/i5 ..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..cn..[["
                                    cy="]]..co..[["
                                    r="]]..i6 ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..cn-i5 ..[[,]]..co..[[ h ]]..i6 ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..cn+i6 ..[[,]]..co..[[ h ]]..i6 ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..cn..[[,]]..co-i5 ..[[ v ]]..i6 ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]h9[#h9+1]=i9 end;h9[#h9+1]=f("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",jB,jC-10,jB,jC+10)h9[#h9+1]=f("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",jB-10,jC,jB+10,jC)h9[#h9+1]='</g>'else return h9 end end;local function kt(ku,kv)local kw;local kx=(kv-ku):normalize()local eO=(bv-ku):dot(kx)/kx:dot(kx)if eO<=0.then return(bv-ku):len()elseif eO>=(kv-ku):len()then return(bv-kv):len()end;local ky=ku+eO*kx;kw=(ky-bv):len()return kw end;local function kz()local kw;local kA=nil;local kB=nil;local kC=nil;for cV,kD in pairs(b[0])do if kD.hasAtmosphere then local aj=kt(planet.center,kD.center)if kA==nil or aj<kA then kB=kD;kA=aj;kC=planet end;if ac and ac.hasAtmosphere and ac.name~=planet.name then local e9=kt(ac.center,kD.center)if e9<kA then kB=kD;kA=e9;kC=ac end end end end;local kE=gl(1770)local kF=gm(330)if kA then local kG="txttick "local kH=500000;if kA<kB.radius+kH or kA<kC.radius+kH then if bH then kG="txttick red "else kG="txttick orange "end end;kw=cz(kA,2)bJ=cm(kE,kF,"Pipe ("..kC.name.."--"..kB.name.."): "..kw,kG.."pbright txtmid")end end;local kI={}local kJ=nil;function kI.HUDPrologue(h9)bH,bI=gv(bv)if not bH then H=PvPR;J=PvPG;I=PvPB;if shield_1 and AutoShieldToggle and shield_1.getState()==0 then shield_1.toggle()end else H=SafeR;J=SafeG;I=SafeB;if shield_1 and AutoShieldToggle and shield_1.getState()==1 then shield_1.toggle()end end;ay=[[rgb(]]..e(H+0.6)..","..e(J+0.6)..","..e(I+0.6)..[[)]]az=[[rgb(]]..e(H*0.8+0.5)..","..e(J*0.8+0.5)..","..e(I*0.8+0.5)..[[)]]local kK=ay;local kL=az;local kM=[[rgb(]]..e(H*0.4+0.5)..","..e(J*0.4+0.5)..","..e(I*0.4+0.5)..[[)]]local kN=ay;local kO=az;local kP=kM;if gx()and not brightHud then kK=[[rgb(]]..e(H*0.5+0.5)..","..e(J*0.5+0.5)..","..e(I*0.5+0.5)..[[)]]kL=[[rgb(]]..e(H*0.3+0.5)..","..e(J*0.3+0.5)..","..e(I*0.2+0.5)..[[)]]kM=[[rgb(]]..e(H*0.2+0.5)..","..e(J*0.2+0.5)..","..e(I*0.2+0.5)..[[)]]end;local i_=gl;local j0=gm;h9[#h9+1]=f([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none;stroke:%s}
                                .linethick {stroke-width:3px;fill:none}
                                .linethin {stroke-width:1px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}
                                .warn {fill:orange; font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                text.bright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pbright {fill:%s;stroke:%s}
                                text.pbright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dim {fill:%s;stroke:%s}
                                text.dim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pdim {fill:%s;stroke:%s}
                                text.pdim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .red {fill:red;stroke:red}
                                text.red {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .orange {fill:orange;stroke:orange}
                                text.orange {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                                text { stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dimstroke {stroke:%s}
                                .brightstroke {stroke:%s}
                                .indicatorText {font-size:20px;fill:white}
                                .size14 {font-size:14px}
                                .size20 {font-size:20px}
                                .topButton {fill:%s;opacity:0.5;stroke-width:2;stroke:%s}
                                .topButtonActive {fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}
                                .topButton text {font-size:13px; fill: %s; opacity:1; stroke-width:20px}
                                .topButtonActive text {font-size:13px;fill:%s; stroke-width:0px; opacity:1}
                                .indicatorFont {font-size:20px;font-family:Bank}
                                .dimmer {stroke: %s;}
                                .pdimfill {fill: %s;}
                                .dimfill {fill: %s;}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                                <defs>
                                    <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="100%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/>
                                    </radialGradient>
                                    <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="1"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="1"/>
                                    </radialGradient>
                                    <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="1"/>
                                        <stop offset="66%%" stop-color="%s" stop-opacity="1"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/>
                                    </radialGradient>
                                </defs>
                                <g class="pdim txt txtend">
                                
                            ]],kK,kK,kK,kN,kN,kL,kL,kO,kO,kL,kK,kM,kO,kK,kK,kM,kM,kP,kM,aG,aH,kL,kL,kL,kL,kL,kN,kL,kO,kP,kO,kO,kP)if not kJ then kJ=f([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],i_(630),j0(0),i_(675),j0(45),i_(960),j0(55),i_(1245),j0(45),i_(1290),j0(0),i_(1000),j0(105),i_(1040),j0(59),i_(1250),j0(51),i_(1300),j0(0),i_(1920),j0(0),i_(1920),j0(20),i_(1400),j0(20),i_(1300),j0(105),i_(920),j0(105),i_(880),j0(59),i_(670),j0(51),i_(620),j0(0),i_(0),j0(0),i_(0),j0(20),i_(520),j0(20),i_(620),j0(105),i_(890),j0(59),i_(960),j0(62),i_(1030),j0(59),i_(985),j0(112),i_(1150),j0(112),i_(1100),j0(152),i_(820),j0(152),i_(780),j0(112),i_(935),j0(112),i_(890),j0(59),i_(960),j0(62),i_(1030),j0(59),i_(985),j0(112),i_(1150),j0(112),i_(1100),j0(152),i_(820),j0(152),i_(780),j0(112),i_(935),j0(112))end;h9[#h9+1]=kJ;return h9 end;function kI.DrawVerticalSpeed(h9,dw)h8(h9,dw)end;function kI.UpdateHud(h9)local hZ=bB;local kQ=bC;local hh=kQ;local hw=hZ;local ih=e(unit.getThrottle())local im=bs*3.6;local ii=unit.getAxisCommandValue(0)local kR=gl(1770)local kS=gm(310)if AtmoSpeedAssist and bA then ii=K;ih=K*100 end;local gz=gy()local hi="ROLL"if ih==nil then ih=0 end;if not bM then if bs>5 then hZ=hY(bq)kQ=h_(bq)else hZ=0;kQ=0 end;hi="YAW"end;if bI>50000 and not aq then local kT;kT=cz(bI)h9[#h9+1]=cm(kR,kS,"PvP Boundary: "..kT,"pbright txtbig txtmid")end;h9[#h9+1]=ak;h9[#h9+1]=aD;h9[#h9+1]=gA;if bJ~=""then h9[#h9+1]=bJ end;if gB~=""then h9[#h9+1]=gB end;if gC~=""then h9[#h9+1]=gC end;h8(h9,as)if m()==0 or RemoteHud then if bM then hg(h9,centerX,centerY,hh,hi,bM)else hg(h9,centerX,centerY,kQ,hi,bM)end;if not gx()or brightHud then if bM then hg(h9,centerX,centerY,hh,hi,bM)hv(h9,hw,hh,centerX,centerY,bM,e(h_(bq)),bs)else hg(h9,centerX,centerY,kQ,hi,bM)hv(h9,hZ,kQ,centerX,centerY,bM,e(kQ),bs)end;hC(h9,as,bM)i0(h9,bq,bs,centerX,centerY)end end;ig(h9,gz,ih,ii)il(h9,im)iq(h9)jh(h9)return h9 end;function kI.HUDEpilogue(h9)h9[#h9+1]="</svg>"return h9 end;function kI.ExtraData(h9)local kU=gl(1240)local kV=gm(55)local kW=kV+10;local kX;local i_=gl;local j0=gm;local kY=0;local gz=gy()local kZ=i_(99)local k_=i_(80)local l0=j0(85)local l1=j0(31)local l2=0;local l3=0;local l4=av>1000000 and A(av/1000000,2).."kT"or A(av/1000,2).."T"if aq then kY=LastMaxBrakeInAtmo else kY=LastMaxBrake end;local l5,l6=aS.computeDistanceAndTime(bs,0,av,0,0,kY)if l5<0 then l5=0 end;kY=A(kY/(av*go),2).."g"local l7=a:maxForceForward()kX=core.g()if kX>0.1 then l3=av*kX;l3=A(l3/(av*go),2).."g"l2=0.5*l7/kX;l2=l2>1000000 and A(l2/1000000,2).."kT"or A(l2/1000,2).."T"end;l7=A(l7/(av*go),2).."g"local l8=vec3(core.getWorldAcceleration()):len()/9.80665;kX=core.g()h9[#h9+1]=[[<g class="dim txt txtend size14">]]if m()==1 and not RemoteHud then kU=gl(1120)kV=gm(55)kW=kV+10 elseif aq then local l9=gl(770)h9[#h9+1]=cm(i_(895),kZ,"ATMO","")h9[#h9+1]=f([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],i_(895),l0,i_(-80))h9[#h9+1]=cm(i_(815),k_,f("%.1f%%",ar*100),"txtstart size20")end;h9[#h9+1]=cm(i_(1025),kZ,"GRAVITY","txtstart")h9[#h9+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],i_(1025),l0,i_(80))h9[#h9+1]=cm(i_(1105),k_,f("%.2fg",kX/9.80665),"size20")h9[#h9+1]=cm(i_(1125),kZ,"ACCEL","txtstart")h9[#h9+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],i_(1125),l0,i_(80))h9[#h9+1]=cm(i_(1205),k_,f("%.2fg",l8),"size20")h9[#h9+1]=cm(i_(695),kZ,"BRAKE","")h9[#h9+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],i_(695),l0,i_(-80))h9[#h9+1]=cm(i_(615),k_,f("%s",cM(l6)),"txtstart size20")h9[#h9+1]=cm(i_(635),j0(45),"TRIP","")h9[#h9+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],i_(635),j0(31),i_(-90))if travelTime then h9[#h9+1]=cm(i_(532),j0(23),f("%s",cM(travelTime)),"txtstart size20")end;h9[#h9+1]=cm(i_(795),kZ,"BRAKE","")h9[#h9+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],i_(795),l0,i_(-80))h9[#h9+1]=cm(i_(715),k_,f("%s",cz(l5)),"txtstart size20")h9[#h9+1]=cm(i_(1285),j0(45),"MASS","txtstart")h9[#h9+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],i_(1285),j0(31),i_(90))h9[#h9+1]=cm(i_(1388),j0(23),f("%s",l4),"size20")h9[#h9+1]=cm(i_(1220),kZ,"THRUST","txtstart")h9[#h9+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],i_(1220),l0,i_(80))h9[#h9+1]=cm(i_(1300),k_,f("%s",l7),"size20")h9[#h9+1]=cm(gl(960),gm(175),gz,"pbright txtbig txtmid size20")h9[#h9+1]="</g>"end;function kI.DrawOdometer(h9,ad,TotalDistanceTravelled,ae)if SelectedTab~="INFO"then return h9 end;local kX;local l2=0;local l3=0;local kY=0;local l4=av>1000000 and A(av/1000000,2).." kTons"or A(av/1000,2).." Tons"if aq then kY=LastMaxBrakeInAtmo else kY=LastMaxBrake end;local l5,l6=aS.computeDistanceAndTime(bs,0,av,0,0,kY)kY=A(kY/(av*go),2).." g"local l7=a:maxForceForward()kX=core.g()if kX>0.1 then l3=av*kX;l3=A(l3/(av*go),2).." g"l2=0.5*l7/kX;l2=l2>1000000 and A(l2/1000000,2).." kTons"or A(l2/1000,2).." Tons"end;l7=A(l7/(av*go),2).." g"if m()==0 or RemoteHud then local la=gl(OrbitMapX+10)local lb=gm(OrbitMapY+20)local lc=gl(OrbitMapX+10+OrbitMapSize)local ld=25;h9[#h9+1]="<g class='txtstart size14 bright'>"h9[#h9+1]=cm(la,lb,f("BrkTime: %s",cM(l6)))h9[#h9+1]=cm(lc,lb,f("Trip: %.2f km",ad))h9[#h9+1]=cm(la,lb+ld,f("Lifetime: %.2f kSU",TotalDistanceTravelled/200000))h9[#h9+1]=cm(lc,lb+ld,f("BrkDist: %s",cz(l5)))h9[#h9+1]=cm(la,lb+ld*2,"Trip Time: "..cM(ae))h9[#h9+1]=cm(lc,lb+ld*2,"Total Time: "..cM(TotalFlightTime))h9[#h9+1]=cm(la,lb+ld*3,f("Mass: %s",l4))h9[#h9+1]=cm(lc,lb+ld*3,f("Max Brake: %s",kY))h9[#h9+1]=cm(la,lb+ld*4,f("Max Thrust: %s",l7))if kX>0.1 then h9[#h9+1]=cm(lc,lb+ld*4,f("Max Thrust Mass: %s",l2))h9[#h9+1]=cm(la,lb+ld*5,f("Req Thrust: %s",l3))else h9[#h9+1]=cm(lc,lb+ld*5,"Max Mass: n/a")h9[#h9+1]=cm(la,lb+ld*6,"Req Thrust: n/a")end end;h9[#h9+1]="</g></g>"return h9 end;function kI.DrawWarnings(h9)return iq(h9)end;function kI.DisplayOrbitScreen(h9)return jh(h9)end;function kI.DisplayMessage(h9,iM)if iM~="empty"then local co=310;for le in string.gmatch(iM,"([^\n]+)")do co=co+35;h9[#h9+1]=cm("50%",co,le,"msg")end end;if ai~=0 then unit.setTimer("msgTick",ai)ai=0 end end;function kI.DrawDeadZone(h9)h9[#h9+1]=f([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function kI.UpdatePipe()if aq then bJ=""return end;kz()end;function kI.DrawSettings(h9)if#bE>0 then local cn=gl(640)local co=gm(200)h9[#h9+1]=[[<g class="pbright txtvspd txtstart">]]for cV,cW in pairs(bE)do h9[#h9+1]=cm(cn,co,cW..": ".._G[cW])co=co+20;if cV%12==0 then cn=cn+gl(350)co=gm(200)end end;h9[#h9+1]=cm(gl(640),gm(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")h9[#h9+1]="</g>"end;return h9 end;local lf;local lg=gl(1770)local lh=gm(350)local li=gm(15)local lj=gl(1370)local bV,lk;local ll=0;function kI.DrawRadarInfo()local function lm()if radarPanelID~=nil and ll==0 then t(radarPanelID)radarPanelID=nil;if lf~=nil then t(lf)lf=nil end else if ll==1 then t(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(bP,1,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")lf=_autoconf.panels[_autoconf.panels_size]end;if radarPanelID==nil then _autoconf.displayCategoryPanel(bP,1,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]end;ll=0 end end;local fe,ff,fd,fg,fh,fa=aY.GetRadarHud()local B=fg or 0;if fd>0 then if CollisionSystem then bV=B.."/"..fh.." Plotted : "..fd-fh.." Ignored"else bV="Radar Contacts: "..fd end;gA=cm(lg,lh,bV,"pbright txtbig txtmid")if#fa>0 then gA=gA..cm(lj,li,"Friendlies In Range","pbright txtbig txtmid")for cV,cW in pairs(fa)do li=li+20;gA=gA..cm(lj,li,bP[1].getConstructName(cW),"pdim txtmid")end end;if fe==nil and lf==nil then ll=1;lm()end;if fe~=nil and lf~=nil then lm()end;if radarPanelID==nil then lm()end else if ff then gA=cm(lg,lh,bQ.." Radar: Jammed","pbright txtbig txtmid")else gA=cm(lg,lh,"Radar: No "..bQ.." Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then ll=0;lm()end end end;function kI.DrawTanks()if fuelX~=0 and fuelY~=0 then gB=cm(fuelX,fuelY,"","txtstart pdim txtfuel")tankY=fuelY;gS(fuelX,"Atmospheric ","ATMO",aI,gQ,gR)gS(fuelX,"Space Fuel T","SPACE",aJ,gO,gP)gS(fuelX,"Rocket Fuel ","ROCKET",aK,gM,gN)end end;function kI.DrawShield()local ln=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local lo=core.getPvPTimer()local lp=shield_1.getResistances()local lq="A: "..10+lp[1]*100 .."% / E: "..10+lp[2]*100 .."% / K:"..10+lp[3]*100 .."% / T: "..10+lp[4]*100 .."%"local cn,co=shieldX-60,shieldY+30;local lr=e(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())local h5=e(lr*2.55)local h6=f("rgb(%d,%d,%d)",255-h5,h5,0)local cq=""gC=cm(cn,co,"","txtmid pdim txtfuel")if lr<10 and ln~="Shield Disabled"then cq="red "end;lo=lo>0 and"   PvPTime: "..cM(lo)or""gC=gC..f([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],cn,co,h6,lr*2,cn,co,cn+2,co+10,lr,lo)gC=gC..cm(cn,co-5,ln,cq.."txtstart pbright txtbig")gC=gC..cm(cn,co+30,lq,cq.."txtstart pbright txtsmall")end;return kI end;local function ls()local function lt(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=b[0][0]end;return p end;local function lu()local function lv(lw,lx)return lw.name<lx.name end;bG={}for cV,cW in pairs(b[0])do bG[#bG+1]={name=cW.name,index=cV}end;table.sort(bG,lv)end;local function ly(lz)for cV,cW in pairs(lz)do if cW.name and cW.name==CustomTarget.name then return cV end end;return-1 end;local function lA()bS=AutopilotTargetIndex;if AutopilotTargetIndex==0 then AutopilotTargetName="None"ac=nil;CustomTarget=nil;return true end;local lB=bG[AutopilotTargetIndex].index;local lC=b[0][lB]if lC.center then AutopilotTargetName=lC.name;ac=aR[0][lB]if CustomTarget~=nil then if ar==0 then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end;if u(widgetTargetOrbitText,widgetTargetOrbit)~=1 then v(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=lC;for _,cW in pairs(aR[0])do if cW.name==CustomTarget.planetname then ac=cW;AutopilotTargetName=CustomTarget.name;break end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ac.center)else AutopilotTargetCoords=CustomTarget.position end;if ac.planetname~="Space"then if ac.hasAtmosphere then AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=aU(ac):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function lD(hd)if not Autopilot and not VectorToTarget and not am and not IntoOrbit then if hd==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bG then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bG end end;if AutopilotTargetIndex==0 then lA()else local lB=bG[AutopilotTargetIndex].index;local lC=b[0][lB]if lC~=nil and lC.name=="Space"or iphCondition=="Custom Only"and lC.center or iphCondition=="No Moons"and string.find(lC.name,"Moon")~=nil then if hd==nil then lD()else lD(1)end else lA()end end else a2="Disengage autopilot before changing Interplanetary Helper"c9("iph","AP")end end;local function lE()local fW=-1;fW=ly(b[0])if fW>-1 then table.remove(b[0],fW)end;fW=-1;fW=ly(SavedLocations)if fW~=-1 then a2=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,fW)end;lD()lu()end;local function lF(ga,position,hV,lG)if dbHud_1 or hV then local p=lt(position)local kX=p.gravity;if lG then kX=unit.getClosestPlanetInfluence()end;local lH={position=position,name=ga,planetname=p.name,gravity=kX,safe=lG}if not hV then SavedLocations[#SavedLocations+1]=lH else for cV,cW in pairs(b[0])do if cW.name and ga==cW.name then table.remove(b[0],cV)end end end;table.insert(b[0],lH)lu()lA()a2="Location saved as "..ga.."("..p.name..")"else a2="Databank must be installed to save permanent locations"end end;local lI={}function lI.UpdateAtlasLocationsList()lu()end;function lI.UpdateAutopilotTarget()lA()end;function lI.adjustAutopilotTargetIndex(hd)lD(hd)end;function lI.findAtlasIndex(lz)ly(lz)end;function lI.UpdatePosition(lJ)local fW=ly(SavedLocations)if fW~=-1 then if lJ~=nil then SavedLocations[fW].name=lJ;AutopilotTargetIndex=AutopilotTargetIndex-1;lD()else local lK=SavedLocations[fW]lK.gravity=unit.getClosestPlanetInfluence()lK.position=bv;lK.safe=true end;a2=SavedLocations[fW].name.." position updated ("..SavedLocations[fW].planetname..")"else a2="Name Not Found"end end;function lI.AddNewLocation(ga,position,hV,lG)lF(ga,position,hV,lG)end;function lI.ClearCurrentPosition()lE()end;for cV,cW in pairs(SavedLocations)do table.insert(b[0],cW)end;lu()if AutopilotTargetIndex>#bG then AutopilotTargetIndex=0 end;lI.UpdateAutopilotTarget()return lI end;local function lL()local cG={}local function lM(eJ)local lN=AutopilotEndSpeed;if not Autopilot then lN=0 end;if not aq then return aS.computeDistanceAndTime(eJ,lN,av,0,0,LastMaxBrake-AutopilotPlanetGravity*av)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return aS.computeDistanceAndTime(eJ,lN,av,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*av)else return 0,0 end end end;local function lO(eJ)local lN=AutopilotEndSpeed;if not Autopilot then lN=0 end;return aS.computeDistanceAndTime(eJ,lN,av,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*av)end;local lP=false;local lQ=0;function cG.GetAutopilotBrakeDistanceAndTime(eJ)return lM(eJ)end;function cG.GetAutopilotTBBrakeDistanceAndTime(eJ)return lO(eJ)end;local function lR()local function lS()local lT=-1;local lU=-1;if vBooster then lT=vBooster.getDistance()end;if hover then lU=hover.getDistance()end;if lT~=-1 and lU~=-1 then if lT<lU then return lT else return lU end elseif lT~=-1 then return lT elseif lU~=-1 then return lU else return-1 end end;local lV=lS()local lW=-1;if telemeter_1 then lW=telemeter_1.getDistance()end;if lV~=-1 and lW~=-1 then if lV<lW then return lV else return lW end elseif lV~=-1 then return lV else return lW end end;local function lX(planet,e5,lY)local function lZ(l_,dq)local eb=vec3(dq)if l_.id==0 then return setmetatable({latitude=eb.x,longitude=eb.y,altitude=eb.z,id=0,systemId=l_.systemId},MapPosition)end;local ec=eb-l_.center;local aj=ec:len()local dw=aj-l_.radius;local du=0;local dv=0;if not cw(aj,0)then local ed=n(ec.y,ec.x)dv=ed>=0 and ed or 2*math.pi+ed;du=math.pi/2-math.acos(ec.z/aj)end;return setmetatable({latitude=math.deg(du),longitude=math.deg(dv),altitude=dw,id=l_.id,systemId=l_.systemId},MapPosition)end;local m0=lZ(planet,e5)m0="::pos{"..m0.systemId..","..m0.id..","..m0.latitude..","..m0.longitude..","..m0.altitude.."}"if lY then return m0 else system.setWaypoint(m0)return true end end;local m1=false;function cG.showWayPoint(planet,e5,lY)return lX(planet,e5,lY)end;function cG.APTick()local function m2()if bO and not BrakeLanding then local c7=bO[1]local gb,gc=bO[2],bO[3]local m3=math.min(gb,gc or gb)local m4=m3/bs;local m5=AutoTakeoff and(bs<42 or ao~=-1)local m6=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if m6 and not m5 and(a8*1.5>m3 or m4<1)then BrakeIsOn=true;cs(0)if AltitudeHold then cE()end;if LockPitch then ToggleLockPitch()end;a2="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then cH()end;StrongBrakes=true;BrakeLanding=true;b0=true end;if m4<11 then bN=c7.name.." COLLISION "..cM(m4).." / "..cz(m3,2)else bN=c7.name.." collision "..cM(m4)end;if m4<6 then c9("alarm","AL",2)end else bN=false end end;local function m7(c3,m8,m9)local function ma(c3,dS)c3=vec3(c3)dS=vec3(dS):normalize()local db=c3*dS;return db.x+db.y+db.z end;local mb=0.001;local mc=1;if not aq or not b2 or ao~=-1 or bs<Q then if m9==nil then m9=DampingMultiplier end;if m8==nil then m8=mb end;c3=vec3(c3):normalize()local md=vec3()-c3;local me=-ma(md,core.getConstructWorldOrientationRight())*mc;local mf=-ma(md,core.getConstructWorldOrientationUp())*mc;if aB==0 then aB=me/2 end;if aC==0 then aC=mf/2 end;if d(me)<0.1 then V=V-me*2 else V=V-(me+(me-aB)*m9)end;if d(mf)<0.1 then U=U+mf*2 else U=U+mf+(mf-aC)*m9 end;aB=me;aC=mf;if d(me)<m8 and d(mf)<m8 then return true end;return false elseif b2 and ao==-1 then c3=br;if m9==nil then m9=DampingMultiplier end;if m8==nil then m8=mb end;c3=vec3(c3):normalize()local md=bo-c3;local me=-ma(md,core.getConstructWorldOrientationRight())*mc;local mf=-ma(md,core.getConstructWorldOrientationUp())*mc;if aB==0 then aB=me/2 end;if aC==0 then aC=mf/2 end;if d(me)<0.1 then V=V-me*5 else V=V-(me+(me-aB)*m9)end;if d(mf)<0.1 then U=U+mf*5 else U=U+mf+(mf-aC)*m9 end;aB=me;aC=mf;if d(me)<m8 and d(mf)<m8 then return true end;return false end end;aq=k()>0;ar=k()as=core.getAltitude()ao=lR()E=q()b3=E;if CollisionSystem then m2()end;if antigrav then by=antigrav.getState()==1 end;local mg=1;local mh=1;local mi=E-b3;local mj=-math.deg(bW(bn,br,bo))local mk=math.deg(bW(bp,br,bo))local hd=bt*-1;b2=aq and mj<-YawStallAngle or mj>YawStallAngle or mk<-PitchStallAngle or mk>PitchStallAngle;local ml=system.getMouseDeltaX()local mm=system.getMouseDeltaY()if InvertMouse and not a1 then mm=-mm end;V=0;Z=0;U=0;sys=aR[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=aU(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),br)if as==0 then as=(bv-planet.center):len()-planet.radius end;bM=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local kX=planet:getGravity(core.getConstructWorldPos()):len()*av;b4=0;aT=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if x()==0 then if m()==1 and a1 then if not aZ then ag=r(ag+ml,-aG/2,aG/2)ah=r(ah+mm,-aH/2,aH/2)end else ag=0;ah=0 end else ag=r(ag+ml,-aG/2,aG/2)ah=r(ah+mm,-aH/2,aH/2)aj=y(ag*ag+ah*ah)if not a1 and m()==0 then local i7,i8=ml,mm;if SelectedTab=="SCOPE"then i7,i8=scopeFOV/90,scopeFOV/90 end;if userControlScheme=="virtual joystick"then if ag>0 and ag>DeadZone then V=V-(ag-DeadZone)*MouseXSensitivity*i7 elseif ag<0 and ag<DeadZone*-1 then V=V-(ag+DeadZone)*MouseXSensitivity*i7 else V=0 end;if ah>0 and ah>DeadZone then U=U-(ah-DeadZone)*MouseYSensitivity*i8 elseif ah<0 and ah<DeadZone*-1 then U=U-(ah+DeadZone)*MouseYSensitivity*i8 else U=0 end else ag=0;ah=0;if userControlScheme=="mouse"then U=(-utils.smoothstep(mm,-100,100)+0.5)*2*mg;V=(-utils.smoothstep(ml,-100,100)+0.5)*2*mh end end end end;local mn=bs>8334;if bs>SpaceSpeedLimit/3.6 and not aq and not Autopilot and not mn then a2="Space Speed Engine Shutoff reached"cs(0)end;if not mn and LastIsWarping then if not BrakeIsOn then cJ()end;if Autopilot then cH()end end;LastIsWarping=mn;if aq and ar>0.09 then if bs>b7/3.6 and not AtmoSpeedAssist and not lP then BrakeIsOn=true;lP=true elseif not AtmoSpeedAssist and lP then if bs<b7/3.6 then BrakeIsOn=false;lP=false end end end;if BrakeIsOn then Y=1 else Y=0 end;if ProgradeIsOn then if al then BrakeIsOn=false;local mo=false;if CustomTarget and al~=1 then mo=m7(CustomTarget.position-bv,0.1)else mo=m7(vec3(br),0.01)end;b0=true;if mo then cv(e(b7))if(d(bC)<2 or d(bB)>85)and bs>=b7/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;R=true;if al~=1 then an=true end;al=false;Autopilot=false;cK()end elseif aq and AtmoSpeedAssist then cs(1)end elseif bs>Q then m7(vec3(br),0.01)end end;if RetrogradeIsOn then if aq then RetrogradeIsOn=false elseif bs>Q then m7(-vec3(br))end end;if not ProgradeIsOn and al and not IntoOrbit then if ar==0 then R=true;cK()al=false;an=true else al=false;cH()end end;if an and CustomTarget and(as<HoldAltitude+250 and as>HoldAltitude-250)and bs*3.6>b7-250 and d(bu)<25 and ar>=0.1 and(CustomTarget.position-bv):len()>2000+as then cH()an=false end;if VertTakeOff then b0=true;local mp=HoldAltitude;if bu<-30 then a2="Unable to achieve lift. Safety Landing."af=0;b0=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and by or HoldAltitude<planet.spaceEngineMinAltitude then if by then mp=antigrav.getBaseAltitude()end;if as<mp-100 then b8=0;af=15;BrakeIsOn=false elseif bu>0 then BrakeIsOn=true;af=0 elseif bu<-30 then BrakeIsOn=true;af=15 elseif as>=mp then if by then if Autopilot or VectorToTarget then cC()else BrakeIsOn=true;VertTakeOff=false end;a2="Takeoff complete. Singularity engaged"c9("aggLk","AG")else BrakeIsOn=false;a2="VTO complete. Engaging Horizontal Flight"c9("vtoc","VT")cC()end;af=0 end else if ar>0.08 then b8=0;BrakeIsOn=false;af=20 elseif ar<0.08 and ar>0 then BrakeIsOn=false;if bk then b8=0;af=20 else af=0;b8=36;cv(3500)end else b0=autoRollPreference;IntoOrbit=true;bi=false;CancelIntoOrbit=false;bc=false;ba=nil;bb=nil;if bh==nil then bh=planet end;bg=mp;bf=true;VertTakeOff=false end end;if b8~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local mq=r(b8-bB,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(mq)local mr=r(vTpitchPID:get(),-1,1)U=mr end end;if IntoOrbit then local md;local ms=false;local mt=cz(bg)if bh==nil then bh=planet;if VectorToTarget then bh=ac end end;if not bf then bg=e(bh.radius+bh.surfaceMaxAltitude+LowOrbitHeight)if bh.hasAtmosphere then bg=e(bh.radius+bh.noAtmosphericDensityAltitude+LowOrbitHeight)end;bf=true end;if be.VectorToTarget and CustomTarget then md=CustomTarget.position-bv end;local mu,mv=aU(bh):escapeAndOrbitalSpeed((bv-bh.center):len()-bh.radius)local mw=bC;if not bc then local mx=false;local my=false;cs(0)bb=0;b9="Aligning to orbital path - OrbitHeight: "..mt;if be.VectorToTarget then m7(md:normalize():project_on_plane(bt))ms=bo:dot(md:project_on_plane(bn):normalize())>0.95 else m7(br)ms=mj<0.5;if bs<150 then ms=true end end;U=0;ba=0;if bB<=ba+1 and bB>=ba-1 then mx=true else mx=false end;if mw<=bb+1 and mw>=bb-1 then my=true else my=false end;if mx and my and ms then ba=nil;bb=nil;bc=true end else if be.VectorToTarget then m7(md:normalize():project_on_plane(bt))elseif bs>150 then m7(br)end;U=0;if be.VectorToTarget and CustomTarget then local a8,_=aS.computeDistanceAndTime(bs,b7/3.6,av,0,0,LastMaxBrake)if bi and md:len()>15000+a8+as then b9="Orbiting to Target"if as-100<=bh.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<bh.noAtmosphericDensityAltitude then bi=false end elseif bi or md:len()<15000+a8+as then a2="Orbit complete, proceeding with reentry"c9("orCom","OB")AutopilotTargetCoords=CustomTarget.position;R=true;an=true;be.VectorToTarget,be.AutopilotAlign=false,false;cD()cK()return end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and as>bg*0.9 and as<bg*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bg*0.99 and orbit.apoapsis.altitude>=bg*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bi then if bi then BrakeIsOn=false;cs(0)ba=0;if not be.VectorToTarget then a2="Orbit complete"c9("orCom","OB")cD()end else bm=bm+1;if bm>=2 then bi=true end end else b9="Adjusting Orbit - OrbitHeight: "..mt;bd=true;cv(mv*3.6+1)local mz=bg-as;if VSpdPID==nil then VSpdPID=pid.new(0.1,0,1*0.1)end;VSpdPID:inject(mz-bu*r(utils.smoothstep(2000-mz,-2000,2000)^6*10,1,10))ba=r(VSpdPID:get(),-60,60)end end else local mA=2.75;local mB=d(A(mu*mA))local mC=mB%50;if mC>0 then mB=mB-mC+50 end;BrakeIsOn=false;if as<bg*0.8 then b9="Escaping planet gravity - OrbitHeight: "..mt;ba=utils.map(bu,200,0,-15,80)elseif as>=bg*0.8 and as<bg*1.15 then b9="Approaching orbital corridor - OrbitHeight: "..mt;mB=mB*0.75;ba=utils.map(bu,100,-100,-15,65)elseif as>=bg*1.15 and as<bg*1.5 then b9="Approaching orbital corridor - OrbitHeight: "..mt;mB=mB*0.75;if bu<0 or bd then ba=utils.map(as,bg*1.5,bg*1.01,-30,0)else ba=utils.map(as,bg*0.99,bg*1.5,0,30)end elseif as>bg*1.5 then b9="Reentering orbital corridor - OrbitHeight: "..mt;ba=-65;local mD=utils.map(bu,-150,-400,1,0.55)mB=mB*mD end;cv(e(mB))end end;if ba~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local mE=ba-bB;OrbitPitchPID:inject(mE)local mF=r(OrbitPitchPID:get(),-0.5,0.5)U=mF end end;if Autopilot and ar==0 and not al then local function mG(bV,orbit)system.print(bV)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cs(0)P=false;a2=bV;c9("apCom","AP")if orbit or al then if orbit and AutopilotTargetOrbit~=nil and not al then if not as or as==0 then return end;bg=as;bf=true end;cD()end end;local mH,mI=AutopilotTargetCoords,false;if CustomTarget and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local mJ=(CustomTarget.position-ac.center):normalize()local mK=mJ:project_on_plane((ac.center-bv):normalize()):normalize()local mL=ac.center+mK*(ac.radius+AutopilotTargetOrbit)local mM=CustomTarget.position+(CustomTarget.position-ac.center):normalize()*(AutopilotTargetOrbit-ac:getAltitude(CustomTarget.position))if(bv-mL):len()<(bv-mM):len()then mH=mL else mH=mM;AutopilotEndSpeed=0 end;AutopilotTargetCoords=mH;aX.showWayPoint(ac,AutopilotTargetCoords)mI=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget and CustomTarget.planetname=="Space"then if not TargetSet then AutopilotPlanetGravity=0;mI=true;AutopilotRealigned=true;TargetSet=true;mH=CustomTarget.position+(bv-CustomTarget.position):normalize()*AutopilotSpaceDistance;AutopilotTargetCoords=mH end elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local mJ=(bv+br*100000-ac.center):normalize()local mK=mJ:project_on_plane((ac.center-bv):normalize()):normalize()if mK:len()<1 then mJ=(bv+bo*100000-ac.center):normalize()mK=mJ:project_on_plane((ac.center-bv):normalize()):normalize()end;mH=ac.center+mK*(ac.radius+AutopilotTargetOrbit)AutopilotTargetCoords=mH;TargetSet=true;mI=true;AutopilotRealigned=true;aX.showWayPoint(ac,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(mH)-bv):len()local c4,c5,c6=aR:getPlanetarySystem(0):castIntersections(bv,br:normalize(),function(c7)if c7.noAtmosphericDensityAltitude>0 then return c7.radius+c7.noAtmosphericDensityAltitude else return c7.radius+c7.surfaceMaxAltitude*1.5 end end)local c8=c5;if c6~=nil and c5~=nil then c8=math.min(c6,c5)end;if c8~=nil and c8<AutopilotDistance and c4.name==ac.name then AutopilotDistance=c8 end;local mo=true;local mN=(ac.center-(bv+vec3(br):normalize()*AutopilotDistance)):len()-ac.radius;local iM=cz(mN)u(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..iM..'"}')local a8,a9;if not TurnBurn then a8,a9=lM(bs)else a8,a9=lO(bs)end;if bs>50 and AutopilotAccelerating then local md=vec3(mH)-bv;local mO=r(math.deg(bW(bn,br:normalize(),md:normalize()))*bs/500,-90,90)local mP=r(math.deg(bW(bp,br:normalize(),md:normalize()))*bs/500,-90,90)if d(mO)<20 and d(mP)<20 then mO=mO*2;mP=mP*2 end;if d(mO)<2 and d(mP)<2 then mO=mO*2;mP=mP*2 end;local mj=-math.deg(bW(bn,bo,br:normalize()))local mk=-math.deg(bW(bp,bo,br:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(mP-mk)local mQ=r(apPitchPID:get(),-1,1)U=U+mQ;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(mO-mj)local mR=r(apYawPID:get(),-1,1)V=V+mR;mI=true;if d(mO)>2 or d(mP)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"c9("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"c9("apAcc","AP")end end elseif AutopilotAccelerating and bs<=50 then m7((mH-bv):normalize())end;if mN<AutopilotTargetOrbit*1.5 then if CustomTarget and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=aU(ac):escapeAndOrbitalSpeed(mN)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local c4,c8=c2((AutopilotTargetCoords-bv):normalize())if ac.name~=planet.name then if c4~=nil and ac.name~=c4.name and c8<AutopilotDistance then a2="Collision with "..c4.name.." in "..cz(c8).."\nClear LOS to continue."ai=5;m1=true else m1=false;a2=""end end end;if not m1 then if not AutopilotCruising and not AutopilotBraking and not mI then mo=m7((mH-bv):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then mo=m7(-vec3(br):normalize())end end;if AutopilotAccelerating then if not P then BrakeIsOn=false;cs(AutopilotInterplanetaryThrottle)K=A(AutopilotInterplanetaryThrottle,2)P=true end;local mS=unit.getThrottle()if AtmoSpeedAssist then mS=K end;local mT=99999;local l8=-vec3(core.getWorldAcceleration()):dot(br:normalize())local mU=r(br:dot((mH-bv):normalize()),0,bs)if mU>0 or l8>0 then mT=aS.computeTravelTime(mU,l8,AutopilotDistance-a8)end;if bq:len()>=MaxGameVelocity or mS==0 and P or warmup/4>mT then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then c9("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;cs(0)end;local mV=AutopilotDistance;if mV<=a8 or PreventPvP and bI<=a8+10000 and bH then if PreventPvP and bI<=a8+10000 and bH then if bI<lQ and bI>2000 then cH()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;lQ=bI else lQ=bI;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then c9("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;cs(0)P=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;Y=1 end;if TurnBurn then cs(1,true)end;local _,mv=aU(ac):escapeAndOrbitalSpeed((bv-planet.center):len()-planet.radius)local md;if CustomTarget then md=CustomTarget.position-bv end;if CustomTarget and CustomTarget.planetname=="Space"and bs<50 then mG("Autopilot complete, arrived at space location")BrakeIsOn=true;Y=1 elseif CustomTarget and CustomTarget.planetname~="Space"and bs<=mv and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then mG("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aX.showWayPoint(ac,AutopilotTargetCoords)elseif(CustomTarget and CustomTarget.planetname~="Space"or CustomTarget==nil)and orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then c9("apCir","AP")AutopilotStatus="Circularizing"end;if bs<=mv then if CustomTarget then if br:normalize():dot(md:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then c9("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;aX.showWayPoint(ac,CustomTarget.position)WaypointSet=true end else mG("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aX.showWayPoint(ac,CustomTarget.position)WaypointSet=false end else mG("Autopilot completed, setting orbit",true)Y=0 end end elseif AutopilotStatus=="Circularizing"then mG("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then local mV=AutopilotDistance;if mV<=a8 or PreventPvP and bI<=a8+10000 and bH then if PreventPvP and bI<=a8+10000 and bH then if bI<lQ and bI>2000 then cH()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;lQ=bI else lQ=bI;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then c9("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local mS=unit.getThrottle()if AtmoSpeedAssist then mS=K end;if mS>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"c9("apAcc","AP")end;AutopilotCruising=false end else if mo then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget and CustomTarget.planetname~="Space"then if not al then AutopilotTargetCoords=vec3(ac.center)+(AutopilotTargetOrbit+ac.radius)*bp;AutopilotShipUp=bn;AutopilotShipRight=bp end;AutopilotRealigned=true elseif mo and not m1 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"c9("apAcc","AP")end;if not P then cs(AutopilotInterplanetaryThrottle,true)K=A(AutopilotInterplanetaryThrottle,2)P=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and ar>0)then a2="Autopilot complete, starting reentry"c9("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"Y=0;cs(0)P=false;ProgradeIsOn=true;al=true;aX.showWayPoint(ac,CustomTarget.position)end;if a0 then b0=true;local mP=0;local eN=bv+vec3(unit.getMasterPlayerRelativePosition())local mW=eN-bv;local mX=vec3(mW):project_on(bo):len()local mY=vec3(mW):project_on(bp):len()local aj=y(mX*mX+mY*mY)m7(mW:normalize())local jW=40;local mZ=aj<jW;local m_=100;local n0=r((aj-jW)/2,10,m_)U=0;local mo=d(V)<0.1;if mo and bs<n0 and not mZ then BrakeIsOn=false;mP=-20 else BrakeIsOn=true;mP=0 end;local n1=0;if d(mP-bB)>n1 then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(mP-bB)local mQ=pitchPID:get()U=mQ end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local n2=LastMaxBrakeInAtmo;if n2 then n2=n2*r(bs/100,0.1,1)*ar else n2=LastMaxBrake end;if ar<0.01 then n2=LastMaxBrake end;local n3=bo:project_on_plane(bt):normalize():dot(br)local n4=vec3(core.getWorldAirFrictionAcceleration())local n5=n4:len()*av;if n3>100 then a8,a9=aS.computeDistanceAndTime(n3,100,av,0,0,n2)local n6,n7=aS.computeDistanceAndTime(100,0,av,0,0,n2*0.55)a8=a8+n6 else a8,a9=aS.computeDistanceAndTime(n3,0,av,0,0,n2*0.55)end;local mz=HoldAltitude-as-bu;local n8=200+bs;if Reentry or al then minMax=2000+bs end;local n9=1;if AutoTakeoff then n9=r(bs/100,0.1,1)end;local mP=(utils.smoothstep(mz,-n8,n8)-0.5)*2*MaxPitch*n9;if not Reentry and not al and not VectorToTarget and bo:dot(br:normalize())<0.99 then mP=(utils.smoothstep(mz,-n8*r(20-19*ar*10,1,20),n8*r(20-19*ar*10,1,20))-0.5)*2*MaxPitch*r(2-ar*10,1,2)*n9 end;if not AltitudeHold then mP=0 end;if LockPitch~=nil then if bM and not IntoOrbit then mP=LockPitch else LockPitch=nil end end;b0=true;local na=U;if Reentry then local nb=e(b7)local nc,nd=aS.computeDistanceAndTime(bs,nb/3.6,av,0,0,LastMaxBrake-planet.gravity*9.8*av)nc=nc==-1 and 5000 or nc;local ne=as-(planet.noAtmosphericDensityAltitude+nc)local nf=as>planet.noAtmosphericDensityAltitude+nc*1.35;if nf then mP=ReEntryPitch;if bs<=nb/3.6 and bs>nb/3.6-10 and d(br:normalize():dot(bo))>0.9 and not bA then O=false;cs(1)end elseif bA and not nf and not aq then cv(nb,true)end;if bA then if bs>nb/3.6 and not nf then BrakeIsOn=true else BrakeIsOn=false end else BrakeIsOn=false end;if bu>0 then BrakeIsOn=true end;if not R then mP=-80;if ar>0.02 then a2="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;mP=0;b0=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and nf then b0=true elseif not nf then if not aq and(bA or s:getTargetSpeed(axisCommandId.longitudinal)~=nb)then cv(nb)end;if bs<nb/3.6+1 then BrakeIsOn=false;R=false;Reentry=false;b0=true end end end;if bs>Q and not am and not VectorToTarget and not BrakeLanding and ForceAlignment then m7(vec3(br))end;if bK or(VectorToTarget or am)and AutopilotTargetIndex>0 and ar>0.01 then local md;if bK then if type(bK)=="table"then md=bK elseif bK<3 and bK>0 then md=-bt:cross(br)*5000 elseif bK>=3 then md=bt:cross(br)*5000 elseif bK<0 then md=br*25000 end elseif CustomTarget~=nil then md=CustomTarget.position-bv else md=ac.center-bv end;local mO=math.deg(bW(bt:normalize(),br,md))*2;local jZ=math.rad(d(bC))if bs>minRollVelocity and ar>0.01 then local ng=1000+bs;local nh=(utils.smoothstep(mz-bu*10,-ng,ng)-0.5)*2*MaxPitch;local ni=r(90-nh,0,180)b4=r(mO*2,-ni,ni)local nj=mO;mO=r(r(mO,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(jZ)+4*(bB-mP)*math.sin(math.rad(bC)),-YawStallAngle*0.80,YawStallAngle*0.80)local nk=1;if b4~=0 then nk=d(jZ/b4)end;nk=(90-r(d(b4-bC),0,90))/90;local nl=mP;if d(bC)>90 then nl=-nl end;mP=nk*r(r(nl*math.cos(jZ),-PitchStallAngle*0.8,PitchStallAngle*0.8)+d(r(d(nj)*math.sin(jZ),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else b4=0;mO=r(mO,-YawStallAngle*0.80,YawStallAngle*0.80)end;local nm=mj-mO;if bK and d(nm)<=0.0001 and(type(bK)=="table"or type(bK)~="table"and bK<0 and d(bC)<1)then if bK==-2 then cE()end;bK=nil;c9("180Off","BR")return end;if not b2 and bs>minRollVelocity and ar>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(nm)local mR=r(yawPID:get(),-1,1)V=V+mR elseif aq and ao>-1 or bs<minRollVelocity then m7(md)elseif b2 and ar>0.01 then if(mj<-YawStallAngle or mj>YawStallAngle)and ar>0.01 then m7(br)end;if(mk<-PitchStallAngle or mk>PitchStallAngle)and ar>0.01 then mP=r(bB-mk,bB-PitchStallAngle*0.80,bB+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not am then local mp=planet:getAltitude(CustomTarget.position)local ne=md:project_on_plane(bt):len()StrongBrakes=true;if not am and not Reentry and ne<=a8 and(br:project_on_plane(bt):normalize():dot(md:project_on_plane(bt):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"cs(0)if AltitudeHold then cE()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(n3<0.1 or ne<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<ne)then if not by then c9("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bN=false end;LastDistanceToTarget=ne end elseif VectorToTarget and ar==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(am or Reentry)then if CustomTarget~=nil and ac.name==planet.name then local md=CustomTarget.position-bv;local mp=planet:getAltitude(CustomTarget.position)local ne=y(md:len()^2-(as-mp)^2)local n2=LastMaxBrakeInAtmo;if n2 then a8,a9=aS.computeDistanceAndTime(bs,0,av,0,0,n2/2)StrongBrakes=true;if ne<=a8+bs*mi/2 and br:project_on_plane(bt):normalize():dot(md:project_on_plane(bt):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;R=true;al=false;an=true;Autopilot=false;cK()end end;LastDistanceToTarget=ne end end end;if ar==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(am or IntoOrbit or Reentry)then if not bi and not IntoOrbit then bg=HoldAltitude;bf=true;if VectorToTarget then be.VectorToTarget=true end;cD()VectorToTarget=false;bc=true end end;if b2 and ar>0.01 and ao==-1 and bs>minRollVelocity and VectorStatus~="Finalizing Approach"then m7(br)mP=r(bB-mk,bB-PitchStallAngle*0.80,bB+PitchStallAngle*0.80)end;U=na;local lW=-1;if BrakeLanding then mP=0;local nn=false;local no=30;if aT~=nil and aT>0 then local np=r(ar,0.4,2)local n2=LastMaxBrakeInAtmo*r(bs/100,0.1,1)*np;local nq=aT*np+n2-kX;local nr=n2/2-kX;local ns=bs-y(d(nr/2)*20/(0.5*av))*utils.sign(nr)if ns<0 then ns=0 end;local nt;if bs>100 then local nu,_=aS.computeDistanceAndTime(bs,100,av,0,0,n2)local nw,_=aS.computeDistanceAndTime(100,0,av,0,0,y(n2))nt=nu+nw else nt=aS.computeDistanceAndTime(bs,0,av,0,0,y(n2))end;if nt<20 then BrakeIsOn=false else local nx=0;if ns>100 then local ny,_=aS.computeDistanceAndTime(ns,100,av,0,0,nq)local nz,_=aS.computeDistanceAndTime(100,0,av,0,0,aT*np+y(n2)-kX)nx=ny+nz else nx,_=aS.computeDistanceAndTime(ns,0,av,0,0,aT*np+y(n2)-kX)end;nx=(nx+15+bs*mi)*1.1;local nA=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if nA then local mp=planet:getAltitude(CustomTarget.position)local nB=as-mp-100;local md=CustomTarget.position-bv;local nC=y(md:len()^2-(as-mp)^2)if nC>100 then nA=false elseif nB<=nx or nx==-1 then BrakeIsOn=true;nn=true else BrakeIsOn=false;nn=true end end;if not nA and CalculateBrakeLandingSpeed then if nx>=no then BrakeIsOn=true else BrakeIsOn=false end;nn=true end end end;if not bA then cs(0)end;s:setTargetGroundAltitude(500)s:activateGroundEngineAltitudeStabilization(500)stablized=true;lW=ao;if lW>-1 then b0=autoRollPreference;if bs<1 or br:normalize():dot(bt)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if S then a.control.extendLandingGears()c9("grOut","LG",1)end;s:setTargetGroundAltitude(LandingGearGroundHeight)af=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and br:normalize():dot(-hd)<0.999 then BrakeIsOn=true elseif bu<-brakeLandingRate and not nn then BrakeIsOn=true elseif not nn then BrakeIsOn=false end end;if AutoTakeoff or am then local c4,c6,c5;if AutopilotTargetCoords~=nil then c4,c6,c5=aR:getPlanetarySystem(0):castIntersections(bv,(AutopilotTargetCoords-bv):normalize(),function(c7)return c7.radius+c7.noAtmosphericDensityAltitude end)end;if by then if as>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;cs(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif d(mP)<15 and as/HoldAltitude>0.75 then AutoTakeoff=false;if not am then if bA and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif am and bs<Q then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;cs(0)elseif am then cs(0)BrakeIsOn=true end elseif am and ar==0 and ac~=nil and(c4==nil or c4.name==ac.name)then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;if not bA then cs(0)end;AutopilotAccelerating=true end end;local nD=ao>-1;local nE=bB;if(VectorToTarget or am or bK)and not nD and bs>minRollVelocity and ar>0.01 then local jZ=math.rad(d(bC))nE=bB*d(math.cos(jZ))+mk*math.sin(jZ)end;local nF=r(mP-nE,-PitchStallAngle*0.80,PitchStallAngle*0.80)if ar<0.01 and VectorToTarget then nF=r(mP-nE,-85,MaxPitch)elseif ar<0.01 then nF=r(mP-nE,-MaxPitch,MaxPitch)end;if d(bC)<5 or VectorToTarget or bK or BrakeLanding or nD or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(nF)local mQ=pitchPID:get()U=U+mQ end end;if antigrav~=nil and(antigrav and not ExternalAGG and as<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;ao=lR()return cG end;function script.onStart()local nG={}local nH={}local nI=false;local function nJ()local function nK(nL)local nM=dbHud_1.hasKey;for cV,cW in pairs(nL)do if nM(cW)then local db=g(dbHud_1.getStringValue(cW))if db~=nil then _G[cW]=db;nI=true end end end end;if dbHud_1 then if not useTheseSettings then nK(cf())coroutine.yield()nK(c)else nK(c)a2="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ai=5;nI=false end;coroutine.yield()if nI then a2="Loaded Saved Variables"aG=ResolutionX;aH=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)b0=autoRollPreference;b7=AtmoSpeedLimit;ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]elseif not useTheseSettings then a2="No Saved Variables Found - Exit HUD to save settings"end;if LastVersionUpdate<1.500 then if LowOrbitHeight<2000 then a2="Updating LowOrbitHeight to new minimum default of 2000."LowOrbitHeight=2000 end end;LastVersionUpdate=VERSION_NUMBER else a2="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<E then LastMaxBrakeInAtmo=0 end;LastStartTime=E;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a2="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ai=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function nN()local function nO(nP,nQ)if nP>nQ then nQ=nP end;local nR,nS=0,0;if ContainerOptimization>0 then nR=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then nS=FuelTankOptimization*0.05 end;nQ=nQ*(1-(nR+nS))return nQ end;local nT=core.getElementNameById;local nU=fuelX~=0 and fuelY~=0;for cV in pairs(at)do local type=core.getElementTypeById(at[cV])if o(type,'^.*Atmospheric Engine$')then if o(tostring(core.getElementTagsById(at[cV])),'^.*vertical.*$')and core.getElementForwardById(at[cV])[3]>0 then bx=true end end;if o(type,'^.*Space Engine$')then bl=true;if o(tostring(core.getElementTagsById(at[cV])),'^.*vertical.*$')then local nV=core.getElementForwardById(at[cV])if nV[3]<0 then bj=true else bk=true end end end;if type=="Landing Gear"then S=true end;if type=="Dynamic Core Unit"then local nW=j(at[cV])if nW>10000 then G=110 elseif nW>1000 then G=55 elseif nW>150 then G=27 end end;aL=aL+j(at[cV])if nU and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local nW=j(at[cV])local l4=l(at[cV])local nP=0;local h1=q()if type=="Atmospheric Fuel Tank"then local nQ=400;local nX=35.03;if nW>10000 then nQ=51200;nX=5480 elseif nW>1300 then nQ=6400;nX=988.67 elseif nW>150 then nQ=1600;nX=182.67 end;nP=l4-nX;if fuelTankHandlingAtmo>0 then nQ=nQ+nQ*fuelTankHandlingAtmo*0.2 end;nQ=nO(nP,nQ)aI[#aI+1]={at[cV],nT(at[cV]),nQ,nX,nP,h1}end;if type=="Rocket Fuel Tank"then local nQ=320;local nX=173.42;if nW>65000 then nQ=40000;nX=25740 elseif nW>6000 then nQ=5120;nX=4720 elseif nW>700 then nQ=640;nX=886.72 end;nP=l4-nX;if fuelTankHandlingRocket>0 then nQ=nQ+nQ*fuelTankHandlingRocket*0.1 end;nQ=nO(nP,nQ)aK[#aK+1]={at[cV],nT(at[cV]),nQ,nX,nP,h1}end;if type=="Space Fuel Tank"then local nQ=600;local nX=35.03;if nW>10000 then nQ=76800;nX=5480 elseif nW>1300 then nQ=9600;nX=988.67 elseif nW>150 then nQ=2400;nX=182.67 end;nP=l4-nX;if fuelTankHandlingSpace>0 then nQ=nQ+nQ*fuelTankHandlingSpace*0.2 end;nQ=nO(nP,nQ)aJ[#aJ+1]={at[cV],nT(at[cV]),nQ,nX,nP,h1}end end end;if not bx then VertTakeOff,VertTakeOffEngine=false,false end end;local function nY()if gyro~=nil then ax=gyro.getState()==1 end;if not stablized then s:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then w(1)else w(0)end;if door and(aq or not aq and as<10000)then for _,cW in pairs(door)do cW.toggle()end end;if switch then for _,cW in pairs(switch)do cW.toggle()end end;if forcefield and(aq or not aq==0 and as<10000)then for _,cW in pairs(forcefield)do cW.toggle()end end;if antigrav then by=antigrav.getState()==1;if by and not ExternalAGG then antigrav.show()end end;if m()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if S then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ao~=-1 or not aq and bq:len()<50 then BrakeIsOn=true;GearExtended=true;if S then a.control.extendLandingGears()end else BrakeIsOn=false end;s:setTargetGroundAltitude(b1)if aq and ao~=-1 then aT=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=aq end;local function nZ(cn,co,n_,ld,ij)local o0={x=cn,y=co,width=n_,height=ld,label=ij}bT[ij]=o0;return o0 end;local function o1(o2,o3,n_,ld,cn,co,o4,o5,o6,o7,cq)local o0={enableName=o2,disableName=o3,width=n_,height=ld,x=cn,y=co,toggleVar=o4,toggleFunction=o5,drawCondition=o6,hovered=false,class=cq}if o7 then table.insert(nH,o0)else table.insert(nG,o0)end;return o0 end;local function o8(o9)if not bD then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif o9=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif o9=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif o9=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bE=cf(o9)showHud=false else bE={}showHud=true end end;local function oa()bD=not bD;if bD then aF=nH;a2="Hold SHIFT to see Settings"bF=showHud else aF=nG;a2="Hold SHIFT to see Control Buttons"o8()showHud=bF end end;local function ob(cW)_G[cW]=not _G[cW]if _G[cW]then a2=cW.." set to true"else a2=cW.." set to false"end;if cW=="showHud"then bF=_G[cW]elseif cW=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local function oc()local od=50;local oe=340;local cn=500;local co=aH/2-400;local of=0;for cV,cW in pairs(cf("boolean"))do if type(_G[cW])=="boolean"then o1(cW,cW,oe,od,cn,co,function()return _G[cW]end,function()ob(cW)end,function()return true end,true)co=co+od+20;if of==9 then cn=cn+oe+20;co=aH/2-400;of=0 else of=of+1 end end end;o1("Control View","Control View",oe,od,10,aH/2-500,function()return true end,oa,function()return true end,true)o1("View Handling Settings",'Hide Handling Settings',oe,od,10,aH/2-(500-od),function()return showHandlingVariables end,function()o8("handling")end,function()return true end,true)o1("View Hud Settings",'Hide Hud Settings',oe,od,10,aH/2-(500-od*2),function()return showHudVariables end,function()o8("hud")end,function()return true end,true)o1("View Physics Settings",'Hide Physics Settings',oe,od,10,aH/2-(500-od*3),function()return showPhysicsVariables end,function()o8("physics")end,function()return true end,true)end;local function og()local function lF()local position=bv;local ga=planet.name..". "..#SavedLocations;if bP[1]then local dn,_=bP[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dn~=nil and dn~=""then ga=ga.." "..bP[1].getConstructName(dn)end end;return aW.AddNewLocation(ga,position,false,true)end;local function oh()TurnBurn=not TurnBurn end;local function oi(oj)if oj==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;a0=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function ok()aW.UpdatePosition()end;local function lE()aW.ClearCurrentPosition()end;local function ol(fW)local ga=AutopilotTargetName;if fW~=nil and type(fW)=="number"then if fW==0 then return"None"end;ga=bG[fW].name end;if ga==nil then ga=CustomTarget.name end;if ga==nil then ga="None"end;return ga end;local function om(fW)return"Engage Autopilot: "..ol(fW)end;local function on(fW)return"Disable Autopilot: "..ol(fW)end;local function oo()if m()==1 then a0=not a0;if a0 then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)c9("folOn","F")else c9("folOff","F")BrakeIsOn=true;b0=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end end else a2="Follow Mode only works with Remote controller"a0=false end end;local od=50;local oe=260;local op=gl(30)local oq=gl(OrbitMapX+OrbitMapSize*2+2)local os=gm(OrbitMapY+1)o1("+","+",op,op,oq,gm(os+op+1),function()return false end,function()scopeFOV=scopeFOV/8 end,function()return SelectedTab=="SCOPE"end,nil,"ZoomButton")o1("-","-",op,op,oq,os,function()return false end,function()scopeFOV=math.min(scopeFOV*8,90)end,function()return SelectedTab=="SCOPE"end,nil,"ZoomButton")o1("0","0",op,op,oq,os+op*2+2,function()return false end,function()scopeFOV=90 end,function()return SelectedTab=="SCOPE"and scopeFOV~=90 end,nil,"ZoomButton")local ot=o1("Enable Brake Toggle","Disable Brake Toggle",oe,od,aG/2-oe/2,aH/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a2="Brakes in Toggle Mode"else a2="Brakes in Default Mode"end end)o1("Align Prograde","Disable Prograde",oe,od,aG/2-oe/2-50-ot.width,aH/2-od+380,function()return ProgradeIsOn end,function()oi(1)end)o1("Align Retrograde","Disable Retrograde",oe,od,aG/2-oe/2+ot.width+50,aH/2-od+380,function()return RetrogradeIsOn end,oi,function()return ar==0 end)apbutton=o1(om,on,600,60,aG/2-600/2,aH/2-60/2-330,function()return Autopilot or VectorToTarget or am or IntoOrbit end,function()end)local i;local function ou(ov)local fW=bS+ov;if fW>#bG then fW=fW-#bG-1 end;if fW<0 then fW=#bG+fW end;return fW end;apExtraButtons={}for i=0,10 do local button=o1(function(cy)local fW=ou(cy.apExtraIndex)if Autopilot or VectorToTarget or am or IntoOrbit then return"Redirect: "..ol(fW)end;return om(fW)end,function(cy)local fW=ou(cy.apExtraIndex)return on(fW)end,600,60,aG/2-600/2,aH/2-60/2-330+60*i,function(cy)local fW=ou(cy.apExtraIndex)return fW==AutopilotTargetIndex and(Autopilot or VectorToTarget or am or IntoOrbit)end,function(cy)local fW=ou(cy.apExtraIndex)local ow=AutopilotTargetIndex==fW;AutopilotTargetIndex=fW;aW.UpdateAutopilotTarget()cH()if not ow and not(Autopilot or VectorToTarget or am or IntoOrbit)then cH()end end,function()return bR end)button.apExtraIndex=i;apExtraButtons[i]=button end;o1("Save Position","Save Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,lF,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)o1("Update Position","Update Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,ok,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)o1("Clear Position","Clear Position",200,apbutton.height,apbutton.x-200-30,apbutton.y,function()return true end,lE,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)od=60;oe=300;local cn=aG-oe-10;local co=aH/2-150;o1("View Settings","View Settings",oe,od,cn,co,function()return true end,oa)co=co+od+20;o1("Enable Turn and Burn","Disable Turn and Burn",oe,od,cn,co,function()return TurnBurn end,oh)cn=10;co=aH/2-300;o1("Horizontal Takeoff Mode","Vertical Takeoff Mode",oe,od,cn+oe+20,co,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a2="Vertical Takeoff Mode"else a2="Horizontal Takeoff Mode"end end,function()return bx end)co=co+od+20;o1("Engage Orbiting","Cancel Orbiting",oe,od,cn+oe+20,co,function()return IntoOrbit end,cD,function()return ar==0 and bM end)co=co+od+20;o1("Glide Re-Entry","Cancel Glide Re-Entry",oe,od,cn,co,function()return Reentry end,function()al=1;oi(1)end,function()return planet.hasAtmosphere and not aq end)o1("Parachute Re-Entry","Cancel Parachute Re-Entry",oe,od,cn+oe+20,co,function()return Reentry end,cK,function()return planet.hasAtmosphere and not aq end)co=co+od+20;o1("Engage Follow Mode","Disable Follow Mode",oe,od,cn,co,function()return a0 end,oo,function()return m()==1 end)o1("Enable Repair Arrows","Disable Repair Arrows",oe,od,cn+oe+20,co,function()return aM end,function()aM=not aM;if aM then a2="Repair Arrows Enabled"else a2="Repair Arrows Diabled"end end,function()return m()==1 end)co=co+od+20;if not ExternalAGG then o1("Enable AGG","Disable AGG",oe,od,cn,co,function()return by end,cL,function()return antigrav~=nil end)end;o1(function()return f("Switch IPH Mode - Current: %s",iphCondition)end,function()return f("IPH Mode: %s",iphCondition)end,oe*2,od,cn,co,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a2="IPH Mode: "..iphCondition end)co=co+od+20;o1(function()return f("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return f("Control Scheme: %s",userControlScheme)end,oe*2,od,cn,co,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a2="New Control Scheme: "..userControlScheme end)local ox=gm(20)local button=nZ(0,0,gl(70),ox,"INFO")button=nZ(button.x+button.width,button.y,gl(80),ox,"ORBIT")button=nZ(button.x+button.width,button.y,gl(70),ox,"HELP")button=nZ(button.x+button.width,button.y,gl(70),ox,"HIDE")button=nZ(button.x+button.width,button.y,gl(70),ox,"SCOPE")end;local function oy()local oz={}local function oA()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local oB={[1]=4480,[6]=4480,[7]=6270}for oC,oD in pairs(b)do b[oC][0]=oA()b[oC][0].systemId=oC;oz[oC]={}for oE,planet in pairs(b[oC])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]planet.noAtmosphericDensityAltitude=planet.atmosphereThickness or planet.atmosphereRadius-planet.radius;planet.spaceEngineMinAltitude=oB[planet.id]or 0.68377*(planet.atmosphereThickness or planet.atmosphereRadius-planet.radius)planet.planetarySystemId=oC;planet.bodyId=planet.id;oz[oC][oE]=planet;if minAtlasX==nil or planet.center.x<minAtlasX then minAtlasX=planet.center.x end;if maxAtlasX==nil or planet.center.x>maxAtlasX then maxAtlasX=planet.center.x end;if minAtlasY==nil or planet.center.y<minAtlasY then minAtlasY=planet.center.y end;if maxAtlasY==nil or planet.center.y>maxAtlasY then maxAtlasY=planet.center.y end;if planet.center and planet.name~="Space"then bU[#bU+1]=planet end end end;aQ=cX()aR=aQ(oz)aS=eh()aU=eL()aY=f8()aV=gn()aW=ls()end;SetupComplete=false;beginSetup=coroutine.create(function()s:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})nJ()coroutine.yield()nN()coroutine.yield()aX=lL()nY()oc()og()aF=nG;coroutine.yield()oy()coroutine.yield()unit.hide()system.showScreen(1)system.showHelper(0)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)bP[1]=nil;if radar_1 then bP[1]=radar_1;aY.pickType()end;c9("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(ar>0 or ar==0 and as<10000)then for _,cW in pairs(door)do cW.toggle()end end;if switch then for _,cW in pairs(switch)do cW.toggle()end end;if forcefield and(ar>0 or ar==0 and as<10000)then for _,cW in pairs(forcefield)do cW.toggle()end end;cR()if button then button.activate()end;if SetWaypointOnExit then aX.showWayPoint(planet,bv)end;c9("stop","SU")end;function script.onTick(oF)local oG=nil;if oF=="contact"then if not contactTimer then contactTimer=0 end;if E>contactTimer+10 then a2="Radar Contact"c9("rdrCon","RC")contactTimer=E end;unit.stopTimer("contact")elseif oF=="tenthSecond"then local function oH()local oI=system.createData;local oJ=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=oJ(panelInterplanetary,"value")interplanetaryHeaderText=oI('{"label": "Target Planet", "value": "N/A", "unit":""}')v(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=oJ(panelInterplanetary,"value")widgetDistanceText=oI('{"label": "distance", "value": "N/A", "unit":""}')v(widgetDistanceText,widgetDistance)widgetTravelTime=oJ(panelInterplanetary,"value")widgetTravelTimeText=oI('{"label": "Travel Time", "value": "N/A", "unit":""}')v(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=oJ(panelInterplanetary,"value")widgetMaxMassText=oI('{"label": "Maximum Mass", "value": "N/A", "unit":""}')v(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=oJ(panelInterplanetary,"value")widgetTargetOrbitText=oI('{"label": "Target Altitude", "value": "N/A", "unit":""}')v(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=oJ(panelInterplanetary,"value")widgetCurBrakeDistanceText=oI('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=oJ(panelInterplanetary,"value")widgetCurBrakeTimeText=oI('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=oJ(panelInterplanetary,"value")widgetMaxBrakeDistanceText=oI('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=oJ(panelInterplanetary,"value")widgetMaxBrakeTimeText=oI('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=oJ(panelInterplanetary,"value")widgetTrajectoryAltitudeText=oI('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not aq then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)v(widgetCurBrakeTimeText,widgetCurBrakeTime)v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function oK()t(panelInterplanetary)panelInterplanetary=nil end;local function oL()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ac.center-bv):len()else AutopilotDistance=(CustomTarget.position-bv):len()end end;local eJ=bs;local mS=unit.getThrottle()/100;if AtmoSpeedAssist then mS=K end;local oM,oN=aS.computeDistanceAndTime(bs,MaxGameVelocity,av,a:maxForceForward()*mS,warmup,0)local a8,a9;if not TurnBurn then a8,a9=aX.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aX.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,oO;if not TurnBurn and eJ>0 then _,oO=aX.GetAutopilotBrakeDistanceAndTime(eJ)else _,oO=aX.GetAutopilotTBBrakeDistanceAndTime(eJ)end;local oP=0;local oQ=0;if AutopilotCruising or not Autopilot and eJ>5 then oQ=aS.computeTravelTime(eJ,0,AutopilotDistance)elseif a8+oM<AutopilotDistance then oP=AutopilotDistance-(a8+oM)oQ=aS.computeTravelTime(8333.0556,0,oP)else local oR=(AutopilotDistance-a8)/oM;oM=AutopilotDistance-a8;oN=oN*oR end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return oQ elseif AutopilotBraking then return oO elseif AutopilotCruising then return oQ+oO else return oN+a9+oQ end end;local function oS(kX,oT)if kX==nil then kX=core.g()end;kX=A(kX,5)if oT~=nil and oT or(oG==nil or oG~=kX)then local eJ=bq:len()local oU=g(unit.getData()).maxBrake;if oU~=nil and oU>0 and aq then oU=oU/r(eJ/100,0.1,1)oU=oU/ar;if ar>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+oU)/2 else LastMaxBrakeInAtmo=oU end end end;if oU~=nil and oU>0 then LastMaxBrake=oU end;oG=kX end end;oS(nil,true)if bz~=nil then if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or s:getTargetSpeed(axisCommandId.longitudinal)~=bz then cv(bz)else bz=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then oH()end;if AutopilotTargetName~=nil then local oV=CustomTarget~=nil;local oW=0.5*LastMaxBrakeInAtmo/ac:getGravity(ac.center+vec3(0,0,1)*ac.radius):len()oW=oW>1000000 and A(oW/1000000,2).." kTons"or A(oW/1000,2).." Tons"u(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=oL()if oV and not Autopilot then aj=(bv-CustomTarget.position):len()else aj=(AutopilotTargetCoords-bv):len()end;if not TurnBurn then a8,a9=aX.GetAutopilotBrakeDistanceAndTime(bs)aa,ab=aX.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aX.GetAutopilotTBBrakeDistanceAndTime(bs)aa,ab=aX.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local iM=cz(aj)u(widgetDistanceText,'{"label": "distance", "value": "'..iM..'"}')u(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..cM(travelTime)..'", "unit":""}')iM=cz(a8)u(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..iM..'"}')u(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..cM(a9)..'", "unit":""}')iM=cz(aa)u(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..iM..'"}')u(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..cM(ab)..'", "unit":""}')u(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..f("%s",oW)..'", "unit":""}')iM=cz(AutopilotTargetOrbit)u(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..iM..'"}')if ar>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not bA and AtmoSpeedAssist and(AltitudeHold or Reentry or an)then cs(1)BrakeIsOn=false;O=false end end;if ar==0 and WasInAtmo then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else oK()end;if warpdrive~=nil then if g(warpdrive.getData()).destination~="Unknown"and g(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;aV.DrawTanks()if shield_1 then aV.DrawShield()end elseif oF=="oneSecond"then local function oX(h9)local oY=0;aD=""local oZ=aL;local o_=0;local p0=0;local p1=0;local h5=0;local h6=""local p2=core.getElementHitPointsById;for cV in pairs(at)do local nW=0;local p3=0;p3=j(at[cV])nW=p2(at[cV])o_=o_+nW;if nW<p3 then if nW==0 then p1=p1+1 else p0=p0+1 end;if aM and#aA==0 then position=vec3(core.getElementPositionById(at[cV]))local cn=position.x;local co=position.y;local fD=position.z;table.insert(aA,core.spawnArrowSticker(cn,co,fD+1,"down"))table.insert(aA,core.spawnArrowSticker(cn,co,fD+1,"down"))core.rotateSticker(aA[2],0,0,90)table.insert(aA,core.spawnArrowSticker(cn+1,co,fD,"north"))table.insert(aA,core.spawnArrowSticker(cn+1,co,fD,"north"))core.rotateSticker(aA[4],90,90,0)table.insert(aA,core.spawnArrowSticker(cn-1,co,fD,"south"))table.insert(aA,core.spawnArrowSticker(cn-1,co,fD,"south"))core.rotateSticker(aA[6],90,-90,0)table.insert(aA,core.spawnArrowSticker(cn,co-1,fD,"east"))table.insert(aA,core.spawnArrowSticker(cn,co-1,fD,"east"))core.rotateSticker(aA[8],90,0,90)table.insert(aA,core.spawnArrowSticker(cn,co+1,fD,"west"))table.insert(aA,core.spawnArrowSticker(cn,co+1,fD,"west"))core.rotateSticker(aA[10],-90,0,90)table.insert(aA,at[cV])end elseif aM and#aA>0 and aA[11]==at[cV]then for h0 in pairs(aA)do core.deleteSticker(aA[h0])end;aA={}end end;oY=e(o_/oZ*100)if oY<100 then if oY>0 and oY<WipeDamage then SavedLocations={}aW.UpdateAtlasLocationsList()aW.UpdateAutopilotTarget()cR()end;h9[#h9+1]=cm(0,0,"","pbright txt")h5=e(oY*2.55)h6=f("rgb(%d,%d,%d)",255-h5,h5,0)if oY<100 then h9[#h9+1]=cm("50%",1035,"Elemental Integrity: "..oY.."%","txtbig txtmid","fill:"..h6)if p1>0 then h9[#h9+1]=cm("50%",1055,"Disabled Modules: "..p1 .." Damaged Modules: "..p0,"txtbig txtmid","fill:"..h6)elseif p0>0 then h9[#h9+1]=cm("50%",1055,"Damaged Modules: "..p0,"txtbig txtmid","fill:"..h6)end end end end;local function p4()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then t(WeaponPanelID)WeaponPanelID=nil end end end;local function p5()local h1=q()local im=bs;local p6=h1-au;if im>1.38889 then im=im/1000;local p7=im*(h1-au)TotalDistanceTravelled=TotalDistanceTravelled+p7;ad=ad+p7 end;ae=ae+p6;TotalFlightTime=TotalFlightTime+p6;au=h1 end;p5()aV.UpdatePipe()passengers=core.getPlayersOnBoard()ships=core.getDockedConstructs()p4()local h9={}aV.ExtraData(h9)if ShouldCheckDamage then oX(h9)end;ak=table.concat(h9,"")collectgarbage("collect")elseif oF=="fiveSecond"then if not UseSatNav then return end;ap=dbHud_1.getStringValue("SPBAutopilotTargetName")if ap~=nil and ap~=""and ap~="SatNavNotChanged"then local db=g(dbHud_1.getStringValue("SavedLocations"))if db~=nil then _G["SavedLocations"]=db;local fW=-1;local lH;for cV,cW in pairs(SavedLocations)do if cW.name and cW.name=="SatNav Location"then fW=cV;break end end;if fW~=-1 then lH=SavedLocations[fW]fW=-1;for cV,cW in pairs(b[0])do if cW.name and cW.name=="SatNav Location"then fW=cV;break end end;if fW>-1 then b[0][fW]=lH end;aW.UpdateAtlasLocationsList()a2=lH.name.." position updated"end end;for i=1,#bG do if bG[i].name==ap then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bG[i].name)aW.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif oF=="msgTick"then local h9={}aV.DisplayMessage(h9,"empty")a2="empty"unit.stopTimer("msgTick")ai=3 elseif oF=="animateTick"then a_=true;aZ=false;ag=0;ah=0;unit.stopTimer("animateTick")elseif oF=="hudTick"then if not planet then return end;local function p8(h9)local p9=e(r(aj/(aG/4)*255,0,255))h9[#h9+1]=f("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ag,ah,e(H+0.5)+p9,e(J+0.5)-p9,e(I+0.5)-p9)end;local function pa()for _,cW in pairs(aF)do if cW.hovered then if not cW.drawCondition or cW.drawCondition(cW)then cW.toggleFunction(cW)end;cW.hovered=false end end;for _,cW in pairs(bT)do if cW.hovered then SelectedTab=cW.label;cW.hovered=false end end end;local function pb()local function pc(pd,pe,cn,co,n_,ld)if pd>=cn and pd<=cn+n_ and pe>=co and pe<=co+ld then return true else return false end end;local cn=ag+aG/2;local co=ah+aH/2;for _,cW in pairs(aF)do cW.hovered=pc(cn,co,cW.x,cW.y,cW.width,cW.height)end;for _,cW in pairs(bT)do cW.hovered=pc(cn,co,cW.x,cW.y,cW.width,cW.height)end;if bR then local kn=false;for _,cy in ipairs(apExtraButtons)do if cy.hovered then kn=true;break end end;if apbutton.hovered then kn=true end;bR=kn else bR=apbutton.hovered;if not bR then bS=AutopilotTargetIndex end end end;local function pf(h9)if not SelectedTab or SelectedTab==""then SelectedTab="INFO"end;for cV,cW in pairs(bT)do local cq="dim brightstroke"local pg=0.2;if SelectedTab==cV then cq="pbright dimstroke"pg=0.6 end;local ph=""if cW.hovered then pg=0.8;ph=";stroke:white"end;h9[#h9+1]=f([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],cW.width,cW.height,cW.x,cW.y,cq,pg,ph)h9[#h9+1]=cm(cW.x+cW.width/2,cW.y+cW.height/2+5,cW.label,"txt txtmid pdim")end end;local function pi(h9)local function pj(h9,pk,hover,cn,co,eC,pl,pm,pn,po,pp,button)if type(po)=="function"then po=po(button)end;if type(pp)=="function"then pp=pp(button)end;h9[#h9+1]=f("<rect x='%f' y='%f' width='%f' height='%f' fill='",cn,co,eC,pl)if pk then h9[#h9+1]=f("%s'",pm)else h9[#h9+1]=pn end;if hover then h9[#h9+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",SafeR,SafeG,SafeB)else h9[#h9+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",A(SafeR*0.5,0),A(SafeG*0.5,0),A(SafeB*0.5,0))end;h9[#h9+1]=" rx='5'></rect>"h9[#h9+1]=f("<text x='%f' y='%f' font-size='24' fill='",cn+eC/2,co+pl/2+5)if pk then h9[#h9+1]="black"else h9[#h9+1]="white"end;h9[#h9+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if pk then h9[#h9+1]=f("%s</text>",po)else h9[#h9+1]=f("%s</text>",pp)end end;local pq=f("rgb(%d,%d,%d)'",A(SafeR*0.1,0),A(SafeG*0.1,0),A(SafeB*0.1,0))local pr=f("rgb(%d,%d,%d)",A(SafeR*0.8,0),A(SafeG*0.8,0),A(SafeB*0.8,0))local ps=pj;for _,cW in pairs(aF)do local o3=cW.disableName;local o2=cW.enableName;if type(o3)=="function"then o3=o3(cW)end;if type(o2)=="function"then o2=o2(cW)end;if not cW.drawCondition or cW.drawCondition(cW)then ps(h9,cW.toggleVar(cW),cW.hovered,cW.x,cW.y,cW.width,cW.height,pr,pq,o3,o2,cW)end end end;local pt=A(aG/2,0)local pu=A(aH/2,0)local h9={}aV.HUDPrologue(h9)if showHud then aV.UpdateHud(h9)else if AlwaysVSpd then aV.DrawVerticalSpeed(h9,as)end;aV.DisplayOrbitScreen(h9)aV.DrawWarnings(h9)end;if bD and bE~={}then aV.DrawSettings(h9)end;if radar_1 or radar_2 then aY.assignRadar()end;if bP[1]then aV.DrawRadarInfo()end;aV.HUDEpilogue(h9)h9[#h9+1]=f([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aG,aH)if a2~="empty"then aV.DisplayMessage(h9,a2)end;if m()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then aV.DrawDeadZone(h9)end end;pf(h9)if x()==0 then if m()==1 and a1 then if not AltIsOn then pb()pi(h9)end;if not aZ and not a_ then local pv=table.concat(h9,"")h9={}h9[#h9+1]=f("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aG,aH)h9[#h9+1]=pv;h9[#h9+1]="</body>"aZ=true;h9[#h9+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(h9,"")system.setScreen(content)elseif a_ then local pv=table.concat(h9,"")h9={}h9[#h9+1]=f("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aG,aH)h9[#h9+1]=pv;h9[#h9+1]="</body>"end;if not aZ then h9[#h9+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],pt,pu,ag,ah)end else pa()end else if not a1 and m()==0 then pa()if aj>DeadZone then if DisplayDeadZone then p8(h9)end end elseif not AltIsOn and a1 then pb()pi(h9)end;h9[#h9+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],pt,pu,ag,ah)end;h9[#h9+1]=[[</svg></body>]]content=table.concat(h9,"")elseif oF=="apTick"then aX.APTick()elseif oF=="radarTick"then aY.UpdateRadar()elseif oF=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;a2="Extra Engine Tags: "..UseExtra;unit.stopTimer("tagTick")end end;function script.onFlush()local function pw(px,n0)local py=vec3()local pz=vec3()if px==axisCommandId.longitudinal then py=vec3(core.getConstructOrientationForward())pz=bo elseif px==axisCommandId.vertical then py=vec3(core.getConstructOrientationUp())pz=bn elseif px==axisCommandId.lateral then py=vec3(core.getConstructOrientationRight())pz=bp else return vec3()end;local pA=vec3(core.getWorldGravity())local pB=pA:dot(pz)local pC=vec3(core.getWorldAirFrictionAcceleration())local pD=pC:dot(pz)local pE=bq:dot(py)local pF=n0*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(pF-pE)local pG=targetSpeedPID2:get()local pH=(pG-pD-pB)*pz;return pH end;local function pI(px,n0)local py=vec3()local pz=vec3()if px==axisCommandId.longitudinal then py=vec3(core.getConstructOrientationForward())pz=bo elseif px==axisCommandId.vertical then py=vec3(core.getConstructOrientationUp())pz=bn elseif px==axisCommandId.lateral then py=vec3(core.getConstructOrientationRight())pz=bp else return vec3()end;local pA=vec3(core.getWorldGravity())local pB=pA:dot(pz)local pC=vec3(core.getWorldAirFrictionAcceleration())local pD=pC:dot(pz)local pE=bq:dot(py)local pF=n0*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(pF-pE)local pG=targetSpeedPID:get()local pH=(pG-pD-pB)*pz;return pH end;local function pJ(pK,hc,lx)local pL=pK:cross(lx):normalize_inplace()local hZ=math.acos(r(pL:dot(-hc),-1,1))*constants.rad2deg;if pL:cross(-hc):dot(lx)<0 then hZ=-hZ end;return hZ end;if antigrav and not ExternalAGG then if not by and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bA=s:getAxisCommandType(0)==axisCommandType.byThrottle;if bA and O then cs(0)O=false elseif not bA and not O then K=0;O=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local pM=r(T+U+system.getControlDeviceForwardInput(),-1,1)local pN=r(W+Z+system.getControlDeviceYawInput(),-1,1)local pO=r(X+V-system.getControlDeviceLeftRightInput(),-1,1)local pP=Y;bt=vec3(core.getWorldVertical())if bt==nil or bt:len()==0 then bt=(planet.center-bv):normalize()end;bn=vec3(core.getConstructWorldOrientationUp())bo=vec3(core.getConstructWorldOrientationForward())bp=vec3(core.getConstructWorldOrientationRight())br=vec3(core.getWorldVelocity())bq=vec3(core.getVelocity())bv=vec3(core.getConstructWorldPos())av=core.getConstructMass()bs=vec3(br):len()bu=-bt:dot(br)bC=getRoll(bt,bo,bp)local pQ=bC/180*math.pi;local pR=math.cos(pQ)local pS=math.sin(pQ)bB=pJ(bt,bo,bp*pR+bn*pS)local pT=br:normalize()local pU=d(bC)local pV=utils.sign(bC)local pW=vec3(core.getWorldAngularVelocity())local pX=pM*pitchSpeedFactor*bp+pN*rollSpeedFactor*bo+pO*yawSpeedFactor*bn;if b0==true and bt:len()>0.01 then local pY=d(b4-bC)if((ProgradeIsOn or Reentry or BrakeLanding or al or AltitudeHold or IntoOrbit)and pY>0 or ar>0.0 and pY<autoRollRollThreshold and autoRollPreference)and pN==0 and d(bB)<85 then local pZ=b4;local p_=autoRollFactor;if ar==0 then p_=p_/4;b4=0;pZ=0 end;if rollPID==nil then rollPID=pid.new(p_*0.01,0,p_*0.1)end;rollPID:inject(pZ-bC)local q0=rollPID:get()pX=pX+q0*bo end end;local q1=1;local q2=0;local q3=1;local q4=system.getMouseWheel()if q4>0 then b_()elseif q4<0 then b_(true)else aw=true end;L=0;if aq and AtmoSpeedAssist and bA then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(b7/3.6-br:dot(bo))local q5=throttlePID:get()N=r(q5,-1,1)if N<K and ar>0.005 then M=true;s:setThrottleCommand(axisCommandId.longitudinal,r(N,0.01,1))else M=false;s:setThrottleCommand(axisCommandId.longitudinal,K)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(br:len()-b7/3.6)local q6=r(brakePID:get(),0,1)if ar>0 and bu<-80 or ar>0.005 then L=q6 end;if L>0 then if M and N==0.01 then s:setThrottleCommand(axisCommandId.longitudinal,0)end else N=r(N,0.01,1)end;local q7=''local q8=vec3()local q9=pw(axisCommandId.vertical,af*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",q9,q2)local qa='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then qa=qa..ExtraLongitudeTags end;local qb=s:getAxisCommandType(axisCommandId.longitudinal)local qc=s:composeAxisAccelerationFromThrottle(qa,axisCommandId.longitudinal)local qd=pI(axisCommandId.lateral,LeftAmount*1000)q7=q7 ..' , '.."lateral airfoil , lateral ground "q8=q8+qd;if q8:len()>constants.epsilon then a:setEngineForceCommand(q7,q8,q2,'','','',q3)end;a:setEngineForceCommand(qa,qc,q1)local qe='thrust analog vertical fueled 'local qf='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then qf=qf..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then qe=qe..ExtraVerticalTags end;if af~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(qe,q9,q1)else a:setEngineForceCommand(qe,vec3(),q1)end;if LeftAmount~=0 then a:setEngineForceCommand(qf,qd,q1)else a:setEngineForceCommand(qf,vec3(),q1)end;if pP==0 then pP=L end;local qg=-pP*(brakeSpeedFactor*br+brakeFlatFactor*pT)a:setEngineForceCommand('brake',qg)else if AtmoSpeedAssist then s:setThrottleCommand(axisCommandId.longitudinal,K)end;local n0=unit.getAxisCommandValue(0)if not bA then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(br:len()-n0/3.6)local q6=r(brakePID:get(),0,1)pP=r(pP+q6,0,1)end;local qg=-pP*(brakeSpeedFactor*br+brakeFlatFactor*pT)a:setEngineForceCommand('brake',qg)local q7=''local q8=vec3()local qh=false;local qa='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then qa=qa..ExtraLongitudeTags end;local qb=s:getAxisCommandType(axisCommandId.longitudinal)if qb==axisCommandType.byThrottle then local qc=s:composeAxisAccelerationFromThrottle(qa,axisCommandId.longitudinal)a:setEngineForceCommand(qa,qc,q1)elseif qb==axisCommandType.byTargetSpeed then local qc=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)q7=q7 ..' , '..qa;q8=q8+qc;if s:getTargetSpeed(axisCommandId.longitudinal)==0 or s:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-s:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then qh=true end end;local qf='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then qf=qf..ExtraLateralTags end;local qi=s:getAxisCommandType(axisCommandId.lateral)if qi==axisCommandType.byThrottle then local qj=s:composeAxisAccelerationFromThrottle(qf,axisCommandId.lateral)a:setEngineForceCommand(qf,qj,q1)elseif qi==axisCommandType.byTargetSpeed then local qd=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)q7=q7 ..' , '..qf;q8=q8+qd end;local qe='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then qe=qe..ExtraVerticalTags end;local qk=s:getAxisCommandType(axisCommandId.vertical)if qk==axisCommandType.byThrottle then local q9=s:composeAxisAccelerationFromThrottle(qe,axisCommandId.vertical)if af~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(qe,q9,q1,'airfoil','ground','',q3)else a:setEngineForceCommand(qe,vec3(),q1)a:setEngineForceCommand('airfoil vertical',q9,q1,'airfoil','','',q3)a:setEngineForceCommand('ground vertical',q9,q1,'ground','','',q3)end elseif qk==axisCommandType.byTargetSpeed then if af<0 then a:setEngineForceCommand('hover',vec3(),q1)end;local ql=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)q7=q7 ..' , '..qe;q8=q8+ql end;if q8:len()>constants.epsilon then if Y~=0 or qh or d(pT:dot(bo))<0.5 then q7=q7 ..', brake'end;a:setEngineForceCommand(q7,q8,q2,'','','',q3)end end;local qm=torqueFactor*(pX-pW)local qn=vec3(core.getWorldAirFrictionAngularAcceleration())qm=qm-qn;a:setEngineTorqueCommand('torque',qm,q1,'airfoil','','',q3)a:setBoosterCommand('rocket_engine')if a7 and not VanillaRockets then local eJ=bq:len()local qo=0.15;if not bA then local qp=s:getTargetSpeed(axisCommandId.longitudinal)if eJ*3.6>qp*(1-qo)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eJ*3.6<qp*(1-qo)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local mS=unit.getThrottle()if AtmoSpeedAssist then mS=K*100 end;local n0=mS/100;if k==0 then n0=n0*MaxGameVelocity;if eJ>=n0*(1-qo)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eJ<n0*(1-qo)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local nb=e(b7)n0=n0*nb/3.6;if eJ>=n0*(1-qo)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eJ<n0*(1-qo)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local gi=coroutine.status(beginSetup)if gi=="suspended"then local ct,gj=coroutine.resume(beginSetup)if gj then system.print("ERROR STARTUP: "..gj)end elseif gi=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not aZ and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(qq)local function qr(c0)local D=1;local function qs(qt,c0)local qu={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local qv=qt;for _,cW in ipairs(qu)do if c0 and qv>cW then qt=cW elseif qt<cW and not c0 then qt=cW;break end end;return qt end;if c0 then D=-1 end;if not ExternalAGG and by then if a1 and c0 then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a4;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+D*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a1 then bg=qs(bg,c0)else bg=bg+D*a3 end;if bg<planet.noAtmosphericDensityAltitude then bg=planet.noAtmosphericDensityAltitude end else if a1 and aq then HoldAltitude=qs(HoldAltitude,c0)else HoldAltitude=HoldAltitude+D*a3 end end else s:updateTargetGroundAltitudeFromActionStart(D*1.0)end end;local function qw(qx)if not aq then a2="Flight Assist in Atmo only"return end;local d1=type(qx)if bK==nil then if d1=="table"then if Autopilot or VectorToTarget then cH()end;c9("180On","BR")elseif qx==1 then c9("bnkLft","BR")else c9("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then cE()if d1~="table"then qx=qx+1 end end;bK=qx else c9("180Off","BR")bK=nil end end;if qq=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;cs(0)if vBooster or hover then if aq and ao==-1 then c9("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;b0=true;GearExtended=false else if S then c9("grOut","LG",1)a.control.extendLandingGears()end;s:setTargetGroundAltitude(LandingGearGroundHeight)if aq then BrakeIsOn=true end end end;if S and not BrakeLanding and not(vBooster or hover)then c9("grOut","LG",1)a.control.extendLandingGears()end else if S then c9("grIn","LG",1)a.control.retractLandingGears()end;s:setTargetGroundAltitude(TargetHoverHeight)end elseif qq=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif qq=="forward"then T=T-1 elseif qq=="backward"then if AltIsOn then qw(-br*5000)else T=T+1 end elseif qq=="left"then if AltIsOn then qw(1)else W=W-1 end elseif qq=="right"then if AltIsOn then qw(3)else W=W+1 end elseif qq=="yawright"then X=X-1 elseif qq=="yawleft"then X=X+1 elseif qq=="straferight"then s:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif qq=="strafeleft"then s:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif qq=="up"then af=af+1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif qq=="down"then af=af-1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif qq=="groundaltitudeup"then qr()elseif qq=="groundaltitudedown"then qr(true)elseif qq=="option1"then toggleView=false;if AltIsOn and a1 then local qy=""for i=1,#passengers do qy=qy.."| Name: "..system.getPlayerName(passengers[i]).." Mass: "..A(core.getBoardedPlayerMass(passengers[i])/1000,1).."t "end;system.print("Onboard: "..qy)return end;aW.adjustAutopilotTargetIndex()elseif qq=="option2"then toggleView=false;if AltIsOn and a1 then for i=1,#passengers do core.forceDeboard(passengers[i])end;a2="Deboarded All Passengers"return end;aW.adjustAutopilotTargetIndex(1)elseif qq=="option3"then local function qz()aE=not aE;if not aE then c9("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end;parentingPanelId=system.createWidgetPanel("Docking")parentingWidgetId=system.createWidget(parentingPanelId,"parenting")system.addDataToWidget(unit.getDataId(),parentingWidgetId)coreCombatStressPanelId=system.createWidgetPanel("Core combat stress")coreCombatStressgWidgetId=system.createWidget(coreCombatStressPanelId,"core_stress")system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)if shield_1~=nil then shield_1.show()end else c9("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then t(fuelPanelID)fuelPanelID=nil end;if parentingPanelId~=nil then t(parentingPanelId)parentingPanelId=nil end;if coreCombatStressPanelId~=nil then t(coreCombatStressPanelId)coreCombatStressPanelId=nil end;if spacefuelPanelID~=nil then t(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then t(rocketfuelPanelID)rocketfuelPanelID=nil end;if shield_1~=nil then shield_1.hide()end end end;if AltIsOn and a1 then local qy=""for i=1,#ships do qy=qy.."| ID: "..ships[i].." Mass: "..A(core.getDockedConstructMass(ships[i])/1000,1).."t "end;system.print("Docked Ships: "..qy)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;qz()toggleView=false elseif qq=="option4"then toggleView=false;if AltIsOn and a1 then for i=1,#ships do core.forceUndock(ships[i])end;a2="Undocked all ships"return end;bK=nil;cH()elseif qq=="option5"then toggleView=false;function ToggleLockPitch()if LockPitch==nil then c9("lkPOn","LP")if not a1 then LockPitch=bB else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else c9("lkPOff","LP")LockPitch=nil end end;ToggleLockPitch()elseif qq=="option6"then toggleView=false;if AltIsOn and a1 then if shield_1 then local qA=shield_1.getVentingCooldown()if qA>0 then a2="Cannot vent again for "..qA.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()a2="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else a2="Shields already at max hitpoints"end;return else a2="No shield found"return end end;cE()elseif qq=="option7"then toggleView=false;if AltIsOn and a1 then if shield_1 then shield_1.toggle()return else a2="No shield found"return end end;CollisionSystem=not CollisionSystem;if CollisionSystem then a2="Collision System Enabled"else a2="Collision System Secured"end elseif qq=="option8"then stablized=not stablized;if not stablized then a2="DeCoupled Mode - Ground Stabilization off"s:deactivateGroundEngineAltitudeStabilization()c9("gsOff","GS")else a2="Coupled Mode - Ground Stabilization on"s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)c9("gsOn","GS")end;toggleView=false elseif qq=="option9"then if AltIsOn and a1 then s:resetCommand(axisCommandId.longitudinal)s:resetCommand(axisCommandId.lateral)s:resetCommand(axisCommandId.vertical)cs(0)unit.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ax=gyro.getState()==1;if ax then c9("gyOn","GA")else c9("gyOff","GA")end end;toggleView=false elseif qq=="lshift"then bR=false;if AltIsOn then a1=true end;if x()==1 then a1=true;PrevViewLock=x()w(1)elseif m()==1 and ShiftShowsRemoteButtons then a1=true;a_=false;aZ=false end elseif qq=="brake"then if BrakeToggleStatus or AltIsOn then cJ()elseif not BrakeIsOn then cJ()else BrakeIsOn=true end elseif qq=="lalt"then toggleView=true;AltIsOn=true;if m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(1)end elseif qq=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a7 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a7=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a7=false end elseif qq=="stopengines"then local function qB()if E-F<1.5 then c9("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bK=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;a0=false;P=false;al=false;am=false;R=false;b0=autoRollPreference;VectorToTarget=false;TurnBurn=false;ax=false;LockPitch=nil;IntoOrbit=false end end;qB()F=E;if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if K~=0 then s:resetCommand(axisCommandId.longitudinal)cs(0)else cs(100)end else if s:getTargetSpeed(axisCommandId.longitudinal)~=0 then s:resetCommand(axisCommandId.longitudinal)else if aq then cv(AtmoSpeedLimit)else cv(MaxGameVelocity*3.6)end end end elseif qq=="speedup"then b_()elseif qq=="speeddown"then b_(true)elseif qq=="antigravity"and not ExternalAGG then if antigrav~=nil then cL()end end end;function script.onActionStop(qq)local function qC()if not ExternalAGG and by then a6=a4 end;if AltitudeHold or VertTakeOff or IntoOrbit then a5=a3 end end;if qq=="forward"then T=0 elseif qq=="backward"then T=0 elseif qq=="left"then if bK then if bK==2 then bK=-2 else bK=-1 end end;W=0 elseif qq=="right"then if bK then if bK==4 then bK=-2 else bK=-1 end end;W=0 elseif qq=="yawright"then X=0 elseif qq=="yawleft"then X=0 elseif qq=="straferight"then s:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif qq=="strafeleft"then s:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif qq=="up"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif qq=="down"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif qq=="groundaltitudeup"then qC()toggleView=false elseif qq=="groundaltitudedown"then qC()toggleView=false elseif qq=="lshift"then if x()==1 then ag=0;ah=0;w(PrevViewLock)elseif m()==1 and ShiftShowsRemoteButtons then a_=false;aZ=false end;a1=false elseif qq=="brake"then if not BrakeToggleStatus and not AltIsOn then if BrakeIsOn then cJ()else BrakeIsOn=false end end elseif qq=="lalt"then if m()==0 and freeLookToggle then if toggleView then if x()==1 then w(0)else w(1)end else toggleView=true end elseif m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(0)end;AltIsOn=false end end;function script.onActionLoop(qq)local function qD(c0)local D=1;if c0 then D=-1 end;if not ExternalAGG and by then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a6;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a6=r(a6*1.05,a4,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+D*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bg=bg+D*a5;if bg<planet.noAtmosphericDensityAltitude then bg=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+D*a5 end;a5=r(a5*1.05,a3,50)else s:updateTargetGroundAltitudeFromActionLoop(D*1.0)end end;local function qE(c0)local D=1;if c0 then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then K=r(K+D*speedChangeSmall/100,-1,1)else s:updateCommandFromActionLoop(axisCommandId.longitudinal,D*speedChangeSmall)end end end;if qq=="groundaltitudeup"then if not a1 then qD()end elseif qq=="groundaltitudedown"then if not a1 then qD(true)end elseif qq=="speedup"then qE()elseif qq=="speeddown"then qE(true)end end;function script.onInputText(cp)local function qF(qG,eN,hV)local function qH(eN)local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local d9='::pos{'..B..','..B..','..B..','..B..','..B..'}'local dm,dn,du,dv,dw=o(eN,d9)if dm=="0"and dn=="0"then return vec3(z(du),z(dv),z(dw))end;dv=math.rad(dv)du=math.rad(du)local planet=b[z(dm)][z(dn)]local ee=math.cos(du)local qI=vec3(ee*math.cos(dv),ee*math.sin(dv),math.sin(du))return planet.center+(planet.radius+dw)*qI end;local position=qH(eN)return aW.AddNewLocation(qG,position,hV)end;local i;local qJ,qK=nil,nil;local qL="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute".."/deletewp - Deletes current selected custom wp"i=string.find(cp," ")qJ=cp;if i~=nil then qJ=string.sub(cp,0,i-1)qK=string.sub(cp,i+1)end;if qJ=="/help"or qJ=="/commands"then for le in string.gmatch(qL,"([^\n]+)")do system.print(le)end;return elseif qJ=="/setname"then if qK==nil or qK==""then a2="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then aW.UpdatePosition(qK)else a2="Select a saved target to rename first"end elseif shield_1 and qJ=="/resist"then if qK==nil or shield_1.getResistancesCooldown()>0 then a2="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local d9=B..', '..B..', '..B..', '..B;local qM,qN,qO,qP=o(qK,d9)if qP==nil or qM+qN+qO+qP>0.6 then a2="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(qM,qN,qO,qP)==1 then a2="Shield Resistances set"else a2="Resistance setting failed."end elseif qJ=="/addlocation"or string.find(cp,"::pos")~=nil then local hV=false;local qG="0-Temp"if qK==nil or qK==""then qK=qJ;hV=true end;i=string.find(qK,"::")if not hV then qG=string.sub(qK,1,i-2)end;local eN=string.sub(qK,i)qF(qG,eN,hV)elseif qJ=="/agg"then if qK==nil or qK==""then a2="Usage: /agg targetheight"return end;qK=z(qK)if qK<1000 then qK=1000 end;AntigravTargetAltitude=qK;a2="AGG Target Height set to "..qK elseif qJ=="/G"then if qK==nil or qK==""then a2="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if qK=="dump"then for cV,cW in pairs(cf())do if type(_G[cW])=="boolean"then if _G[cW]==true then system.print(cW.." true")else system.print(cW.." false")end elseif _G[cW]==nil then system.print(cW.." nil")else system.print(cW.." ".._G[cW])end end;return end;i=string.find(qK," ")local qQ=string.sub(qK,0,i-1)local qR=string.sub(qK,i+1)for cV,cW in pairs(cf())do if cW==qQ then a2="Variable "..qQ.." changed to "..qR;local qS=type(_G[cW])if qS=="number"then qR=z(qR)if cW=="AtmoSpeedLimit"then b7=qR end elseif qS=="boolean"then if string.lower(qR)=="true"then qR=true else qR=false end end;_G[cW]=qR;return end end;a2="No such global variable: "..qQ elseif qJ=="/deletewp"then if autopilotTargetIndex>0 and CustomTarget~=nil then aW.ClearCurrentPosition()else a2="Select a custom wp to delete first in IPH"end elseif qJ=="/copydatabank"then if dbHud_2 then cR(true)else a2="Spare Databank required to copy databank"end elseif qJ=="/iphWP"then if AutopilotTargetIndex>0 then system.print(aX.showWayPoint(ac,AutopilotTargetCoords,true))a2="::pos waypoint shown in lua chat"else a2="No target selected in IPH"end end end;function script.onEnter(dn)if bP[1]and not aq and not bH then unit.setTimer("contact",0.1)end end;function script.onLeave(dn)if bP[1]and CollisionSystem then if#bL>650 then dn=tostring(dn)bL[dn]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
